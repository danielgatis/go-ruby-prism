/*----------------------------------------------------------------------------*/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/../../templates/gen_nodes.go.erb                                 */
/* if you are looking to modify the                                           */
/* template                                                                   */
/*----------------------------------------------------------------------------*/

package parser

// Flags for arguments nodes.
const (
	ArgumentsNodeFlagsCONTAINS_FORWARDING      = 1 << 2
	ArgumentsNodeFlagsCONTAINS_KEYWORDS        = 1 << 3
	ArgumentsNodeFlagsCONTAINS_KEYWORD_SPLAT   = 1 << 4
	ArgumentsNodeFlagsCONTAINS_SPLAT           = 1 << 5
	ArgumentsNodeFlagsCONTAINS_MULTIPLE_SPLATS = 1 << 6
)

// Flags for array nodes.
const (
	ArrayNodeFlagsCONTAINS_SPLAT = 1 << 2
)

// Flags for call nodes.
const (
	CallNodeFlagsSAFE_NAVIGATION   = 1 << 2
	CallNodeFlagsVARIABLE_CALL     = 1 << 3
	CallNodeFlagsATTRIBUTE_WRITE   = 1 << 4
	CallNodeFlagsIGNORE_VISIBILITY = 1 << 5
)

// Flags for nodes that have unescaped content.
const (
	EncodingFlagsFORCED_UTF8_ENCODING   = 1 << 2
	EncodingFlagsFORCED_BINARY_ENCODING = 1 << 3
)

// Flags for integer nodes that correspond to the base of the integer.
const (
	IntegerBaseFlagsBINARY      = 1 << 2
	IntegerBaseFlagsDECIMAL     = 1 << 3
	IntegerBaseFlagsOCTAL       = 1 << 4
	IntegerBaseFlagsHEXADECIMAL = 1 << 5
)

// Flags for interpolated string nodes that indicated mutability if they are also marked as literals.
const (
	InterpolatedStringNodeFlagsFROZEN  = 1 << 2
	InterpolatedStringNodeFlagsMUTABLE = 1 << 3
)

// Flags for keyword hash nodes.
const (
	KeywordHashNodeFlagsSYMBOL_KEYS = 1 << 2
)

// Flags for while and until loop nodes.
const (
	LoopFlagsBEGIN_MODIFIER = 1 << 2
)

// Flags for parameter nodes.
const (
	ParameterFlagsREPEATED_PARAMETER = 1 << 2
)

// Flags for parentheses nodes.
const (
	ParenthesesNodeFlagsMULTIPLE_STATEMENTS = 1 << 2
)

// Flags for range and flip-flop nodes.
const (
	RangeFlagsEXCLUDE_END = 1 << 2
)

// Flags for regular expression and match last line nodes.
const (
	RegularExpressionFlagsIGNORE_CASE              = 1 << 2
	RegularExpressionFlagsEXTENDED                 = 1 << 3
	RegularExpressionFlagsMULTI_LINE               = 1 << 4
	RegularExpressionFlagsONCE                     = 1 << 5
	RegularExpressionFlagsEUC_JP                   = 1 << 6
	RegularExpressionFlagsASCII_8BIT               = 1 << 7
	RegularExpressionFlagsWINDOWS_31J              = 1 << 8
	RegularExpressionFlagsUTF_8                    = 1 << 9
	RegularExpressionFlagsFORCED_UTF8_ENCODING     = 1 << 10
	RegularExpressionFlagsFORCED_BINARY_ENCODING   = 1 << 11
	RegularExpressionFlagsFORCED_US_ASCII_ENCODING = 1 << 12
)

// Flags for shareable constant nodes.
const (
	ShareableConstantNodeFlagsLITERAL                 = 1 << 2
	ShareableConstantNodeFlagsEXPERIMENTAL_EVERYTHING = 1 << 3
	ShareableConstantNodeFlagsEXPERIMENTAL_COPY       = 1 << 4
)

// Flags for string nodes.
const (
	StringFlagsFORCED_UTF8_ENCODING   = 1 << 2
	StringFlagsFORCED_BINARY_ENCODING = 1 << 3
	StringFlagsFROZEN                 = 1 << 4
	StringFlagsMUTABLE                = 1 << 5
)

// Flags for symbol nodes.
const (
	SymbolFlagsFORCED_UTF8_ENCODING     = 1 << 2
	SymbolFlagsFORCED_BINARY_ENCODING   = 1 << 3
	SymbolFlagsFORCED_US_ASCII_ENCODING = 1 << 4
)

// Location represents a location in the source code.
type Location struct {
	StartOffset int `json:"startOffset"`
	Length      int `json:"length"`
}

// RubyString represents an encoded Ruby string.
type RubyString struct {
	Value         string `json:"value"`
	Encoding      string `json:"encoding"`
	ValidEncoding bool   `json:"validEncoding"`
}

// Node represents a generic node in the tree.
type Node interface {
	Accept(visitor Visitor)
	ChildNodes() []Node
	CompactChildNodes() []Node
	ToJSON() map[string]interface{}
	GetLocation() Location
	GetNodeID() int
}

// Represents the use of the `alias` keyword to alias a global variable.
//
//	alias $foo $bar
//	^^^^^^^^^^^^^^^
type AliasGlobalVariableNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	NewName    Node     `json:"new_name"`
	OldName    Node     `json:"old_name"`
	KeywordLoc Location `json:"keyword_loc"`
}

// NewAliasGlobalVariableNode creates a new AliasGlobalVariableNode.
func NewAliasGlobalVariableNode(nodeID int, location Location, flags uint32, new_name Node, old_name Node, keyword_loc Location) *AliasGlobalVariableNode {
	return &AliasGlobalVariableNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		NewName:    new_name,
		OldName:    old_name,
		KeywordLoc: keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *AliasGlobalVariableNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *AliasGlobalVariableNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *AliasGlobalVariableNode) Accept(visitor Visitor) {
	visitor.VisitAliasGlobalVariableNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *AliasGlobalVariableNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.NewName)
	nodes = append(nodes, n.OldName)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *AliasGlobalVariableNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.NewName)
	nodes = append(nodes, n.OldName)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *AliasGlobalVariableNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "AliasGlobalVariableNode",
		"location":    n.Location,
		"flags":       n.flags,
		"new_name":    n.NewName,
		"old_name":    n.OldName,
		"keyword_loc": n.KeywordLoc,
	}
}

// Represents the use of the `alias` keyword to alias a method.
//
//	alias foo bar
//	^^^^^^^^^^^^^
type AliasMethodNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	NewName    Node     `json:"new_name"`
	OldName    Node     `json:"old_name"`
	KeywordLoc Location `json:"keyword_loc"`
}

// NewAliasMethodNode creates a new AliasMethodNode.
func NewAliasMethodNode(nodeID int, location Location, flags uint32, new_name Node, old_name Node, keyword_loc Location) *AliasMethodNode {
	return &AliasMethodNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		NewName:    new_name,
		OldName:    old_name,
		KeywordLoc: keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *AliasMethodNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *AliasMethodNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *AliasMethodNode) Accept(visitor Visitor) {
	visitor.VisitAliasMethodNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *AliasMethodNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.NewName)
	nodes = append(nodes, n.OldName)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *AliasMethodNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.NewName)
	nodes = append(nodes, n.OldName)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *AliasMethodNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "AliasMethodNode",
		"location":    n.Location,
		"flags":       n.flags,
		"new_name":    n.NewName,
		"old_name":    n.OldName,
		"keyword_loc": n.KeywordLoc,
	}
}

// Represents an alternation pattern in pattern matching.
//
//	foo => bar | baz
//	       ^^^^^^^^^
type AlternationPatternNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Left        Node     `json:"left"`
	Right       Node     `json:"right"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewAlternationPatternNode creates a new AlternationPatternNode.
func NewAlternationPatternNode(nodeID int, location Location, flags uint32, left Node, right Node, operator_loc Location) *AlternationPatternNode {
	return &AlternationPatternNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Left:        left,
		Right:       right,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *AlternationPatternNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *AlternationPatternNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *AlternationPatternNode) Accept(visitor Visitor) {
	visitor.VisitAlternationPatternNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *AlternationPatternNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Left)
	nodes = append(nodes, n.Right)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *AlternationPatternNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Left)
	nodes = append(nodes, n.Right)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *AlternationPatternNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "AlternationPatternNode",
		"location":     n.Location,
		"flags":        n.flags,
		"left":         n.Left,
		"right":        n.Right,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents the use of the `&&` operator or the `and` keyword.
//
//	left and right
//	^^^^^^^^^^^^^^
type AndNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Left        Node     `json:"left"`
	Right       Node     `json:"right"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewAndNode creates a new AndNode.
func NewAndNode(nodeID int, location Location, flags uint32, left Node, right Node, operator_loc Location) *AndNode {
	return &AndNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Left:        left,
		Right:       right,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *AndNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *AndNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *AndNode) Accept(visitor Visitor) {
	visitor.VisitAndNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *AndNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Left)
	nodes = append(nodes, n.Right)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *AndNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Left)
	nodes = append(nodes, n.Right)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *AndNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "AndNode",
		"location":     n.Location,
		"flags":        n.flags,
		"left":         n.Left,
		"right":        n.Right,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents a set of arguments to a method or a keyword.
//
//	return foo, bar, baz
//	       ^^^^^^^^^^^^^
type ArgumentsNode struct {
	NodeID    int      `json:"nodeID"`
	Location  Location `json:"location"`
	flags     uint32
	Arguments []Node `json:"arguments"`
}

// NewArgumentsNode creates a new ArgumentsNode.
func NewArgumentsNode(nodeID int, location Location, flags uint32, arguments []Node) *ArgumentsNode {
	return &ArgumentsNode{
		NodeID:    nodeID,
		Location:  location,
		flags:     flags,
		Arguments: arguments,
	}
}

// GetLocation returns the location of this node.
func (n *ArgumentsNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ArgumentsNode) GetNodeID() int {
	return n.NodeID
}

// IsCONTAINS_FORWARDING returns true if this node has the CONTAINS_FORWARDING flag.
func (n *ArgumentsNode) IsCONTAINS_FORWARDING() bool {
	return (n.flags & ArgumentsNodeFlagsCONTAINS_FORWARDING) != 0
}

// IsCONTAINS_KEYWORDS returns true if this node has the CONTAINS_KEYWORDS flag.
func (n *ArgumentsNode) IsCONTAINS_KEYWORDS() bool {
	return (n.flags & ArgumentsNodeFlagsCONTAINS_KEYWORDS) != 0
}

// IsCONTAINS_KEYWORD_SPLAT returns true if this node has the CONTAINS_KEYWORD_SPLAT flag.
func (n *ArgumentsNode) IsCONTAINS_KEYWORD_SPLAT() bool {
	return (n.flags & ArgumentsNodeFlagsCONTAINS_KEYWORD_SPLAT) != 0
}

// IsCONTAINS_SPLAT returns true if this node has the CONTAINS_SPLAT flag.
func (n *ArgumentsNode) IsCONTAINS_SPLAT() bool {
	return (n.flags & ArgumentsNodeFlagsCONTAINS_SPLAT) != 0
}

// IsCONTAINS_MULTIPLE_SPLATS returns true if this node has the CONTAINS_MULTIPLE_SPLATS flag.
func (n *ArgumentsNode) IsCONTAINS_MULTIPLE_SPLATS() bool {
	return (n.flags & ArgumentsNodeFlagsCONTAINS_MULTIPLE_SPLATS) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *ArgumentsNode) Accept(visitor Visitor) {
	visitor.VisitArgumentsNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ArgumentsNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Arguments...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ArgumentsNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Arguments...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ArgumentsNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":      "ArgumentsNode",
		"location":  n.Location,
		"flags":     n.flags,
		"arguments": n.Arguments,
	}
}

// Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
//
//	[1, 2, 3]
//	^^^^^^^^^
type ArrayNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Elements   []Node    `json:"elements"`
	OpeningLoc *Location `json:"opening_loc"`
	ClosingLoc *Location `json:"closing_loc"`
}

// NewArrayNode creates a new ArrayNode.
func NewArrayNode(nodeID int, location Location, flags uint32, elements []Node, opening_loc *Location, closing_loc *Location) *ArrayNode {
	return &ArrayNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Elements:   elements,
		OpeningLoc: opening_loc,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *ArrayNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ArrayNode) GetNodeID() int {
	return n.NodeID
}

// IsCONTAINS_SPLAT returns true if this node has the CONTAINS_SPLAT flag.
func (n *ArrayNode) IsCONTAINS_SPLAT() bool {
	return (n.flags & ArrayNodeFlagsCONTAINS_SPLAT) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *ArrayNode) Accept(visitor Visitor) {
	visitor.VisitArrayNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ArrayNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Elements...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ArrayNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Elements...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ArrayNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "ArrayNode",
		"location":    n.Location,
		"flags":       n.flags,
		"elements":    n.Elements,
		"opening_loc": n.OpeningLoc,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents an array pattern in pattern matching.
//
//	foo in 1, 2
//	^^^^^^^^^^^
//
//	foo in [1, 2]
//	^^^^^^^^^^^^^
//
//	foo in *bar
//	^^^^^^^^^^^
//
//	foo in Bar[]
//	^^^^^^^^^^^^
//
//	foo in Bar[1, 2, 3]
//	^^^^^^^^^^^^^^^^^^^
type ArrayPatternNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Constant   Node      `json:"constant"`
	Requireds  []Node    `json:"requireds"`
	Rest       Node      `json:"rest"`
	Posts      []Node    `json:"posts"`
	OpeningLoc *Location `json:"opening_loc"`
	ClosingLoc *Location `json:"closing_loc"`
}

// NewArrayPatternNode creates a new ArrayPatternNode.
func NewArrayPatternNode(nodeID int, location Location, flags uint32, constant Node, requireds []Node, rest Node, posts []Node, opening_loc *Location, closing_loc *Location) *ArrayPatternNode {
	return &ArrayPatternNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Constant:   constant,
		Requireds:  requireds,
		Rest:       rest,
		Posts:      posts,
		OpeningLoc: opening_loc,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *ArrayPatternNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ArrayPatternNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ArrayPatternNode) Accept(visitor Visitor) {
	visitor.VisitArrayPatternNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ArrayPatternNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Constant != nil {
		nodes = append(nodes, n.Constant)
	}
	nodes = append(nodes, n.Requireds...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	nodes = append(nodes, n.Posts...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ArrayPatternNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Constant != nil {
		nodes = append(nodes, n.Constant)
	}
	nodes = append(nodes, n.Requireds...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	nodes = append(nodes, n.Posts...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ArrayPatternNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "ArrayPatternNode",
		"location":    n.Location,
		"flags":       n.flags,
		"constant":    n.Constant,
		"requireds":   n.Requireds,
		"rest":        n.Rest,
		"posts":       n.Posts,
		"opening_loc": n.OpeningLoc,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents a hash key/value pair.
//
//	{ a => b }
//	  ^^^^^^
type AssocNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Key         Node      `json:"key"`
	Value       Node      `json:"value"`
	OperatorLoc *Location `json:"operator_loc"`
}

// NewAssocNode creates a new AssocNode.
func NewAssocNode(nodeID int, location Location, flags uint32, key Node, value Node, operator_loc *Location) *AssocNode {
	return &AssocNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Key:         key,
		Value:       value,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *AssocNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *AssocNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *AssocNode) Accept(visitor Visitor) {
	visitor.VisitAssocNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *AssocNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Key)
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *AssocNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Key)
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *AssocNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "AssocNode",
		"location":     n.Location,
		"flags":        n.flags,
		"key":          n.Key,
		"value":        n.Value,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents a splat in a hash literal.
//
//	{ **foo }
//	  ^^^^^
type AssocSplatNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Value       Node     `json:"value"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewAssocSplatNode creates a new AssocSplatNode.
func NewAssocSplatNode(nodeID int, location Location, flags uint32, value Node, operator_loc Location) *AssocSplatNode {
	return &AssocSplatNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Value:       value,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *AssocSplatNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *AssocSplatNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *AssocSplatNode) Accept(visitor Visitor) {
	visitor.VisitAssocSplatNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *AssocSplatNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Value != nil {
		nodes = append(nodes, n.Value)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *AssocSplatNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Value != nil {
		nodes = append(nodes, n.Value)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *AssocSplatNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "AssocSplatNode",
		"location":     n.Location,
		"flags":        n.flags,
		"value":        n.Value,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents reading a reference to a field in the previous match.
//
//	$'
//	^^
type BackReferenceReadNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewBackReferenceReadNode creates a new BackReferenceReadNode.
func NewBackReferenceReadNode(nodeID int, location Location, flags uint32, name string) *BackReferenceReadNode {
	return &BackReferenceReadNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *BackReferenceReadNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *BackReferenceReadNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *BackReferenceReadNode) Accept(visitor Visitor) {
	visitor.VisitBackReferenceReadNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *BackReferenceReadNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *BackReferenceReadNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *BackReferenceReadNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "BackReferenceReadNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents a begin statement.
//
//	begin
//	  foo
//	end
//	^^^^^
type BeginNode struct {
	NodeID          int      `json:"nodeID"`
	Location        Location `json:"location"`
	flags           uint32
	BeginKeywordLoc *Location       `json:"begin_keyword_loc"`
	Statements      *StatementsNode `json:"statements"`
	RescueClause    *RescueNode     `json:"rescue_clause"`
	ElseClause      *ElseNode       `json:"else_clause"`
	EnsureClause    *EnsureNode     `json:"ensure_clause"`
	EndKeywordLoc   *Location       `json:"end_keyword_loc"`
}

// NewBeginNode creates a new BeginNode.
func NewBeginNode(nodeID int, location Location, flags uint32, begin_keyword_loc *Location, statements *StatementsNode, rescue_clause *RescueNode, else_clause *ElseNode, ensure_clause *EnsureNode, end_keyword_loc *Location) *BeginNode {
	return &BeginNode{
		NodeID:          nodeID,
		Location:        location,
		flags:           flags,
		BeginKeywordLoc: begin_keyword_loc,
		Statements:      statements,
		RescueClause:    rescue_clause,
		ElseClause:      else_clause,
		EnsureClause:    ensure_clause,
		EndKeywordLoc:   end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *BeginNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *BeginNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *BeginNode) Accept(visitor Visitor) {
	visitor.VisitBeginNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *BeginNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	if n.RescueClause != nil {
		nodes = append(nodes, n.RescueClause)
	}
	if n.ElseClause != nil {
		nodes = append(nodes, n.ElseClause)
	}
	if n.EnsureClause != nil {
		nodes = append(nodes, n.EnsureClause)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *BeginNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	if n.RescueClause != nil {
		nodes = append(nodes, n.RescueClause)
	}
	if n.ElseClause != nil {
		nodes = append(nodes, n.ElseClause)
	}
	if n.EnsureClause != nil {
		nodes = append(nodes, n.EnsureClause)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *BeginNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":              "BeginNode",
		"location":          n.Location,
		"flags":             n.flags,
		"begin_keyword_loc": n.BeginKeywordLoc,
		"statements":        n.Statements,
		"rescue_clause":     n.RescueClause,
		"else_clause":       n.ElseClause,
		"ensure_clause":     n.EnsureClause,
		"end_keyword_loc":   n.EndKeywordLoc,
	}
}

// Represents a block argument using `&`.
//
//	bar(&args)
//	^^^^^^^^^^
type BlockArgumentNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Expression  Node     `json:"expression"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewBlockArgumentNode creates a new BlockArgumentNode.
func NewBlockArgumentNode(nodeID int, location Location, flags uint32, expression Node, operator_loc Location) *BlockArgumentNode {
	return &BlockArgumentNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Expression:  expression,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *BlockArgumentNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *BlockArgumentNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *BlockArgumentNode) Accept(visitor Visitor) {
	visitor.VisitBlockArgumentNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *BlockArgumentNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Expression != nil {
		nodes = append(nodes, n.Expression)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *BlockArgumentNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Expression != nil {
		nodes = append(nodes, n.Expression)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *BlockArgumentNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "BlockArgumentNode",
		"location":     n.Location,
		"flags":        n.flags,
		"expression":   n.Expression,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents a block local variable.
//
//	a { |; b| }
//	       ^
type BlockLocalVariableNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewBlockLocalVariableNode creates a new BlockLocalVariableNode.
func NewBlockLocalVariableNode(nodeID int, location Location, flags uint32, name string) *BlockLocalVariableNode {
	return &BlockLocalVariableNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *BlockLocalVariableNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *BlockLocalVariableNode) GetNodeID() int {
	return n.NodeID
}

// IsREPEATED_PARAMETER returns true if this node has the REPEATED_PARAMETER flag.
func (n *BlockLocalVariableNode) IsREPEATED_PARAMETER() bool {
	return (n.flags & ParameterFlagsREPEATED_PARAMETER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *BlockLocalVariableNode) Accept(visitor Visitor) {
	visitor.VisitBlockLocalVariableNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *BlockLocalVariableNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *BlockLocalVariableNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *BlockLocalVariableNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "BlockLocalVariableNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents a block of ruby code.
//
//	[1, 2, 3].each { |i| puts x }
//	               ^^^^^^^^^^^^^^
type BlockNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Locals     []string `json:"locals"`
	Parameters Node     `json:"parameters"`
	Body       Node     `json:"body"`
	OpeningLoc Location `json:"opening_loc"`
	ClosingLoc Location `json:"closing_loc"`
}

// NewBlockNode creates a new BlockNode.
func NewBlockNode(nodeID int, location Location, flags uint32, locals []string, parameters Node, body Node, opening_loc Location, closing_loc Location) *BlockNode {
	return &BlockNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Locals:     locals,
		Parameters: parameters,
		Body:       body,
		OpeningLoc: opening_loc,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *BlockNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *BlockNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *BlockNode) Accept(visitor Visitor) {
	visitor.VisitBlockNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *BlockNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Parameters != nil {
		nodes = append(nodes, n.Parameters)
	}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *BlockNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Parameters != nil {
		nodes = append(nodes, n.Parameters)
	}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *BlockNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "BlockNode",
		"location":    n.Location,
		"flags":       n.flags,
		"locals":      n.Locals,
		"parameters":  n.Parameters,
		"body":        n.Body,
		"opening_loc": n.OpeningLoc,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents a block parameter of a method, block, or lambda definition.
//
//	def a(&b)
//	      ^^
//	end
type BlockParameterNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        *string   `json:"name"`
	NameLoc     *Location `json:"name_loc"`
	OperatorLoc Location  `json:"operator_loc"`
}

// NewBlockParameterNode creates a new BlockParameterNode.
func NewBlockParameterNode(nodeID int, location Location, flags uint32, name *string, name_loc *Location, operator_loc Location) *BlockParameterNode {
	return &BlockParameterNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *BlockParameterNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *BlockParameterNode) GetNodeID() int {
	return n.NodeID
}

// IsREPEATED_PARAMETER returns true if this node has the REPEATED_PARAMETER flag.
func (n *BlockParameterNode) IsREPEATED_PARAMETER() bool {
	return (n.flags & ParameterFlagsREPEATED_PARAMETER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *BlockParameterNode) Accept(visitor Visitor) {
	visitor.VisitBlockParameterNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *BlockParameterNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *BlockParameterNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *BlockParameterNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "BlockParameterNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents a block's parameters declaration.
//
//	-> (a, b = 1; local) { }
//	   ^^^^^^^^^^^^^^^^^
//
//	foo do |a, b = 1; local|
//	       ^^^^^^^^^^^^^^^^^
//	end
type BlockParametersNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Parameters *ParametersNode `json:"parameters"`
	Locals     []Node          `json:"locals"`
	OpeningLoc *Location       `json:"opening_loc"`
	ClosingLoc *Location       `json:"closing_loc"`
}

// NewBlockParametersNode creates a new BlockParametersNode.
func NewBlockParametersNode(nodeID int, location Location, flags uint32, parameters *ParametersNode, locals []Node, opening_loc *Location, closing_loc *Location) *BlockParametersNode {
	return &BlockParametersNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Parameters: parameters,
		Locals:     locals,
		OpeningLoc: opening_loc,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *BlockParametersNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *BlockParametersNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *BlockParametersNode) Accept(visitor Visitor) {
	visitor.VisitBlockParametersNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *BlockParametersNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Parameters != nil {
		nodes = append(nodes, n.Parameters)
	}
	nodes = append(nodes, n.Locals...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *BlockParametersNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Parameters != nil {
		nodes = append(nodes, n.Parameters)
	}
	nodes = append(nodes, n.Locals...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *BlockParametersNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "BlockParametersNode",
		"location":    n.Location,
		"flags":       n.flags,
		"parameters":  n.Parameters,
		"locals":      n.Locals,
		"opening_loc": n.OpeningLoc,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents the use of the `break` keyword.
//
//	break foo
//	^^^^^^^^^
type BreakNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Arguments  *ArgumentsNode `json:"arguments"`
	KeywordLoc Location       `json:"keyword_loc"`
}

// NewBreakNode creates a new BreakNode.
func NewBreakNode(nodeID int, location Location, flags uint32, arguments *ArgumentsNode, keyword_loc Location) *BreakNode {
	return &BreakNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Arguments:  arguments,
		KeywordLoc: keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *BreakNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *BreakNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *BreakNode) Accept(visitor Visitor) {
	visitor.VisitBreakNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *BreakNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *BreakNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *BreakNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "BreakNode",
		"location":    n.Location,
		"flags":       n.flags,
		"arguments":   n.Arguments,
		"keyword_loc": n.KeywordLoc,
	}
}

// Represents the use of the `&&=` operator on a call.
//
//	foo.bar &&= value
//	^^^^^^^^^^^^^^^^^
type CallAndWriteNode struct {
	NodeID          int      `json:"nodeID"`
	Location        Location `json:"location"`
	flags           uint32
	Receiver        Node      `json:"receiver"`
	CallOperatorLoc *Location `json:"call_operator_loc"`
	MessageLoc      *Location `json:"message_loc"`
	ReadName        string    `json:"read_name"`
	WriteName       string    `json:"write_name"`
	OperatorLoc     Location  `json:"operator_loc"`
	Value           Node      `json:"value"`
}

// NewCallAndWriteNode creates a new CallAndWriteNode.
func NewCallAndWriteNode(nodeID int, location Location, flags uint32, receiver Node, call_operator_loc *Location, message_loc *Location, read_name string, write_name string, operator_loc Location, value Node) *CallAndWriteNode {
	return &CallAndWriteNode{
		NodeID:          nodeID,
		Location:        location,
		flags:           flags,
		Receiver:        receiver,
		CallOperatorLoc: call_operator_loc,
		MessageLoc:      message_loc,
		ReadName:        read_name,
		WriteName:       write_name,
		OperatorLoc:     operator_loc,
		Value:           value,
	}
}

// GetLocation returns the location of this node.
func (n *CallAndWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *CallAndWriteNode) GetNodeID() int {
	return n.NodeID
}

// IsSAFE_NAVIGATION returns true if this node has the SAFE_NAVIGATION flag.
func (n *CallAndWriteNode) IsSAFE_NAVIGATION() bool {
	return (n.flags & CallNodeFlagsSAFE_NAVIGATION) != 0
}

// IsVARIABLE_CALL returns true if this node has the VARIABLE_CALL flag.
func (n *CallAndWriteNode) IsVARIABLE_CALL() bool {
	return (n.flags & CallNodeFlagsVARIABLE_CALL) != 0
}

// IsATTRIBUTE_WRITE returns true if this node has the ATTRIBUTE_WRITE flag.
func (n *CallAndWriteNode) IsATTRIBUTE_WRITE() bool {
	return (n.flags & CallNodeFlagsATTRIBUTE_WRITE) != 0
}

// IsIGNORE_VISIBILITY returns true if this node has the IGNORE_VISIBILITY flag.
func (n *CallAndWriteNode) IsIGNORE_VISIBILITY() bool {
	return (n.flags & CallNodeFlagsIGNORE_VISIBILITY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *CallAndWriteNode) Accept(visitor Visitor) {
	visitor.VisitCallAndWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *CallAndWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *CallAndWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *CallAndWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":              "CallAndWriteNode",
		"location":          n.Location,
		"flags":             n.flags,
		"receiver":          n.Receiver,
		"call_operator_loc": n.CallOperatorLoc,
		"message_loc":       n.MessageLoc,
		"read_name":         n.ReadName,
		"write_name":        n.WriteName,
		"operator_loc":      n.OperatorLoc,
		"value":             n.Value,
	}
}

// Represents a method call, in all of the various forms that can take.
//
//	foo
//	^^^
//
//	foo()
//	^^^^^
//
//	+foo
//	^^^^
//
//	foo + bar
//	^^^^^^^^^
//
//	foo.bar
//	^^^^^^^
//
//	foo&.bar
//	^^^^^^^^
type CallNode struct {
	NodeID          int      `json:"nodeID"`
	Location        Location `json:"location"`
	flags           uint32
	Receiver        Node           `json:"receiver"`
	CallOperatorLoc *Location      `json:"call_operator_loc"`
	Name            string         `json:"name"`
	MessageLoc      *Location      `json:"message_loc"`
	OpeningLoc      *Location      `json:"opening_loc"`
	Arguments       *ArgumentsNode `json:"arguments"`
	ClosingLoc      *Location      `json:"closing_loc"`
	Block           Node           `json:"block"`
}

// NewCallNode creates a new CallNode.
func NewCallNode(nodeID int, location Location, flags uint32, receiver Node, call_operator_loc *Location, name string, message_loc *Location, opening_loc *Location, arguments *ArgumentsNode, closing_loc *Location, block Node) *CallNode {
	return &CallNode{
		NodeID:          nodeID,
		Location:        location,
		flags:           flags,
		Receiver:        receiver,
		CallOperatorLoc: call_operator_loc,
		Name:            name,
		MessageLoc:      message_loc,
		OpeningLoc:      opening_loc,
		Arguments:       arguments,
		ClosingLoc:      closing_loc,
		Block:           block,
	}
}

// GetLocation returns the location of this node.
func (n *CallNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *CallNode) GetNodeID() int {
	return n.NodeID
}

// IsSAFE_NAVIGATION returns true if this node has the SAFE_NAVIGATION flag.
func (n *CallNode) IsSAFE_NAVIGATION() bool {
	return (n.flags & CallNodeFlagsSAFE_NAVIGATION) != 0
}

// IsVARIABLE_CALL returns true if this node has the VARIABLE_CALL flag.
func (n *CallNode) IsVARIABLE_CALL() bool {
	return (n.flags & CallNodeFlagsVARIABLE_CALL) != 0
}

// IsATTRIBUTE_WRITE returns true if this node has the ATTRIBUTE_WRITE flag.
func (n *CallNode) IsATTRIBUTE_WRITE() bool {
	return (n.flags & CallNodeFlagsATTRIBUTE_WRITE) != 0
}

// IsIGNORE_VISIBILITY returns true if this node has the IGNORE_VISIBILITY flag.
func (n *CallNode) IsIGNORE_VISIBILITY() bool {
	return (n.flags & CallNodeFlagsIGNORE_VISIBILITY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *CallNode) Accept(visitor Visitor) {
	visitor.VisitCallNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *CallNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *CallNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *CallNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":              "CallNode",
		"location":          n.Location,
		"flags":             n.flags,
		"receiver":          n.Receiver,
		"call_operator_loc": n.CallOperatorLoc,
		"name":              n.Name,
		"message_loc":       n.MessageLoc,
		"opening_loc":       n.OpeningLoc,
		"arguments":         n.Arguments,
		"closing_loc":       n.ClosingLoc,
		"block":             n.Block,
	}
}

// Represents the use of an assignment operator on a call.
//
//	foo.bar += baz
//	^^^^^^^^^^^^^^
type CallOperatorWriteNode struct {
	NodeID            int      `json:"nodeID"`
	Location          Location `json:"location"`
	flags             uint32
	Receiver          Node      `json:"receiver"`
	CallOperatorLoc   *Location `json:"call_operator_loc"`
	MessageLoc        *Location `json:"message_loc"`
	ReadName          string    `json:"read_name"`
	WriteName         string    `json:"write_name"`
	BinaryOperator    string    `json:"binary_operator"`
	BinaryOperatorLoc Location  `json:"binary_operator_loc"`
	Value             Node      `json:"value"`
}

// NewCallOperatorWriteNode creates a new CallOperatorWriteNode.
func NewCallOperatorWriteNode(nodeID int, location Location, flags uint32, receiver Node, call_operator_loc *Location, message_loc *Location, read_name string, write_name string, binary_operator string, binary_operator_loc Location, value Node) *CallOperatorWriteNode {
	return &CallOperatorWriteNode{
		NodeID:            nodeID,
		Location:          location,
		flags:             flags,
		Receiver:          receiver,
		CallOperatorLoc:   call_operator_loc,
		MessageLoc:        message_loc,
		ReadName:          read_name,
		WriteName:         write_name,
		BinaryOperator:    binary_operator,
		BinaryOperatorLoc: binary_operator_loc,
		Value:             value,
	}
}

// GetLocation returns the location of this node.
func (n *CallOperatorWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *CallOperatorWriteNode) GetNodeID() int {
	return n.NodeID
}

// IsSAFE_NAVIGATION returns true if this node has the SAFE_NAVIGATION flag.
func (n *CallOperatorWriteNode) IsSAFE_NAVIGATION() bool {
	return (n.flags & CallNodeFlagsSAFE_NAVIGATION) != 0
}

// IsVARIABLE_CALL returns true if this node has the VARIABLE_CALL flag.
func (n *CallOperatorWriteNode) IsVARIABLE_CALL() bool {
	return (n.flags & CallNodeFlagsVARIABLE_CALL) != 0
}

// IsATTRIBUTE_WRITE returns true if this node has the ATTRIBUTE_WRITE flag.
func (n *CallOperatorWriteNode) IsATTRIBUTE_WRITE() bool {
	return (n.flags & CallNodeFlagsATTRIBUTE_WRITE) != 0
}

// IsIGNORE_VISIBILITY returns true if this node has the IGNORE_VISIBILITY flag.
func (n *CallOperatorWriteNode) IsIGNORE_VISIBILITY() bool {
	return (n.flags & CallNodeFlagsIGNORE_VISIBILITY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *CallOperatorWriteNode) Accept(visitor Visitor) {
	visitor.VisitCallOperatorWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *CallOperatorWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *CallOperatorWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *CallOperatorWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":                "CallOperatorWriteNode",
		"location":            n.Location,
		"flags":               n.flags,
		"receiver":            n.Receiver,
		"call_operator_loc":   n.CallOperatorLoc,
		"message_loc":         n.MessageLoc,
		"read_name":           n.ReadName,
		"write_name":          n.WriteName,
		"binary_operator":     n.BinaryOperator,
		"binary_operator_loc": n.BinaryOperatorLoc,
		"value":               n.Value,
	}
}

// Represents the use of the `||=` operator on a call.
//
//	foo.bar ||= value
//	^^^^^^^^^^^^^^^^^
type CallOrWriteNode struct {
	NodeID          int      `json:"nodeID"`
	Location        Location `json:"location"`
	flags           uint32
	Receiver        Node      `json:"receiver"`
	CallOperatorLoc *Location `json:"call_operator_loc"`
	MessageLoc      *Location `json:"message_loc"`
	ReadName        string    `json:"read_name"`
	WriteName       string    `json:"write_name"`
	OperatorLoc     Location  `json:"operator_loc"`
	Value           Node      `json:"value"`
}

// NewCallOrWriteNode creates a new CallOrWriteNode.
func NewCallOrWriteNode(nodeID int, location Location, flags uint32, receiver Node, call_operator_loc *Location, message_loc *Location, read_name string, write_name string, operator_loc Location, value Node) *CallOrWriteNode {
	return &CallOrWriteNode{
		NodeID:          nodeID,
		Location:        location,
		flags:           flags,
		Receiver:        receiver,
		CallOperatorLoc: call_operator_loc,
		MessageLoc:      message_loc,
		ReadName:        read_name,
		WriteName:       write_name,
		OperatorLoc:     operator_loc,
		Value:           value,
	}
}

// GetLocation returns the location of this node.
func (n *CallOrWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *CallOrWriteNode) GetNodeID() int {
	return n.NodeID
}

// IsSAFE_NAVIGATION returns true if this node has the SAFE_NAVIGATION flag.
func (n *CallOrWriteNode) IsSAFE_NAVIGATION() bool {
	return (n.flags & CallNodeFlagsSAFE_NAVIGATION) != 0
}

// IsVARIABLE_CALL returns true if this node has the VARIABLE_CALL flag.
func (n *CallOrWriteNode) IsVARIABLE_CALL() bool {
	return (n.flags & CallNodeFlagsVARIABLE_CALL) != 0
}

// IsATTRIBUTE_WRITE returns true if this node has the ATTRIBUTE_WRITE flag.
func (n *CallOrWriteNode) IsATTRIBUTE_WRITE() bool {
	return (n.flags & CallNodeFlagsATTRIBUTE_WRITE) != 0
}

// IsIGNORE_VISIBILITY returns true if this node has the IGNORE_VISIBILITY flag.
func (n *CallOrWriteNode) IsIGNORE_VISIBILITY() bool {
	return (n.flags & CallNodeFlagsIGNORE_VISIBILITY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *CallOrWriteNode) Accept(visitor Visitor) {
	visitor.VisitCallOrWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *CallOrWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *CallOrWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *CallOrWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":              "CallOrWriteNode",
		"location":          n.Location,
		"flags":             n.flags,
		"receiver":          n.Receiver,
		"call_operator_loc": n.CallOperatorLoc,
		"message_loc":       n.MessageLoc,
		"read_name":         n.ReadName,
		"write_name":        n.WriteName,
		"operator_loc":      n.OperatorLoc,
		"value":             n.Value,
	}
}

// Represents assigning to a method call.
//
//	foo.bar, = 1
//	^^^^^^^
//
//	begin
//	rescue => foo.bar
//	          ^^^^^^^
//	end
//
//	for foo.bar in baz do end
//	    ^^^^^^^
type CallTargetNode struct {
	NodeID          int      `json:"nodeID"`
	Location        Location `json:"location"`
	flags           uint32
	Receiver        Node     `json:"receiver"`
	CallOperatorLoc Location `json:"call_operator_loc"`
	Name            string   `json:"name"`
	MessageLoc      Location `json:"message_loc"`
}

// NewCallTargetNode creates a new CallTargetNode.
func NewCallTargetNode(nodeID int, location Location, flags uint32, receiver Node, call_operator_loc Location, name string, message_loc Location) *CallTargetNode {
	return &CallTargetNode{
		NodeID:          nodeID,
		Location:        location,
		flags:           flags,
		Receiver:        receiver,
		CallOperatorLoc: call_operator_loc,
		Name:            name,
		MessageLoc:      message_loc,
	}
}

// GetLocation returns the location of this node.
func (n *CallTargetNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *CallTargetNode) GetNodeID() int {
	return n.NodeID
}

// IsSAFE_NAVIGATION returns true if this node has the SAFE_NAVIGATION flag.
func (n *CallTargetNode) IsSAFE_NAVIGATION() bool {
	return (n.flags & CallNodeFlagsSAFE_NAVIGATION) != 0
}

// IsVARIABLE_CALL returns true if this node has the VARIABLE_CALL flag.
func (n *CallTargetNode) IsVARIABLE_CALL() bool {
	return (n.flags & CallNodeFlagsVARIABLE_CALL) != 0
}

// IsATTRIBUTE_WRITE returns true if this node has the ATTRIBUTE_WRITE flag.
func (n *CallTargetNode) IsATTRIBUTE_WRITE() bool {
	return (n.flags & CallNodeFlagsATTRIBUTE_WRITE) != 0
}

// IsIGNORE_VISIBILITY returns true if this node has the IGNORE_VISIBILITY flag.
func (n *CallTargetNode) IsIGNORE_VISIBILITY() bool {
	return (n.flags & CallNodeFlagsIGNORE_VISIBILITY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *CallTargetNode) Accept(visitor Visitor) {
	visitor.VisitCallTargetNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *CallTargetNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Receiver)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *CallTargetNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Receiver)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *CallTargetNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":              "CallTargetNode",
		"location":          n.Location,
		"flags":             n.flags,
		"receiver":          n.Receiver,
		"call_operator_loc": n.CallOperatorLoc,
		"name":              n.Name,
		"message_loc":       n.MessageLoc,
	}
}

// Represents assigning to a local variable in pattern matching.
//
//	foo => [bar => baz]
//	       ^^^^^^^^^^^^
type CapturePatternNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Value       Node                     `json:"value"`
	Target      *LocalVariableTargetNode `json:"target"`
	OperatorLoc Location                 `json:"operator_loc"`
}

// NewCapturePatternNode creates a new CapturePatternNode.
func NewCapturePatternNode(nodeID int, location Location, flags uint32, value Node, target *LocalVariableTargetNode, operator_loc Location) *CapturePatternNode {
	return &CapturePatternNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Value:       value,
		Target:      target,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *CapturePatternNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *CapturePatternNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *CapturePatternNode) Accept(visitor Visitor) {
	visitor.VisitCapturePatternNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *CapturePatternNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	nodes = append(nodes, n.Target)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *CapturePatternNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	nodes = append(nodes, n.Target)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *CapturePatternNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "CapturePatternNode",
		"location":     n.Location,
		"flags":        n.flags,
		"value":        n.Value,
		"target":       n.Target,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents the use of a case statement for pattern matching.
//
//	case true
//	in false
//	end
//	^^^^^^^^^
type CaseMatchNode struct {
	NodeID         int      `json:"nodeID"`
	Location       Location `json:"location"`
	flags          uint32
	Predicate      Node      `json:"predicate"`
	Conditions     []Node    `json:"conditions"`
	ElseClause     *ElseNode `json:"else_clause"`
	CaseKeywordLoc Location  `json:"case_keyword_loc"`
	EndKeywordLoc  Location  `json:"end_keyword_loc"`
}

// NewCaseMatchNode creates a new CaseMatchNode.
func NewCaseMatchNode(nodeID int, location Location, flags uint32, predicate Node, conditions []Node, else_clause *ElseNode, case_keyword_loc Location, end_keyword_loc Location) *CaseMatchNode {
	return &CaseMatchNode{
		NodeID:         nodeID,
		Location:       location,
		flags:          flags,
		Predicate:      predicate,
		Conditions:     conditions,
		ElseClause:     else_clause,
		CaseKeywordLoc: case_keyword_loc,
		EndKeywordLoc:  end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *CaseMatchNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *CaseMatchNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *CaseMatchNode) Accept(visitor Visitor) {
	visitor.VisitCaseMatchNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *CaseMatchNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Predicate != nil {
		nodes = append(nodes, n.Predicate)
	}
	nodes = append(nodes, n.Conditions...)
	if n.ElseClause != nil {
		nodes = append(nodes, n.ElseClause)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *CaseMatchNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Predicate != nil {
		nodes = append(nodes, n.Predicate)
	}
	nodes = append(nodes, n.Conditions...)
	if n.ElseClause != nil {
		nodes = append(nodes, n.ElseClause)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *CaseMatchNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":             "CaseMatchNode",
		"location":         n.Location,
		"flags":            n.flags,
		"predicate":        n.Predicate,
		"conditions":       n.Conditions,
		"else_clause":      n.ElseClause,
		"case_keyword_loc": n.CaseKeywordLoc,
		"end_keyword_loc":  n.EndKeywordLoc,
	}
}

// Represents the use of a case statement.
//
//	case true
//	when false
//	end
//	^^^^^^^^^^
type CaseNode struct {
	NodeID         int      `json:"nodeID"`
	Location       Location `json:"location"`
	flags          uint32
	Predicate      Node      `json:"predicate"`
	Conditions     []Node    `json:"conditions"`
	ElseClause     *ElseNode `json:"else_clause"`
	CaseKeywordLoc Location  `json:"case_keyword_loc"`
	EndKeywordLoc  Location  `json:"end_keyword_loc"`
}

// NewCaseNode creates a new CaseNode.
func NewCaseNode(nodeID int, location Location, flags uint32, predicate Node, conditions []Node, else_clause *ElseNode, case_keyword_loc Location, end_keyword_loc Location) *CaseNode {
	return &CaseNode{
		NodeID:         nodeID,
		Location:       location,
		flags:          flags,
		Predicate:      predicate,
		Conditions:     conditions,
		ElseClause:     else_clause,
		CaseKeywordLoc: case_keyword_loc,
		EndKeywordLoc:  end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *CaseNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *CaseNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *CaseNode) Accept(visitor Visitor) {
	visitor.VisitCaseNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *CaseNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Predicate != nil {
		nodes = append(nodes, n.Predicate)
	}
	nodes = append(nodes, n.Conditions...)
	if n.ElseClause != nil {
		nodes = append(nodes, n.ElseClause)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *CaseNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Predicate != nil {
		nodes = append(nodes, n.Predicate)
	}
	nodes = append(nodes, n.Conditions...)
	if n.ElseClause != nil {
		nodes = append(nodes, n.ElseClause)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *CaseNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":             "CaseNode",
		"location":         n.Location,
		"flags":            n.flags,
		"predicate":        n.Predicate,
		"conditions":       n.Conditions,
		"else_clause":      n.ElseClause,
		"case_keyword_loc": n.CaseKeywordLoc,
		"end_keyword_loc":  n.EndKeywordLoc,
	}
}

// Represents a class declaration involving the `class` keyword.
//
//	class Foo end
//	^^^^^^^^^^^^^
type ClassNode struct {
	NodeID                 int      `json:"nodeID"`
	Location               Location `json:"location"`
	flags                  uint32
	Locals                 []string  `json:"locals"`
	ClassKeywordLoc        Location  `json:"class_keyword_loc"`
	ConstantPath           Node      `json:"constant_path"`
	InheritanceOperatorLoc *Location `json:"inheritance_operator_loc"`
	Superclass             Node      `json:"superclass"`
	Body                   Node      `json:"body"`
	EndKeywordLoc          Location  `json:"end_keyword_loc"`
	Name                   string    `json:"name"`
}

// NewClassNode creates a new ClassNode.
func NewClassNode(nodeID int, location Location, flags uint32, locals []string, class_keyword_loc Location, constant_path Node, inheritance_operator_loc *Location, superclass Node, body Node, end_keyword_loc Location, name string) *ClassNode {
	return &ClassNode{
		NodeID:                 nodeID,
		Location:               location,
		flags:                  flags,
		Locals:                 locals,
		ClassKeywordLoc:        class_keyword_loc,
		ConstantPath:           constant_path,
		InheritanceOperatorLoc: inheritance_operator_loc,
		Superclass:             superclass,
		Body:                   body,
		EndKeywordLoc:          end_keyword_loc,
		Name:                   name,
	}
}

// GetLocation returns the location of this node.
func (n *ClassNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ClassNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ClassNode) Accept(visitor Visitor) {
	visitor.VisitClassNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ClassNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.ConstantPath)
	if n.Superclass != nil {
		nodes = append(nodes, n.Superclass)
	}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ClassNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.ConstantPath)
	if n.Superclass != nil {
		nodes = append(nodes, n.Superclass)
	}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ClassNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":                     "ClassNode",
		"location":                 n.Location,
		"flags":                    n.flags,
		"locals":                   n.Locals,
		"class_keyword_loc":        n.ClassKeywordLoc,
		"constant_path":            n.ConstantPath,
		"inheritance_operator_loc": n.InheritanceOperatorLoc,
		"superclass":               n.Superclass,
		"body":                     n.Body,
		"end_keyword_loc":          n.EndKeywordLoc,
		"name":                     n.Name,
	}
}

// Represents the use of the `&&=` operator for assignment to a class variable.
//
//	@@target &&= value
//	^^^^^^^^^^^^^^^^^^
type ClassVariableAndWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
}

// NewClassVariableAndWriteNode creates a new ClassVariableAndWriteNode.
func NewClassVariableAndWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, operator_loc Location, value Node) *ClassVariableAndWriteNode {
	return &ClassVariableAndWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *ClassVariableAndWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ClassVariableAndWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ClassVariableAndWriteNode) Accept(visitor Visitor) {
	visitor.VisitClassVariableAndWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ClassVariableAndWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ClassVariableAndWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ClassVariableAndWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ClassVariableAndWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents assigning to a class variable using an operator that isn't `=`.
//
//	@@target += value
//	^^^^^^^^^^^^^^^^^
type ClassVariableOperatorWriteNode struct {
	NodeID            int      `json:"nodeID"`
	Location          Location `json:"location"`
	flags             uint32
	Name              string   `json:"name"`
	NameLoc           Location `json:"name_loc"`
	BinaryOperatorLoc Location `json:"binary_operator_loc"`
	Value             Node     `json:"value"`
	BinaryOperator    string   `json:"binary_operator"`
}

// NewClassVariableOperatorWriteNode creates a new ClassVariableOperatorWriteNode.
func NewClassVariableOperatorWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, binary_operator_loc Location, value Node, binary_operator string) *ClassVariableOperatorWriteNode {
	return &ClassVariableOperatorWriteNode{
		NodeID:            nodeID,
		Location:          location,
		flags:             flags,
		Name:              name,
		NameLoc:           name_loc,
		BinaryOperatorLoc: binary_operator_loc,
		Value:             value,
		BinaryOperator:    binary_operator,
	}
}

// GetLocation returns the location of this node.
func (n *ClassVariableOperatorWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ClassVariableOperatorWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ClassVariableOperatorWriteNode) Accept(visitor Visitor) {
	visitor.VisitClassVariableOperatorWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ClassVariableOperatorWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ClassVariableOperatorWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ClassVariableOperatorWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":                "ClassVariableOperatorWriteNode",
		"location":            n.Location,
		"flags":               n.flags,
		"name":                n.Name,
		"name_loc":            n.NameLoc,
		"binary_operator_loc": n.BinaryOperatorLoc,
		"value":               n.Value,
		"binary_operator":     n.BinaryOperator,
	}
}

// Represents the use of the `||=` operator for assignment to a class variable.
//
//	@@target ||= value
//	^^^^^^^^^^^^^^^^^^
type ClassVariableOrWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
}

// NewClassVariableOrWriteNode creates a new ClassVariableOrWriteNode.
func NewClassVariableOrWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, operator_loc Location, value Node) *ClassVariableOrWriteNode {
	return &ClassVariableOrWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *ClassVariableOrWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ClassVariableOrWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ClassVariableOrWriteNode) Accept(visitor Visitor) {
	visitor.VisitClassVariableOrWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ClassVariableOrWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ClassVariableOrWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ClassVariableOrWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ClassVariableOrWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents referencing a class variable.
//
//	@@foo
//	^^^^^
type ClassVariableReadNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewClassVariableReadNode creates a new ClassVariableReadNode.
func NewClassVariableReadNode(nodeID int, location Location, flags uint32, name string) *ClassVariableReadNode {
	return &ClassVariableReadNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *ClassVariableReadNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ClassVariableReadNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ClassVariableReadNode) Accept(visitor Visitor) {
	visitor.VisitClassVariableReadNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ClassVariableReadNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ClassVariableReadNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ClassVariableReadNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ClassVariableReadNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents writing to a class variable in a context that doesn't have an explicit value.
//
//	@@foo, @@bar = baz
//	^^^^^  ^^^^^
type ClassVariableTargetNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewClassVariableTargetNode creates a new ClassVariableTargetNode.
func NewClassVariableTargetNode(nodeID int, location Location, flags uint32, name string) *ClassVariableTargetNode {
	return &ClassVariableTargetNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *ClassVariableTargetNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ClassVariableTargetNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ClassVariableTargetNode) Accept(visitor Visitor) {
	visitor.VisitClassVariableTargetNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ClassVariableTargetNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ClassVariableTargetNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ClassVariableTargetNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ClassVariableTargetNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents writing to a class variable.
//
//	@@foo = 1
//	^^^^^^^^^
type ClassVariableWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	Value       Node     `json:"value"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewClassVariableWriteNode creates a new ClassVariableWriteNode.
func NewClassVariableWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, value Node, operator_loc Location) *ClassVariableWriteNode {
	return &ClassVariableWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		Value:       value,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *ClassVariableWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ClassVariableWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ClassVariableWriteNode) Accept(visitor Visitor) {
	visitor.VisitClassVariableWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ClassVariableWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ClassVariableWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ClassVariableWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ClassVariableWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"value":        n.Value,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents the use of the `&&=` operator for assignment to a constant.
//
//	Target &&= value
//	^^^^^^^^^^^^^^^^
type ConstantAndWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
}

// NewConstantAndWriteNode creates a new ConstantAndWriteNode.
func NewConstantAndWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, operator_loc Location, value Node) *ConstantAndWriteNode {
	return &ConstantAndWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantAndWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantAndWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantAndWriteNode) Accept(visitor Visitor) {
	visitor.VisitConstantAndWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantAndWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantAndWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantAndWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ConstantAndWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents assigning to a constant using an operator that isn't `=`.
//
//	Target += value
//	^^^^^^^^^^^^^^^
type ConstantOperatorWriteNode struct {
	NodeID            int      `json:"nodeID"`
	Location          Location `json:"location"`
	flags             uint32
	Name              string   `json:"name"`
	NameLoc           Location `json:"name_loc"`
	BinaryOperatorLoc Location `json:"binary_operator_loc"`
	Value             Node     `json:"value"`
	BinaryOperator    string   `json:"binary_operator"`
}

// NewConstantOperatorWriteNode creates a new ConstantOperatorWriteNode.
func NewConstantOperatorWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, binary_operator_loc Location, value Node, binary_operator string) *ConstantOperatorWriteNode {
	return &ConstantOperatorWriteNode{
		NodeID:            nodeID,
		Location:          location,
		flags:             flags,
		Name:              name,
		NameLoc:           name_loc,
		BinaryOperatorLoc: binary_operator_loc,
		Value:             value,
		BinaryOperator:    binary_operator,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantOperatorWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantOperatorWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantOperatorWriteNode) Accept(visitor Visitor) {
	visitor.VisitConstantOperatorWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantOperatorWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantOperatorWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantOperatorWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":                "ConstantOperatorWriteNode",
		"location":            n.Location,
		"flags":               n.flags,
		"name":                n.Name,
		"name_loc":            n.NameLoc,
		"binary_operator_loc": n.BinaryOperatorLoc,
		"value":               n.Value,
		"binary_operator":     n.BinaryOperator,
	}
}

// Represents the use of the `||=` operator for assignment to a constant.
//
//	Target ||= value
//	^^^^^^^^^^^^^^^^
type ConstantOrWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
}

// NewConstantOrWriteNode creates a new ConstantOrWriteNode.
func NewConstantOrWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, operator_loc Location, value Node) *ConstantOrWriteNode {
	return &ConstantOrWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantOrWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantOrWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantOrWriteNode) Accept(visitor Visitor) {
	visitor.VisitConstantOrWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantOrWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantOrWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantOrWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ConstantOrWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents the use of the `&&=` operator for assignment to a constant path.
//
//	Parent::Child &&= value
//	^^^^^^^^^^^^^^^^^^^^^^^
type ConstantPathAndWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Target      *ConstantPathNode `json:"target"`
	OperatorLoc Location          `json:"operator_loc"`
	Value       Node              `json:"value"`
}

// NewConstantPathAndWriteNode creates a new ConstantPathAndWriteNode.
func NewConstantPathAndWriteNode(nodeID int, location Location, flags uint32, target *ConstantPathNode, operator_loc Location, value Node) *ConstantPathAndWriteNode {
	return &ConstantPathAndWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Target:      target,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantPathAndWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantPathAndWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantPathAndWriteNode) Accept(visitor Visitor) {
	visitor.VisitConstantPathAndWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantPathAndWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Target)
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantPathAndWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Target)
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantPathAndWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ConstantPathAndWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"target":       n.Target,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents accessing a constant through a path of `::` operators.
//
//	Foo::Bar
//	^^^^^^^^
type ConstantPathNode struct {
	NodeID       int      `json:"nodeID"`
	Location     Location `json:"location"`
	flags        uint32
	Parent       Node     `json:"parent"`
	Name         *string  `json:"name"`
	DelimiterLoc Location `json:"delimiter_loc"`
	NameLoc      Location `json:"name_loc"`
}

// NewConstantPathNode creates a new ConstantPathNode.
func NewConstantPathNode(nodeID int, location Location, flags uint32, parent Node, name *string, delimiter_loc Location, name_loc Location) *ConstantPathNode {
	return &ConstantPathNode{
		NodeID:       nodeID,
		Location:     location,
		flags:        flags,
		Parent:       parent,
		Name:         name,
		DelimiterLoc: delimiter_loc,
		NameLoc:      name_loc,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantPathNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantPathNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantPathNode) Accept(visitor Visitor) {
	visitor.VisitConstantPathNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantPathNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Parent != nil {
		nodes = append(nodes, n.Parent)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantPathNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Parent != nil {
		nodes = append(nodes, n.Parent)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantPathNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":          "ConstantPathNode",
		"location":      n.Location,
		"flags":         n.flags,
		"parent":        n.Parent,
		"name":          n.Name,
		"delimiter_loc": n.DelimiterLoc,
		"name_loc":      n.NameLoc,
	}
}

// Represents assigning to a constant path using an operator that isn't `=`.
//
//	Parent::Child += value
//	^^^^^^^^^^^^^^^^^^^^^^
type ConstantPathOperatorWriteNode struct {
	NodeID            int      `json:"nodeID"`
	Location          Location `json:"location"`
	flags             uint32
	Target            *ConstantPathNode `json:"target"`
	BinaryOperatorLoc Location          `json:"binary_operator_loc"`
	Value             Node              `json:"value"`
	BinaryOperator    string            `json:"binary_operator"`
}

// NewConstantPathOperatorWriteNode creates a new ConstantPathOperatorWriteNode.
func NewConstantPathOperatorWriteNode(nodeID int, location Location, flags uint32, target *ConstantPathNode, binary_operator_loc Location, value Node, binary_operator string) *ConstantPathOperatorWriteNode {
	return &ConstantPathOperatorWriteNode{
		NodeID:            nodeID,
		Location:          location,
		flags:             flags,
		Target:            target,
		BinaryOperatorLoc: binary_operator_loc,
		Value:             value,
		BinaryOperator:    binary_operator,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantPathOperatorWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantPathOperatorWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantPathOperatorWriteNode) Accept(visitor Visitor) {
	visitor.VisitConstantPathOperatorWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantPathOperatorWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Target)
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantPathOperatorWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Target)
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantPathOperatorWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":                "ConstantPathOperatorWriteNode",
		"location":            n.Location,
		"flags":               n.flags,
		"target":              n.Target,
		"binary_operator_loc": n.BinaryOperatorLoc,
		"value":               n.Value,
		"binary_operator":     n.BinaryOperator,
	}
}

// Represents the use of the `||=` operator for assignment to a constant path.
//
//	Parent::Child ||= value
//	^^^^^^^^^^^^^^^^^^^^^^^
type ConstantPathOrWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Target      *ConstantPathNode `json:"target"`
	OperatorLoc Location          `json:"operator_loc"`
	Value       Node              `json:"value"`
}

// NewConstantPathOrWriteNode creates a new ConstantPathOrWriteNode.
func NewConstantPathOrWriteNode(nodeID int, location Location, flags uint32, target *ConstantPathNode, operator_loc Location, value Node) *ConstantPathOrWriteNode {
	return &ConstantPathOrWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Target:      target,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantPathOrWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantPathOrWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantPathOrWriteNode) Accept(visitor Visitor) {
	visitor.VisitConstantPathOrWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantPathOrWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Target)
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantPathOrWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Target)
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantPathOrWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ConstantPathOrWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"target":       n.Target,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents writing to a constant path in a context that doesn't have an explicit value.
//
//	Foo::Foo, Bar::Bar = baz
//	^^^^^^^^  ^^^^^^^^
type ConstantPathTargetNode struct {
	NodeID       int      `json:"nodeID"`
	Location     Location `json:"location"`
	flags        uint32
	Parent       Node     `json:"parent"`
	Name         *string  `json:"name"`
	DelimiterLoc Location `json:"delimiter_loc"`
	NameLoc      Location `json:"name_loc"`
}

// NewConstantPathTargetNode creates a new ConstantPathTargetNode.
func NewConstantPathTargetNode(nodeID int, location Location, flags uint32, parent Node, name *string, delimiter_loc Location, name_loc Location) *ConstantPathTargetNode {
	return &ConstantPathTargetNode{
		NodeID:       nodeID,
		Location:     location,
		flags:        flags,
		Parent:       parent,
		Name:         name,
		DelimiterLoc: delimiter_loc,
		NameLoc:      name_loc,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantPathTargetNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantPathTargetNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantPathTargetNode) Accept(visitor Visitor) {
	visitor.VisitConstantPathTargetNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantPathTargetNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Parent != nil {
		nodes = append(nodes, n.Parent)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantPathTargetNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Parent != nil {
		nodes = append(nodes, n.Parent)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantPathTargetNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":          "ConstantPathTargetNode",
		"location":      n.Location,
		"flags":         n.flags,
		"parent":        n.Parent,
		"name":          n.Name,
		"delimiter_loc": n.DelimiterLoc,
		"name_loc":      n.NameLoc,
	}
}

// Represents writing to a constant path.
//
//	::Foo = 1
//	^^^^^^^^^
//
//	Foo::Bar = 1
//	^^^^^^^^^^^^
//
//	::Foo::Bar = 1
//	^^^^^^^^^^^^^^
type ConstantPathWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Target      *ConstantPathNode `json:"target"`
	OperatorLoc Location          `json:"operator_loc"`
	Value       Node              `json:"value"`
}

// NewConstantPathWriteNode creates a new ConstantPathWriteNode.
func NewConstantPathWriteNode(nodeID int, location Location, flags uint32, target *ConstantPathNode, operator_loc Location, value Node) *ConstantPathWriteNode {
	return &ConstantPathWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Target:      target,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantPathWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantPathWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantPathWriteNode) Accept(visitor Visitor) {
	visitor.VisitConstantPathWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantPathWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Target)
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantPathWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Target)
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantPathWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ConstantPathWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"target":       n.Target,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents referencing a constant.
//
//	Foo
//	^^^
type ConstantReadNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewConstantReadNode creates a new ConstantReadNode.
func NewConstantReadNode(nodeID int, location Location, flags uint32, name string) *ConstantReadNode {
	return &ConstantReadNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantReadNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantReadNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantReadNode) Accept(visitor Visitor) {
	visitor.VisitConstantReadNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantReadNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantReadNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantReadNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ConstantReadNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents writing to a constant in a context that doesn't have an explicit value.
//
//	Foo, Bar = baz
//	^^^  ^^^
type ConstantTargetNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewConstantTargetNode creates a new ConstantTargetNode.
func NewConstantTargetNode(nodeID int, location Location, flags uint32, name string) *ConstantTargetNode {
	return &ConstantTargetNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantTargetNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantTargetNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantTargetNode) Accept(visitor Visitor) {
	visitor.VisitConstantTargetNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantTargetNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantTargetNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantTargetNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ConstantTargetNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents writing to a constant.
//
//	Foo = 1
//	^^^^^^^
type ConstantWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	Value       Node     `json:"value"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewConstantWriteNode creates a new ConstantWriteNode.
func NewConstantWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, value Node, operator_loc Location) *ConstantWriteNode {
	return &ConstantWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		Value:       value,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *ConstantWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ConstantWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ConstantWriteNode) Accept(visitor Visitor) {
	visitor.VisitConstantWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ConstantWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ConstantWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ConstantWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ConstantWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"value":        n.Value,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents a method definition.
//
//	def method
//	end
//	^^^^^^^^^^
type DefNode struct {
	NodeID        int      `json:"nodeID"`
	Location      Location `json:"location"`
	flags         uint32
	Name          string          `json:"name"`
	NameLoc       Location        `json:"name_loc"`
	Receiver      Node            `json:"receiver"`
	Parameters    *ParametersNode `json:"parameters"`
	Body          Node            `json:"body"`
	Locals        []string        `json:"locals"`
	DefKeywordLoc Location        `json:"def_keyword_loc"`
	OperatorLoc   *Location       `json:"operator_loc"`
	LparenLoc     *Location       `json:"lparen_loc"`
	RparenLoc     *Location       `json:"rparen_loc"`
	EqualLoc      *Location       `json:"equal_loc"`
	EndKeywordLoc *Location       `json:"end_keyword_loc"`
}

// NewDefNode creates a new DefNode.
func NewDefNode(nodeID int, location Location, flags uint32, name string, name_loc Location, receiver Node, parameters *ParametersNode, body Node, locals []string, def_keyword_loc Location, operator_loc *Location, lparen_loc *Location, rparen_loc *Location, equal_loc *Location, end_keyword_loc *Location) *DefNode {
	return &DefNode{
		NodeID:        nodeID,
		Location:      location,
		flags:         flags,
		Name:          name,
		NameLoc:       name_loc,
		Receiver:      receiver,
		Parameters:    parameters,
		Body:          body,
		Locals:        locals,
		DefKeywordLoc: def_keyword_loc,
		OperatorLoc:   operator_loc,
		LparenLoc:     lparen_loc,
		RparenLoc:     rparen_loc,
		EqualLoc:      equal_loc,
		EndKeywordLoc: end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *DefNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *DefNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *DefNode) Accept(visitor Visitor) {
	visitor.VisitDefNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *DefNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Parameters != nil {
		nodes = append(nodes, n.Parameters)
	}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *DefNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Parameters != nil {
		nodes = append(nodes, n.Parameters)
	}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *DefNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":            "DefNode",
		"location":        n.Location,
		"flags":           n.flags,
		"name":            n.Name,
		"name_loc":        n.NameLoc,
		"receiver":        n.Receiver,
		"parameters":      n.Parameters,
		"body":            n.Body,
		"locals":          n.Locals,
		"def_keyword_loc": n.DefKeywordLoc,
		"operator_loc":    n.OperatorLoc,
		"lparen_loc":      n.LparenLoc,
		"rparen_loc":      n.RparenLoc,
		"equal_loc":       n.EqualLoc,
		"end_keyword_loc": n.EndKeywordLoc,
	}
}

// Represents the use of the `defined?` keyword.
//
//	defined?(a)
//	^^^^^^^^^^^
type DefinedNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	LparenLoc  *Location `json:"lparen_loc"`
	Value      Node      `json:"value"`
	RparenLoc  *Location `json:"rparen_loc"`
	KeywordLoc Location  `json:"keyword_loc"`
}

// NewDefinedNode creates a new DefinedNode.
func NewDefinedNode(nodeID int, location Location, flags uint32, lparen_loc *Location, value Node, rparen_loc *Location, keyword_loc Location) *DefinedNode {
	return &DefinedNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		LparenLoc:  lparen_loc,
		Value:      value,
		RparenLoc:  rparen_loc,
		KeywordLoc: keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *DefinedNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *DefinedNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *DefinedNode) Accept(visitor Visitor) {
	visitor.VisitDefinedNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *DefinedNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *DefinedNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *DefinedNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "DefinedNode",
		"location":    n.Location,
		"flags":       n.flags,
		"lparen_loc":  n.LparenLoc,
		"value":       n.Value,
		"rparen_loc":  n.RparenLoc,
		"keyword_loc": n.KeywordLoc,
	}
}

// Represents an `else` clause in a `case`, `if`, or `unless` statement.
//
//	if a then b else c end
//	            ^^^^^^^^^^
type ElseNode struct {
	NodeID         int      `json:"nodeID"`
	Location       Location `json:"location"`
	flags          uint32
	ElseKeywordLoc Location        `json:"else_keyword_loc"`
	Statements     *StatementsNode `json:"statements"`
	EndKeywordLoc  *Location       `json:"end_keyword_loc"`
}

// NewElseNode creates a new ElseNode.
func NewElseNode(nodeID int, location Location, flags uint32, else_keyword_loc Location, statements *StatementsNode, end_keyword_loc *Location) *ElseNode {
	return &ElseNode{
		NodeID:         nodeID,
		Location:       location,
		flags:          flags,
		ElseKeywordLoc: else_keyword_loc,
		Statements:     statements,
		EndKeywordLoc:  end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *ElseNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ElseNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ElseNode) Accept(visitor Visitor) {
	visitor.VisitElseNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ElseNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ElseNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ElseNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":             "ElseNode",
		"location":         n.Location,
		"flags":            n.flags,
		"else_keyword_loc": n.ElseKeywordLoc,
		"statements":       n.Statements,
		"end_keyword_loc":  n.EndKeywordLoc,
	}
}

// Represents an interpolated set of statements.
//
//	"foo #{bar}"
//	     ^^^^^^
type EmbeddedStatementsNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc Location        `json:"opening_loc"`
	Statements *StatementsNode `json:"statements"`
	ClosingLoc Location        `json:"closing_loc"`
}

// NewEmbeddedStatementsNode creates a new EmbeddedStatementsNode.
func NewEmbeddedStatementsNode(nodeID int, location Location, flags uint32, opening_loc Location, statements *StatementsNode, closing_loc Location) *EmbeddedStatementsNode {
	return &EmbeddedStatementsNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		Statements: statements,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *EmbeddedStatementsNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *EmbeddedStatementsNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *EmbeddedStatementsNode) Accept(visitor Visitor) {
	visitor.VisitEmbeddedStatementsNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *EmbeddedStatementsNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *EmbeddedStatementsNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *EmbeddedStatementsNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "EmbeddedStatementsNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"statements":  n.Statements,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents an interpolated variable.
//
//	"foo #@bar"
//	     ^^^^^
type EmbeddedVariableNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	OperatorLoc Location `json:"operator_loc"`
	Variable    Node     `json:"variable"`
}

// NewEmbeddedVariableNode creates a new EmbeddedVariableNode.
func NewEmbeddedVariableNode(nodeID int, location Location, flags uint32, operator_loc Location, variable Node) *EmbeddedVariableNode {
	return &EmbeddedVariableNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		OperatorLoc: operator_loc,
		Variable:    variable,
	}
}

// GetLocation returns the location of this node.
func (n *EmbeddedVariableNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *EmbeddedVariableNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *EmbeddedVariableNode) Accept(visitor Visitor) {
	visitor.VisitEmbeddedVariableNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *EmbeddedVariableNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Variable)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *EmbeddedVariableNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Variable)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *EmbeddedVariableNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "EmbeddedVariableNode",
		"location":     n.Location,
		"flags":        n.flags,
		"operator_loc": n.OperatorLoc,
		"variable":     n.Variable,
	}
}

// Represents an `ensure` clause in a `begin` statement.
//
//	begin
//	  foo
//	ensure
//	^^^^^^
//	  bar
//	end
type EnsureNode struct {
	NodeID           int      `json:"nodeID"`
	Location         Location `json:"location"`
	flags            uint32
	EnsureKeywordLoc Location        `json:"ensure_keyword_loc"`
	Statements       *StatementsNode `json:"statements"`
	EndKeywordLoc    Location        `json:"end_keyword_loc"`
}

// NewEnsureNode creates a new EnsureNode.
func NewEnsureNode(nodeID int, location Location, flags uint32, ensure_keyword_loc Location, statements *StatementsNode, end_keyword_loc Location) *EnsureNode {
	return &EnsureNode{
		NodeID:           nodeID,
		Location:         location,
		flags:            flags,
		EnsureKeywordLoc: ensure_keyword_loc,
		Statements:       statements,
		EndKeywordLoc:    end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *EnsureNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *EnsureNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *EnsureNode) Accept(visitor Visitor) {
	visitor.VisitEnsureNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *EnsureNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *EnsureNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *EnsureNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":               "EnsureNode",
		"location":           n.Location,
		"flags":              n.flags,
		"ensure_keyword_loc": n.EnsureKeywordLoc,
		"statements":         n.Statements,
		"end_keyword_loc":    n.EndKeywordLoc,
	}
}

// Represents the use of the literal `false` keyword.
//
//	false
//	^^^^^
type FalseNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewFalseNode creates a new FalseNode.
func NewFalseNode(nodeID int, location Location, flags uint32) *FalseNode {
	return &FalseNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *FalseNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *FalseNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *FalseNode) Accept(visitor Visitor) {
	visitor.VisitFalseNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *FalseNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *FalseNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *FalseNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "FalseNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents a find pattern in pattern matching.
//
//	foo in *bar, baz, *qux
//	       ^^^^^^^^^^^^^^^
//
//	foo in [*bar, baz, *qux]
//	       ^^^^^^^^^^^^^^^^^
//
//	foo in Foo(*bar, baz, *qux)
//	       ^^^^^^^^^^^^^^^^^^^^
type FindPatternNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Constant   Node       `json:"constant"`
	Left       *SplatNode `json:"left"`
	Requireds  []Node     `json:"requireds"`
	Right      Node       `json:"right"`
	OpeningLoc *Location  `json:"opening_loc"`
	ClosingLoc *Location  `json:"closing_loc"`
}

// NewFindPatternNode creates a new FindPatternNode.
func NewFindPatternNode(nodeID int, location Location, flags uint32, constant Node, left *SplatNode, requireds []Node, right Node, opening_loc *Location, closing_loc *Location) *FindPatternNode {
	return &FindPatternNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Constant:   constant,
		Left:       left,
		Requireds:  requireds,
		Right:      right,
		OpeningLoc: opening_loc,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *FindPatternNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *FindPatternNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *FindPatternNode) Accept(visitor Visitor) {
	visitor.VisitFindPatternNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *FindPatternNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Constant != nil {
		nodes = append(nodes, n.Constant)
	}
	nodes = append(nodes, n.Left)
	nodes = append(nodes, n.Requireds...)
	nodes = append(nodes, n.Right)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *FindPatternNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Constant != nil {
		nodes = append(nodes, n.Constant)
	}
	nodes = append(nodes, n.Left)
	nodes = append(nodes, n.Requireds...)
	nodes = append(nodes, n.Right)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *FindPatternNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "FindPatternNode",
		"location":    n.Location,
		"flags":       n.flags,
		"constant":    n.Constant,
		"left":        n.Left,
		"requireds":   n.Requireds,
		"right":       n.Right,
		"opening_loc": n.OpeningLoc,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents the use of the `..` or `...` operators to create flip flops.
//
//	baz if foo .. bar
//	       ^^^^^^^^^^
type FlipFlopNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Left        Node     `json:"left"`
	Right       Node     `json:"right"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewFlipFlopNode creates a new FlipFlopNode.
func NewFlipFlopNode(nodeID int, location Location, flags uint32, left Node, right Node, operator_loc Location) *FlipFlopNode {
	return &FlipFlopNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Left:        left,
		Right:       right,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *FlipFlopNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *FlipFlopNode) GetNodeID() int {
	return n.NodeID
}

// IsEXCLUDE_END returns true if this node has the EXCLUDE_END flag.
func (n *FlipFlopNode) IsEXCLUDE_END() bool {
	return (n.flags & RangeFlagsEXCLUDE_END) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *FlipFlopNode) Accept(visitor Visitor) {
	visitor.VisitFlipFlopNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *FlipFlopNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Left != nil {
		nodes = append(nodes, n.Left)
	}
	if n.Right != nil {
		nodes = append(nodes, n.Right)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *FlipFlopNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Left != nil {
		nodes = append(nodes, n.Left)
	}
	if n.Right != nil {
		nodes = append(nodes, n.Right)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *FlipFlopNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "FlipFlopNode",
		"location":     n.Location,
		"flags":        n.flags,
		"left":         n.Left,
		"right":        n.Right,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents a floating point number literal.
//
//	1.0
//	^^^
type FloatNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Value    float64 `json:"value"`
}

// NewFloatNode creates a new FloatNode.
func NewFloatNode(nodeID int, location Location, flags uint32, value float64) *FloatNode {
	return &FloatNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Value:    value,
	}
}

// GetLocation returns the location of this node.
func (n *FloatNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *FloatNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *FloatNode) Accept(visitor Visitor) {
	visitor.VisitFloatNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *FloatNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *FloatNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *FloatNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "FloatNode",
		"location": n.Location,
		"flags":    n.flags,
		"value":    n.Value,
	}
}

// Represents the use of the `for` keyword.
//
//	for i in a end
//	^^^^^^^^^^^^^^
type ForNode struct {
	NodeID        int      `json:"nodeID"`
	Location      Location `json:"location"`
	flags         uint32
	Index         Node            `json:"index"`
	Collection    Node            `json:"collection"`
	Statements    *StatementsNode `json:"statements"`
	ForKeywordLoc Location        `json:"for_keyword_loc"`
	InKeywordLoc  Location        `json:"in_keyword_loc"`
	DoKeywordLoc  *Location       `json:"do_keyword_loc"`
	EndKeywordLoc Location        `json:"end_keyword_loc"`
}

// NewForNode creates a new ForNode.
func NewForNode(nodeID int, location Location, flags uint32, index Node, collection Node, statements *StatementsNode, for_keyword_loc Location, in_keyword_loc Location, do_keyword_loc *Location, end_keyword_loc Location) *ForNode {
	return &ForNode{
		NodeID:        nodeID,
		Location:      location,
		flags:         flags,
		Index:         index,
		Collection:    collection,
		Statements:    statements,
		ForKeywordLoc: for_keyword_loc,
		InKeywordLoc:  in_keyword_loc,
		DoKeywordLoc:  do_keyword_loc,
		EndKeywordLoc: end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *ForNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ForNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ForNode) Accept(visitor Visitor) {
	visitor.VisitForNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ForNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Index)
	nodes = append(nodes, n.Collection)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ForNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Index)
	nodes = append(nodes, n.Collection)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ForNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":            "ForNode",
		"location":        n.Location,
		"flags":           n.flags,
		"index":           n.Index,
		"collection":      n.Collection,
		"statements":      n.Statements,
		"for_keyword_loc": n.ForKeywordLoc,
		"in_keyword_loc":  n.InKeywordLoc,
		"do_keyword_loc":  n.DoKeywordLoc,
		"end_keyword_loc": n.EndKeywordLoc,
	}
}

// Represents forwarding all arguments to this method to another method.
//
//	def foo(...)
//	  bar(...)
//	      ^^^
//	end
type ForwardingArgumentsNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewForwardingArgumentsNode creates a new ForwardingArgumentsNode.
func NewForwardingArgumentsNode(nodeID int, location Location, flags uint32) *ForwardingArgumentsNode {
	return &ForwardingArgumentsNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *ForwardingArgumentsNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ForwardingArgumentsNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ForwardingArgumentsNode) Accept(visitor Visitor) {
	visitor.VisitForwardingArgumentsNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ForwardingArgumentsNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ForwardingArgumentsNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ForwardingArgumentsNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ForwardingArgumentsNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents the use of the forwarding parameter in a method, block, or lambda declaration.
//
//	def foo(...)
//	        ^^^
//	end
type ForwardingParameterNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewForwardingParameterNode creates a new ForwardingParameterNode.
func NewForwardingParameterNode(nodeID int, location Location, flags uint32) *ForwardingParameterNode {
	return &ForwardingParameterNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *ForwardingParameterNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ForwardingParameterNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ForwardingParameterNode) Accept(visitor Visitor) {
	visitor.VisitForwardingParameterNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ForwardingParameterNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ForwardingParameterNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ForwardingParameterNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ForwardingParameterNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents the use of the `super` keyword without parentheses or arguments.
//
//	super
//	^^^^^
type ForwardingSuperNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Block    *BlockNode `json:"block"`
}

// NewForwardingSuperNode creates a new ForwardingSuperNode.
func NewForwardingSuperNode(nodeID int, location Location, flags uint32, block *BlockNode) *ForwardingSuperNode {
	return &ForwardingSuperNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Block:    block,
	}
}

// GetLocation returns the location of this node.
func (n *ForwardingSuperNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ForwardingSuperNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ForwardingSuperNode) Accept(visitor Visitor) {
	visitor.VisitForwardingSuperNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ForwardingSuperNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ForwardingSuperNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ForwardingSuperNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ForwardingSuperNode",
		"location": n.Location,
		"flags":    n.flags,
		"block":    n.Block,
	}
}

// Represents the use of the `&&=` operator for assignment to a global variable.
//
//	$target &&= value
//	^^^^^^^^^^^^^^^^^
type GlobalVariableAndWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
}

// NewGlobalVariableAndWriteNode creates a new GlobalVariableAndWriteNode.
func NewGlobalVariableAndWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, operator_loc Location, value Node) *GlobalVariableAndWriteNode {
	return &GlobalVariableAndWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *GlobalVariableAndWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *GlobalVariableAndWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *GlobalVariableAndWriteNode) Accept(visitor Visitor) {
	visitor.VisitGlobalVariableAndWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *GlobalVariableAndWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *GlobalVariableAndWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *GlobalVariableAndWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "GlobalVariableAndWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents assigning to a global variable using an operator that isn't `=`.
//
//	$target += value
//	^^^^^^^^^^^^^^^^
type GlobalVariableOperatorWriteNode struct {
	NodeID            int      `json:"nodeID"`
	Location          Location `json:"location"`
	flags             uint32
	Name              string   `json:"name"`
	NameLoc           Location `json:"name_loc"`
	BinaryOperatorLoc Location `json:"binary_operator_loc"`
	Value             Node     `json:"value"`
	BinaryOperator    string   `json:"binary_operator"`
}

// NewGlobalVariableOperatorWriteNode creates a new GlobalVariableOperatorWriteNode.
func NewGlobalVariableOperatorWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, binary_operator_loc Location, value Node, binary_operator string) *GlobalVariableOperatorWriteNode {
	return &GlobalVariableOperatorWriteNode{
		NodeID:            nodeID,
		Location:          location,
		flags:             flags,
		Name:              name,
		NameLoc:           name_loc,
		BinaryOperatorLoc: binary_operator_loc,
		Value:             value,
		BinaryOperator:    binary_operator,
	}
}

// GetLocation returns the location of this node.
func (n *GlobalVariableOperatorWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *GlobalVariableOperatorWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *GlobalVariableOperatorWriteNode) Accept(visitor Visitor) {
	visitor.VisitGlobalVariableOperatorWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *GlobalVariableOperatorWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *GlobalVariableOperatorWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *GlobalVariableOperatorWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":                "GlobalVariableOperatorWriteNode",
		"location":            n.Location,
		"flags":               n.flags,
		"name":                n.Name,
		"name_loc":            n.NameLoc,
		"binary_operator_loc": n.BinaryOperatorLoc,
		"value":               n.Value,
		"binary_operator":     n.BinaryOperator,
	}
}

// Represents the use of the `||=` operator for assignment to a global variable.
//
//	$target ||= value
//	^^^^^^^^^^^^^^^^^
type GlobalVariableOrWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
}

// NewGlobalVariableOrWriteNode creates a new GlobalVariableOrWriteNode.
func NewGlobalVariableOrWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, operator_loc Location, value Node) *GlobalVariableOrWriteNode {
	return &GlobalVariableOrWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *GlobalVariableOrWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *GlobalVariableOrWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *GlobalVariableOrWriteNode) Accept(visitor Visitor) {
	visitor.VisitGlobalVariableOrWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *GlobalVariableOrWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *GlobalVariableOrWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *GlobalVariableOrWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "GlobalVariableOrWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents referencing a global variable.
//
//	$foo
//	^^^^
type GlobalVariableReadNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewGlobalVariableReadNode creates a new GlobalVariableReadNode.
func NewGlobalVariableReadNode(nodeID int, location Location, flags uint32, name string) *GlobalVariableReadNode {
	return &GlobalVariableReadNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *GlobalVariableReadNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *GlobalVariableReadNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *GlobalVariableReadNode) Accept(visitor Visitor) {
	visitor.VisitGlobalVariableReadNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *GlobalVariableReadNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *GlobalVariableReadNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *GlobalVariableReadNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "GlobalVariableReadNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents writing to a global variable in a context that doesn't have an explicit value.
//
//	$foo, $bar = baz
//	^^^^  ^^^^
type GlobalVariableTargetNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewGlobalVariableTargetNode creates a new GlobalVariableTargetNode.
func NewGlobalVariableTargetNode(nodeID int, location Location, flags uint32, name string) *GlobalVariableTargetNode {
	return &GlobalVariableTargetNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *GlobalVariableTargetNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *GlobalVariableTargetNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *GlobalVariableTargetNode) Accept(visitor Visitor) {
	visitor.VisitGlobalVariableTargetNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *GlobalVariableTargetNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *GlobalVariableTargetNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *GlobalVariableTargetNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "GlobalVariableTargetNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents writing to a global variable.
//
//	$foo = 1
//	^^^^^^^^
type GlobalVariableWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	Value       Node     `json:"value"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewGlobalVariableWriteNode creates a new GlobalVariableWriteNode.
func NewGlobalVariableWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, value Node, operator_loc Location) *GlobalVariableWriteNode {
	return &GlobalVariableWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		Value:       value,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *GlobalVariableWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *GlobalVariableWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *GlobalVariableWriteNode) Accept(visitor Visitor) {
	visitor.VisitGlobalVariableWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *GlobalVariableWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *GlobalVariableWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *GlobalVariableWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "GlobalVariableWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"value":        n.Value,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents a hash literal.
//
//	{ a => b }
//	^^^^^^^^^^
type HashNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc Location `json:"opening_loc"`
	Elements   []Node   `json:"elements"`
	ClosingLoc Location `json:"closing_loc"`
}

// NewHashNode creates a new HashNode.
func NewHashNode(nodeID int, location Location, flags uint32, opening_loc Location, elements []Node, closing_loc Location) *HashNode {
	return &HashNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		Elements:   elements,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *HashNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *HashNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *HashNode) Accept(visitor Visitor) {
	visitor.VisitHashNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *HashNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Elements...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *HashNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Elements...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *HashNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "HashNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"elements":    n.Elements,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents a hash pattern in pattern matching.
//
//	foo => { a: 1, b: 2 }
//	       ^^^^^^^^^^^^^^
//
//	foo => { a: 1, b: 2, **c }
//	       ^^^^^^^^^^^^^^^^^^^
type HashPatternNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Constant   Node      `json:"constant"`
	Elements   []Node    `json:"elements"`
	Rest       Node      `json:"rest"`
	OpeningLoc *Location `json:"opening_loc"`
	ClosingLoc *Location `json:"closing_loc"`
}

// NewHashPatternNode creates a new HashPatternNode.
func NewHashPatternNode(nodeID int, location Location, flags uint32, constant Node, elements []Node, rest Node, opening_loc *Location, closing_loc *Location) *HashPatternNode {
	return &HashPatternNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Constant:   constant,
		Elements:   elements,
		Rest:       rest,
		OpeningLoc: opening_loc,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *HashPatternNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *HashPatternNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *HashPatternNode) Accept(visitor Visitor) {
	visitor.VisitHashPatternNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *HashPatternNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Constant != nil {
		nodes = append(nodes, n.Constant)
	}
	nodes = append(nodes, n.Elements...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *HashPatternNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Constant != nil {
		nodes = append(nodes, n.Constant)
	}
	nodes = append(nodes, n.Elements...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *HashPatternNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "HashPatternNode",
		"location":    n.Location,
		"flags":       n.flags,
		"constant":    n.Constant,
		"elements":    n.Elements,
		"rest":        n.Rest,
		"opening_loc": n.OpeningLoc,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.
//
//	bar if foo
//	^^^^^^^^^^
//
//	if foo then bar end
//	^^^^^^^^^^^^^^^^^^^
//
//	foo ? bar : baz
//	^^^^^^^^^^^^^^^
type IfNode struct {
	NodeID         int      `json:"nodeID"`
	Location       Location `json:"location"`
	flags          uint32
	IfKeywordLoc   *Location       `json:"if_keyword_loc"`
	Predicate      Node            `json:"predicate"`
	ThenKeywordLoc *Location       `json:"then_keyword_loc"`
	Statements     *StatementsNode `json:"statements"`
	Subsequent     Node            `json:"subsequent"`
	EndKeywordLoc  *Location       `json:"end_keyword_loc"`
}

// NewIfNode creates a new IfNode.
func NewIfNode(nodeID int, location Location, flags uint32, if_keyword_loc *Location, predicate Node, then_keyword_loc *Location, statements *StatementsNode, subsequent Node, end_keyword_loc *Location) *IfNode {
	return &IfNode{
		NodeID:         nodeID,
		Location:       location,
		flags:          flags,
		IfKeywordLoc:   if_keyword_loc,
		Predicate:      predicate,
		ThenKeywordLoc: then_keyword_loc,
		Statements:     statements,
		Subsequent:     subsequent,
		EndKeywordLoc:  end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *IfNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *IfNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *IfNode) Accept(visitor Visitor) {
	visitor.VisitIfNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *IfNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Predicate)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	if n.Subsequent != nil {
		nodes = append(nodes, n.Subsequent)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *IfNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Predicate)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	if n.Subsequent != nil {
		nodes = append(nodes, n.Subsequent)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *IfNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":             "IfNode",
		"location":         n.Location,
		"flags":            n.flags,
		"if_keyword_loc":   n.IfKeywordLoc,
		"predicate":        n.Predicate,
		"then_keyword_loc": n.ThenKeywordLoc,
		"statements":       n.Statements,
		"subsequent":       n.Subsequent,
		"end_keyword_loc":  n.EndKeywordLoc,
	}
}

// Represents an imaginary number literal.
//
//	1.0i
//	^^^^
type ImaginaryNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Numeric  Node `json:"numeric"`
}

// NewImaginaryNode creates a new ImaginaryNode.
func NewImaginaryNode(nodeID int, location Location, flags uint32, numeric Node) *ImaginaryNode {
	return &ImaginaryNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Numeric:  numeric,
	}
}

// GetLocation returns the location of this node.
func (n *ImaginaryNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ImaginaryNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ImaginaryNode) Accept(visitor Visitor) {
	visitor.VisitImaginaryNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ImaginaryNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Numeric)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ImaginaryNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Numeric)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ImaginaryNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ImaginaryNode",
		"location": n.Location,
		"flags":    n.flags,
		"numeric":  n.Numeric,
	}
}

// Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.
//
//	{ foo: }
//	  ^^^^
//
//	{ Foo: }
//	  ^^^^
//
//	foo in { bar: }
//	         ^^^^
type ImplicitNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Value    Node `json:"value"`
}

// NewImplicitNode creates a new ImplicitNode.
func NewImplicitNode(nodeID int, location Location, flags uint32, value Node) *ImplicitNode {
	return &ImplicitNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Value:    value,
	}
}

// GetLocation returns the location of this node.
func (n *ImplicitNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ImplicitNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ImplicitNode) Accept(visitor Visitor) {
	visitor.VisitImplicitNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ImplicitNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ImplicitNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ImplicitNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ImplicitNode",
		"location": n.Location,
		"flags":    n.flags,
		"value":    n.Value,
	}
}

// Represents using a trailing comma to indicate an implicit rest parameter.
//
//	foo { |bar,| }
//	          ^
//
//	foo in [bar,]
//	           ^
//
//	for foo, in bar do end
//	       ^
//
//	foo, = bar
//	   ^
type ImplicitRestNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewImplicitRestNode creates a new ImplicitRestNode.
func NewImplicitRestNode(nodeID int, location Location, flags uint32) *ImplicitRestNode {
	return &ImplicitRestNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *ImplicitRestNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ImplicitRestNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ImplicitRestNode) Accept(visitor Visitor) {
	visitor.VisitImplicitRestNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ImplicitRestNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ImplicitRestNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ImplicitRestNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ImplicitRestNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents the use of the `in` keyword in a case statement.
//
//	case a; in b then c end
//	        ^^^^^^^^^^^
type InNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Pattern    Node            `json:"pattern"`
	Statements *StatementsNode `json:"statements"`
	InLoc      Location        `json:"in_loc"`
	ThenLoc    *Location       `json:"then_loc"`
}

// NewInNode creates a new InNode.
func NewInNode(nodeID int, location Location, flags uint32, pattern Node, statements *StatementsNode, in_loc Location, then_loc *Location) *InNode {
	return &InNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Pattern:    pattern,
		Statements: statements,
		InLoc:      in_loc,
		ThenLoc:    then_loc,
	}
}

// GetLocation returns the location of this node.
func (n *InNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *InNode) Accept(visitor Visitor) {
	visitor.VisitInNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Pattern)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Pattern)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":       "InNode",
		"location":   n.Location,
		"flags":      n.flags,
		"pattern":    n.Pattern,
		"statements": n.Statements,
		"in_loc":     n.InLoc,
		"then_loc":   n.ThenLoc,
	}
}

// Represents the use of the `&&=` operator on a call to the `[]` method.
//
//	foo.bar[baz] &&= value
//	^^^^^^^^^^^^^^^^^^^^^^
type IndexAndWriteNode struct {
	NodeID          int      `json:"nodeID"`
	Location        Location `json:"location"`
	flags           uint32
	Receiver        Node               `json:"receiver"`
	CallOperatorLoc *Location          `json:"call_operator_loc"`
	OpeningLoc      Location           `json:"opening_loc"`
	Arguments       *ArgumentsNode     `json:"arguments"`
	ClosingLoc      Location           `json:"closing_loc"`
	Block           *BlockArgumentNode `json:"block"`
	OperatorLoc     Location           `json:"operator_loc"`
	Value           Node               `json:"value"`
}

// NewIndexAndWriteNode creates a new IndexAndWriteNode.
func NewIndexAndWriteNode(nodeID int, location Location, flags uint32, receiver Node, call_operator_loc *Location, opening_loc Location, arguments *ArgumentsNode, closing_loc Location, block *BlockArgumentNode, operator_loc Location, value Node) *IndexAndWriteNode {
	return &IndexAndWriteNode{
		NodeID:          nodeID,
		Location:        location,
		flags:           flags,
		Receiver:        receiver,
		CallOperatorLoc: call_operator_loc,
		OpeningLoc:      opening_loc,
		Arguments:       arguments,
		ClosingLoc:      closing_loc,
		Block:           block,
		OperatorLoc:     operator_loc,
		Value:           value,
	}
}

// GetLocation returns the location of this node.
func (n *IndexAndWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *IndexAndWriteNode) GetNodeID() int {
	return n.NodeID
}

// IsSAFE_NAVIGATION returns true if this node has the SAFE_NAVIGATION flag.
func (n *IndexAndWriteNode) IsSAFE_NAVIGATION() bool {
	return (n.flags & CallNodeFlagsSAFE_NAVIGATION) != 0
}

// IsVARIABLE_CALL returns true if this node has the VARIABLE_CALL flag.
func (n *IndexAndWriteNode) IsVARIABLE_CALL() bool {
	return (n.flags & CallNodeFlagsVARIABLE_CALL) != 0
}

// IsATTRIBUTE_WRITE returns true if this node has the ATTRIBUTE_WRITE flag.
func (n *IndexAndWriteNode) IsATTRIBUTE_WRITE() bool {
	return (n.flags & CallNodeFlagsATTRIBUTE_WRITE) != 0
}

// IsIGNORE_VISIBILITY returns true if this node has the IGNORE_VISIBILITY flag.
func (n *IndexAndWriteNode) IsIGNORE_VISIBILITY() bool {
	return (n.flags & CallNodeFlagsIGNORE_VISIBILITY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *IndexAndWriteNode) Accept(visitor Visitor) {
	visitor.VisitIndexAndWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *IndexAndWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *IndexAndWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *IndexAndWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":              "IndexAndWriteNode",
		"location":          n.Location,
		"flags":             n.flags,
		"receiver":          n.Receiver,
		"call_operator_loc": n.CallOperatorLoc,
		"opening_loc":       n.OpeningLoc,
		"arguments":         n.Arguments,
		"closing_loc":       n.ClosingLoc,
		"block":             n.Block,
		"operator_loc":      n.OperatorLoc,
		"value":             n.Value,
	}
}

// Represents the use of an assignment operator on a call to `[]`.
//
//	foo.bar[baz] += value
//	^^^^^^^^^^^^^^^^^^^^^
type IndexOperatorWriteNode struct {
	NodeID            int      `json:"nodeID"`
	Location          Location `json:"location"`
	flags             uint32
	Receiver          Node               `json:"receiver"`
	CallOperatorLoc   *Location          `json:"call_operator_loc"`
	OpeningLoc        Location           `json:"opening_loc"`
	Arguments         *ArgumentsNode     `json:"arguments"`
	ClosingLoc        Location           `json:"closing_loc"`
	Block             *BlockArgumentNode `json:"block"`
	BinaryOperator    string             `json:"binary_operator"`
	BinaryOperatorLoc Location           `json:"binary_operator_loc"`
	Value             Node               `json:"value"`
}

// NewIndexOperatorWriteNode creates a new IndexOperatorWriteNode.
func NewIndexOperatorWriteNode(nodeID int, location Location, flags uint32, receiver Node, call_operator_loc *Location, opening_loc Location, arguments *ArgumentsNode, closing_loc Location, block *BlockArgumentNode, binary_operator string, binary_operator_loc Location, value Node) *IndexOperatorWriteNode {
	return &IndexOperatorWriteNode{
		NodeID:            nodeID,
		Location:          location,
		flags:             flags,
		Receiver:          receiver,
		CallOperatorLoc:   call_operator_loc,
		OpeningLoc:        opening_loc,
		Arguments:         arguments,
		ClosingLoc:        closing_loc,
		Block:             block,
		BinaryOperator:    binary_operator,
		BinaryOperatorLoc: binary_operator_loc,
		Value:             value,
	}
}

// GetLocation returns the location of this node.
func (n *IndexOperatorWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *IndexOperatorWriteNode) GetNodeID() int {
	return n.NodeID
}

// IsSAFE_NAVIGATION returns true if this node has the SAFE_NAVIGATION flag.
func (n *IndexOperatorWriteNode) IsSAFE_NAVIGATION() bool {
	return (n.flags & CallNodeFlagsSAFE_NAVIGATION) != 0
}

// IsVARIABLE_CALL returns true if this node has the VARIABLE_CALL flag.
func (n *IndexOperatorWriteNode) IsVARIABLE_CALL() bool {
	return (n.flags & CallNodeFlagsVARIABLE_CALL) != 0
}

// IsATTRIBUTE_WRITE returns true if this node has the ATTRIBUTE_WRITE flag.
func (n *IndexOperatorWriteNode) IsATTRIBUTE_WRITE() bool {
	return (n.flags & CallNodeFlagsATTRIBUTE_WRITE) != 0
}

// IsIGNORE_VISIBILITY returns true if this node has the IGNORE_VISIBILITY flag.
func (n *IndexOperatorWriteNode) IsIGNORE_VISIBILITY() bool {
	return (n.flags & CallNodeFlagsIGNORE_VISIBILITY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *IndexOperatorWriteNode) Accept(visitor Visitor) {
	visitor.VisitIndexOperatorWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *IndexOperatorWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *IndexOperatorWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *IndexOperatorWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":                "IndexOperatorWriteNode",
		"location":            n.Location,
		"flags":               n.flags,
		"receiver":            n.Receiver,
		"call_operator_loc":   n.CallOperatorLoc,
		"opening_loc":         n.OpeningLoc,
		"arguments":           n.Arguments,
		"closing_loc":         n.ClosingLoc,
		"block":               n.Block,
		"binary_operator":     n.BinaryOperator,
		"binary_operator_loc": n.BinaryOperatorLoc,
		"value":               n.Value,
	}
}

// Represents the use of the `||=` operator on a call to `[]`.
//
//	foo.bar[baz] ||= value
//	^^^^^^^^^^^^^^^^^^^^^^
type IndexOrWriteNode struct {
	NodeID          int      `json:"nodeID"`
	Location        Location `json:"location"`
	flags           uint32
	Receiver        Node               `json:"receiver"`
	CallOperatorLoc *Location          `json:"call_operator_loc"`
	OpeningLoc      Location           `json:"opening_loc"`
	Arguments       *ArgumentsNode     `json:"arguments"`
	ClosingLoc      Location           `json:"closing_loc"`
	Block           *BlockArgumentNode `json:"block"`
	OperatorLoc     Location           `json:"operator_loc"`
	Value           Node               `json:"value"`
}

// NewIndexOrWriteNode creates a new IndexOrWriteNode.
func NewIndexOrWriteNode(nodeID int, location Location, flags uint32, receiver Node, call_operator_loc *Location, opening_loc Location, arguments *ArgumentsNode, closing_loc Location, block *BlockArgumentNode, operator_loc Location, value Node) *IndexOrWriteNode {
	return &IndexOrWriteNode{
		NodeID:          nodeID,
		Location:        location,
		flags:           flags,
		Receiver:        receiver,
		CallOperatorLoc: call_operator_loc,
		OpeningLoc:      opening_loc,
		Arguments:       arguments,
		ClosingLoc:      closing_loc,
		Block:           block,
		OperatorLoc:     operator_loc,
		Value:           value,
	}
}

// GetLocation returns the location of this node.
func (n *IndexOrWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *IndexOrWriteNode) GetNodeID() int {
	return n.NodeID
}

// IsSAFE_NAVIGATION returns true if this node has the SAFE_NAVIGATION flag.
func (n *IndexOrWriteNode) IsSAFE_NAVIGATION() bool {
	return (n.flags & CallNodeFlagsSAFE_NAVIGATION) != 0
}

// IsVARIABLE_CALL returns true if this node has the VARIABLE_CALL flag.
func (n *IndexOrWriteNode) IsVARIABLE_CALL() bool {
	return (n.flags & CallNodeFlagsVARIABLE_CALL) != 0
}

// IsATTRIBUTE_WRITE returns true if this node has the ATTRIBUTE_WRITE flag.
func (n *IndexOrWriteNode) IsATTRIBUTE_WRITE() bool {
	return (n.flags & CallNodeFlagsATTRIBUTE_WRITE) != 0
}

// IsIGNORE_VISIBILITY returns true if this node has the IGNORE_VISIBILITY flag.
func (n *IndexOrWriteNode) IsIGNORE_VISIBILITY() bool {
	return (n.flags & CallNodeFlagsIGNORE_VISIBILITY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *IndexOrWriteNode) Accept(visitor Visitor) {
	visitor.VisitIndexOrWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *IndexOrWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *IndexOrWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Receiver != nil {
		nodes = append(nodes, n.Receiver)
	}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *IndexOrWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":              "IndexOrWriteNode",
		"location":          n.Location,
		"flags":             n.flags,
		"receiver":          n.Receiver,
		"call_operator_loc": n.CallOperatorLoc,
		"opening_loc":       n.OpeningLoc,
		"arguments":         n.Arguments,
		"closing_loc":       n.ClosingLoc,
		"block":             n.Block,
		"operator_loc":      n.OperatorLoc,
		"value":             n.Value,
	}
}

// Represents assigning to an index.
//
//	foo[bar], = 1
//	^^^^^^^^
//
//	begin
//	rescue => foo[bar]
//	          ^^^^^^^^
//	end
//
//	for foo[bar] in baz do end
//	    ^^^^^^^^
type IndexTargetNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Receiver   Node               `json:"receiver"`
	OpeningLoc Location           `json:"opening_loc"`
	Arguments  *ArgumentsNode     `json:"arguments"`
	ClosingLoc Location           `json:"closing_loc"`
	Block      *BlockArgumentNode `json:"block"`
}

// NewIndexTargetNode creates a new IndexTargetNode.
func NewIndexTargetNode(nodeID int, location Location, flags uint32, receiver Node, opening_loc Location, arguments *ArgumentsNode, closing_loc Location, block *BlockArgumentNode) *IndexTargetNode {
	return &IndexTargetNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Receiver:   receiver,
		OpeningLoc: opening_loc,
		Arguments:  arguments,
		ClosingLoc: closing_loc,
		Block:      block,
	}
}

// GetLocation returns the location of this node.
func (n *IndexTargetNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *IndexTargetNode) GetNodeID() int {
	return n.NodeID
}

// IsSAFE_NAVIGATION returns true if this node has the SAFE_NAVIGATION flag.
func (n *IndexTargetNode) IsSAFE_NAVIGATION() bool {
	return (n.flags & CallNodeFlagsSAFE_NAVIGATION) != 0
}

// IsVARIABLE_CALL returns true if this node has the VARIABLE_CALL flag.
func (n *IndexTargetNode) IsVARIABLE_CALL() bool {
	return (n.flags & CallNodeFlagsVARIABLE_CALL) != 0
}

// IsATTRIBUTE_WRITE returns true if this node has the ATTRIBUTE_WRITE flag.
func (n *IndexTargetNode) IsATTRIBUTE_WRITE() bool {
	return (n.flags & CallNodeFlagsATTRIBUTE_WRITE) != 0
}

// IsIGNORE_VISIBILITY returns true if this node has the IGNORE_VISIBILITY flag.
func (n *IndexTargetNode) IsIGNORE_VISIBILITY() bool {
	return (n.flags & CallNodeFlagsIGNORE_VISIBILITY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *IndexTargetNode) Accept(visitor Visitor) {
	visitor.VisitIndexTargetNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *IndexTargetNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Receiver)
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *IndexTargetNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Receiver)
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *IndexTargetNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "IndexTargetNode",
		"location":    n.Location,
		"flags":       n.flags,
		"receiver":    n.Receiver,
		"opening_loc": n.OpeningLoc,
		"arguments":   n.Arguments,
		"closing_loc": n.ClosingLoc,
		"block":       n.Block,
	}
}

// Represents the use of the `&&=` operator for assignment to an instance variable.
//
//	@target &&= value
//	^^^^^^^^^^^^^^^^^
type InstanceVariableAndWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
}

// NewInstanceVariableAndWriteNode creates a new InstanceVariableAndWriteNode.
func NewInstanceVariableAndWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, operator_loc Location, value Node) *InstanceVariableAndWriteNode {
	return &InstanceVariableAndWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *InstanceVariableAndWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InstanceVariableAndWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *InstanceVariableAndWriteNode) Accept(visitor Visitor) {
	visitor.VisitInstanceVariableAndWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InstanceVariableAndWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InstanceVariableAndWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InstanceVariableAndWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "InstanceVariableAndWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents assigning to an instance variable using an operator that isn't `=`.
//
//	@target += value
//	^^^^^^^^^^^^^^^^
type InstanceVariableOperatorWriteNode struct {
	NodeID            int      `json:"nodeID"`
	Location          Location `json:"location"`
	flags             uint32
	Name              string   `json:"name"`
	NameLoc           Location `json:"name_loc"`
	BinaryOperatorLoc Location `json:"binary_operator_loc"`
	Value             Node     `json:"value"`
	BinaryOperator    string   `json:"binary_operator"`
}

// NewInstanceVariableOperatorWriteNode creates a new InstanceVariableOperatorWriteNode.
func NewInstanceVariableOperatorWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, binary_operator_loc Location, value Node, binary_operator string) *InstanceVariableOperatorWriteNode {
	return &InstanceVariableOperatorWriteNode{
		NodeID:            nodeID,
		Location:          location,
		flags:             flags,
		Name:              name,
		NameLoc:           name_loc,
		BinaryOperatorLoc: binary_operator_loc,
		Value:             value,
		BinaryOperator:    binary_operator,
	}
}

// GetLocation returns the location of this node.
func (n *InstanceVariableOperatorWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InstanceVariableOperatorWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *InstanceVariableOperatorWriteNode) Accept(visitor Visitor) {
	visitor.VisitInstanceVariableOperatorWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InstanceVariableOperatorWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InstanceVariableOperatorWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InstanceVariableOperatorWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":                "InstanceVariableOperatorWriteNode",
		"location":            n.Location,
		"flags":               n.flags,
		"name":                n.Name,
		"name_loc":            n.NameLoc,
		"binary_operator_loc": n.BinaryOperatorLoc,
		"value":               n.Value,
		"binary_operator":     n.BinaryOperator,
	}
}

// Represents the use of the `||=` operator for assignment to an instance variable.
//
//	@target ||= value
//	^^^^^^^^^^^^^^^^^
type InstanceVariableOrWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
}

// NewInstanceVariableOrWriteNode creates a new InstanceVariableOrWriteNode.
func NewInstanceVariableOrWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, operator_loc Location, value Node) *InstanceVariableOrWriteNode {
	return &InstanceVariableOrWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *InstanceVariableOrWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InstanceVariableOrWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *InstanceVariableOrWriteNode) Accept(visitor Visitor) {
	visitor.VisitInstanceVariableOrWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InstanceVariableOrWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InstanceVariableOrWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InstanceVariableOrWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "InstanceVariableOrWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents referencing an instance variable.
//
//	@foo
//	^^^^
type InstanceVariableReadNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewInstanceVariableReadNode creates a new InstanceVariableReadNode.
func NewInstanceVariableReadNode(nodeID int, location Location, flags uint32, name string) *InstanceVariableReadNode {
	return &InstanceVariableReadNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *InstanceVariableReadNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InstanceVariableReadNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *InstanceVariableReadNode) Accept(visitor Visitor) {
	visitor.VisitInstanceVariableReadNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InstanceVariableReadNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InstanceVariableReadNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InstanceVariableReadNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "InstanceVariableReadNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents writing to an instance variable in a context that doesn't have an explicit value.
//
//	@foo, @bar = baz
//	^^^^  ^^^^
type InstanceVariableTargetNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewInstanceVariableTargetNode creates a new InstanceVariableTargetNode.
func NewInstanceVariableTargetNode(nodeID int, location Location, flags uint32, name string) *InstanceVariableTargetNode {
	return &InstanceVariableTargetNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *InstanceVariableTargetNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InstanceVariableTargetNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *InstanceVariableTargetNode) Accept(visitor Visitor) {
	visitor.VisitInstanceVariableTargetNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InstanceVariableTargetNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InstanceVariableTargetNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InstanceVariableTargetNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "InstanceVariableTargetNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents writing to an instance variable.
//
//	@foo = 1
//	^^^^^^^^
type InstanceVariableWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	Value       Node     `json:"value"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewInstanceVariableWriteNode creates a new InstanceVariableWriteNode.
func NewInstanceVariableWriteNode(nodeID int, location Location, flags uint32, name string, name_loc Location, value Node, operator_loc Location) *InstanceVariableWriteNode {
	return &InstanceVariableWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		Value:       value,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *InstanceVariableWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InstanceVariableWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *InstanceVariableWriteNode) Accept(visitor Visitor) {
	visitor.VisitInstanceVariableWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InstanceVariableWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InstanceVariableWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InstanceVariableWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "InstanceVariableWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"value":        n.Value,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents an integer number literal.
//
//	1
//	^
type IntegerNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Value    int64 `json:"value"`
}

// NewIntegerNode creates a new IntegerNode.
func NewIntegerNode(nodeID int, location Location, flags uint32, value int64) *IntegerNode {
	return &IntegerNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Value:    value,
	}
}

// GetLocation returns the location of this node.
func (n *IntegerNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *IntegerNode) GetNodeID() int {
	return n.NodeID
}

// IsBINARY returns true if this node has the BINARY flag.
func (n *IntegerNode) IsBINARY() bool {
	return (n.flags & IntegerBaseFlagsBINARY) != 0
}

// IsDECIMAL returns true if this node has the DECIMAL flag.
func (n *IntegerNode) IsDECIMAL() bool {
	return (n.flags & IntegerBaseFlagsDECIMAL) != 0
}

// IsOCTAL returns true if this node has the OCTAL flag.
func (n *IntegerNode) IsOCTAL() bool {
	return (n.flags & IntegerBaseFlagsOCTAL) != 0
}

// IsHEXADECIMAL returns true if this node has the HEXADECIMAL flag.
func (n *IntegerNode) IsHEXADECIMAL() bool {
	return (n.flags & IntegerBaseFlagsHEXADECIMAL) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *IntegerNode) Accept(visitor Visitor) {
	visitor.VisitIntegerNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *IntegerNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *IntegerNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *IntegerNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "IntegerNode",
		"location": n.Location,
		"flags":    n.flags,
		"value":    n.Value,
	}
}

// Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
//
//	if /foo #{bar} baz/ then end
//	   ^^^^^^^^^^^^^^^^
type InterpolatedMatchLastLineNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc Location `json:"opening_loc"`
	Parts      []Node   `json:"parts"`
	ClosingLoc Location `json:"closing_loc"`
}

// NewInterpolatedMatchLastLineNode creates a new InterpolatedMatchLastLineNode.
func NewInterpolatedMatchLastLineNode(nodeID int, location Location, flags uint32, opening_loc Location, parts []Node, closing_loc Location) *InterpolatedMatchLastLineNode {
	return &InterpolatedMatchLastLineNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		Parts:      parts,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *InterpolatedMatchLastLineNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InterpolatedMatchLastLineNode) GetNodeID() int {
	return n.NodeID
}

// IsIGNORE_CASE returns true if this node has the IGNORE_CASE flag.
func (n *InterpolatedMatchLastLineNode) IsIGNORE_CASE() bool {
	return (n.flags & RegularExpressionFlagsIGNORE_CASE) != 0
}

// IsEXTENDED returns true if this node has the EXTENDED flag.
func (n *InterpolatedMatchLastLineNode) IsEXTENDED() bool {
	return (n.flags & RegularExpressionFlagsEXTENDED) != 0
}

// IsMULTI_LINE returns true if this node has the MULTI_LINE flag.
func (n *InterpolatedMatchLastLineNode) IsMULTI_LINE() bool {
	return (n.flags & RegularExpressionFlagsMULTI_LINE) != 0
}

// IsONCE returns true if this node has the ONCE flag.
func (n *InterpolatedMatchLastLineNode) IsONCE() bool {
	return (n.flags & RegularExpressionFlagsONCE) != 0
}

// IsEUC_JP returns true if this node has the EUC_JP flag.
func (n *InterpolatedMatchLastLineNode) IsEUC_JP() bool {
	return (n.flags & RegularExpressionFlagsEUC_JP) != 0
}

// IsASCII_8BIT returns true if this node has the ASCII_8BIT flag.
func (n *InterpolatedMatchLastLineNode) IsASCII_8BIT() bool {
	return (n.flags & RegularExpressionFlagsASCII_8BIT) != 0
}

// IsWINDOWS_31J returns true if this node has the WINDOWS_31J flag.
func (n *InterpolatedMatchLastLineNode) IsWINDOWS_31J() bool {
	return (n.flags & RegularExpressionFlagsWINDOWS_31J) != 0
}

// IsUTF_8 returns true if this node has the UTF_8 flag.
func (n *InterpolatedMatchLastLineNode) IsUTF_8() bool {
	return (n.flags & RegularExpressionFlagsUTF_8) != 0
}

// IsFORCED_UTF8_ENCODING returns true if this node has the FORCED_UTF8_ENCODING flag.
func (n *InterpolatedMatchLastLineNode) IsFORCED_UTF8_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_UTF8_ENCODING) != 0
}

// IsFORCED_BINARY_ENCODING returns true if this node has the FORCED_BINARY_ENCODING flag.
func (n *InterpolatedMatchLastLineNode) IsFORCED_BINARY_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_BINARY_ENCODING) != 0
}

// IsFORCED_US_ASCII_ENCODING returns true if this node has the FORCED_US_ASCII_ENCODING flag.
func (n *InterpolatedMatchLastLineNode) IsFORCED_US_ASCII_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_US_ASCII_ENCODING) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *InterpolatedMatchLastLineNode) Accept(visitor Visitor) {
	visitor.VisitInterpolatedMatchLastLineNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InterpolatedMatchLastLineNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InterpolatedMatchLastLineNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InterpolatedMatchLastLineNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "InterpolatedMatchLastLineNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"parts":       n.Parts,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents a regular expression literal that contains interpolation.
//
//	/foo #{bar} baz/
//	^^^^^^^^^^^^^^^^
type InterpolatedRegularExpressionNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc Location `json:"opening_loc"`
	Parts      []Node   `json:"parts"`
	ClosingLoc Location `json:"closing_loc"`
}

// NewInterpolatedRegularExpressionNode creates a new InterpolatedRegularExpressionNode.
func NewInterpolatedRegularExpressionNode(nodeID int, location Location, flags uint32, opening_loc Location, parts []Node, closing_loc Location) *InterpolatedRegularExpressionNode {
	return &InterpolatedRegularExpressionNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		Parts:      parts,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *InterpolatedRegularExpressionNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InterpolatedRegularExpressionNode) GetNodeID() int {
	return n.NodeID
}

// IsIGNORE_CASE returns true if this node has the IGNORE_CASE flag.
func (n *InterpolatedRegularExpressionNode) IsIGNORE_CASE() bool {
	return (n.flags & RegularExpressionFlagsIGNORE_CASE) != 0
}

// IsEXTENDED returns true if this node has the EXTENDED flag.
func (n *InterpolatedRegularExpressionNode) IsEXTENDED() bool {
	return (n.flags & RegularExpressionFlagsEXTENDED) != 0
}

// IsMULTI_LINE returns true if this node has the MULTI_LINE flag.
func (n *InterpolatedRegularExpressionNode) IsMULTI_LINE() bool {
	return (n.flags & RegularExpressionFlagsMULTI_LINE) != 0
}

// IsONCE returns true if this node has the ONCE flag.
func (n *InterpolatedRegularExpressionNode) IsONCE() bool {
	return (n.flags & RegularExpressionFlagsONCE) != 0
}

// IsEUC_JP returns true if this node has the EUC_JP flag.
func (n *InterpolatedRegularExpressionNode) IsEUC_JP() bool {
	return (n.flags & RegularExpressionFlagsEUC_JP) != 0
}

// IsASCII_8BIT returns true if this node has the ASCII_8BIT flag.
func (n *InterpolatedRegularExpressionNode) IsASCII_8BIT() bool {
	return (n.flags & RegularExpressionFlagsASCII_8BIT) != 0
}

// IsWINDOWS_31J returns true if this node has the WINDOWS_31J flag.
func (n *InterpolatedRegularExpressionNode) IsWINDOWS_31J() bool {
	return (n.flags & RegularExpressionFlagsWINDOWS_31J) != 0
}

// IsUTF_8 returns true if this node has the UTF_8 flag.
func (n *InterpolatedRegularExpressionNode) IsUTF_8() bool {
	return (n.flags & RegularExpressionFlagsUTF_8) != 0
}

// IsFORCED_UTF8_ENCODING returns true if this node has the FORCED_UTF8_ENCODING flag.
func (n *InterpolatedRegularExpressionNode) IsFORCED_UTF8_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_UTF8_ENCODING) != 0
}

// IsFORCED_BINARY_ENCODING returns true if this node has the FORCED_BINARY_ENCODING flag.
func (n *InterpolatedRegularExpressionNode) IsFORCED_BINARY_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_BINARY_ENCODING) != 0
}

// IsFORCED_US_ASCII_ENCODING returns true if this node has the FORCED_US_ASCII_ENCODING flag.
func (n *InterpolatedRegularExpressionNode) IsFORCED_US_ASCII_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_US_ASCII_ENCODING) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *InterpolatedRegularExpressionNode) Accept(visitor Visitor) {
	visitor.VisitInterpolatedRegularExpressionNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InterpolatedRegularExpressionNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InterpolatedRegularExpressionNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InterpolatedRegularExpressionNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "InterpolatedRegularExpressionNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"parts":       n.Parts,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents a string literal that contains interpolation.
//
//	"foo #{bar} baz"
//	^^^^^^^^^^^^^^^^
type InterpolatedStringNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc *Location `json:"opening_loc"`
	Parts      []Node    `json:"parts"`
	ClosingLoc *Location `json:"closing_loc"`
}

// NewInterpolatedStringNode creates a new InterpolatedStringNode.
func NewInterpolatedStringNode(nodeID int, location Location, flags uint32, opening_loc *Location, parts []Node, closing_loc *Location) *InterpolatedStringNode {
	return &InterpolatedStringNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		Parts:      parts,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *InterpolatedStringNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InterpolatedStringNode) GetNodeID() int {
	return n.NodeID
}

// IsFROZEN returns true if this node has the FROZEN flag.
func (n *InterpolatedStringNode) IsFROZEN() bool {
	return (n.flags & InterpolatedStringNodeFlagsFROZEN) != 0
}

// IsMUTABLE returns true if this node has the MUTABLE flag.
func (n *InterpolatedStringNode) IsMUTABLE() bool {
	return (n.flags & InterpolatedStringNodeFlagsMUTABLE) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *InterpolatedStringNode) Accept(visitor Visitor) {
	visitor.VisitInterpolatedStringNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InterpolatedStringNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InterpolatedStringNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InterpolatedStringNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "InterpolatedStringNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"parts":       n.Parts,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents a symbol literal that contains interpolation.
//
//	:"foo #{bar} baz"
//	^^^^^^^^^^^^^^^^^
type InterpolatedSymbolNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc *Location `json:"opening_loc"`
	Parts      []Node    `json:"parts"`
	ClosingLoc *Location `json:"closing_loc"`
}

// NewInterpolatedSymbolNode creates a new InterpolatedSymbolNode.
func NewInterpolatedSymbolNode(nodeID int, location Location, flags uint32, opening_loc *Location, parts []Node, closing_loc *Location) *InterpolatedSymbolNode {
	return &InterpolatedSymbolNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		Parts:      parts,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *InterpolatedSymbolNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InterpolatedSymbolNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *InterpolatedSymbolNode) Accept(visitor Visitor) {
	visitor.VisitInterpolatedSymbolNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InterpolatedSymbolNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InterpolatedSymbolNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InterpolatedSymbolNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "InterpolatedSymbolNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"parts":       n.Parts,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents an xstring literal that contains interpolation.
//
//	`foo #{bar} baz`
//	^^^^^^^^^^^^^^^^
type InterpolatedXStringNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc Location `json:"opening_loc"`
	Parts      []Node   `json:"parts"`
	ClosingLoc Location `json:"closing_loc"`
}

// NewInterpolatedXStringNode creates a new InterpolatedXStringNode.
func NewInterpolatedXStringNode(nodeID int, location Location, flags uint32, opening_loc Location, parts []Node, closing_loc Location) *InterpolatedXStringNode {
	return &InterpolatedXStringNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		Parts:      parts,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *InterpolatedXStringNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *InterpolatedXStringNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *InterpolatedXStringNode) Accept(visitor Visitor) {
	visitor.VisitInterpolatedXStringNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *InterpolatedXStringNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *InterpolatedXStringNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Parts...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *InterpolatedXStringNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "InterpolatedXStringNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"parts":       n.Parts,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents reading from the implicit `it` local variable.
//
//	-> { it }
//	     ^^
type ItLocalVariableReadNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewItLocalVariableReadNode creates a new ItLocalVariableReadNode.
func NewItLocalVariableReadNode(nodeID int, location Location, flags uint32) *ItLocalVariableReadNode {
	return &ItLocalVariableReadNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *ItLocalVariableReadNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ItLocalVariableReadNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ItLocalVariableReadNode) Accept(visitor Visitor) {
	visitor.VisitItLocalVariableReadNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ItLocalVariableReadNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ItLocalVariableReadNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ItLocalVariableReadNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ItLocalVariableReadNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.
//
//	-> { it + it }
//	^^^^^^^^^^^^^^
type ItParametersNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewItParametersNode creates a new ItParametersNode.
func NewItParametersNode(nodeID int, location Location, flags uint32) *ItParametersNode {
	return &ItParametersNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *ItParametersNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ItParametersNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ItParametersNode) Accept(visitor Visitor) {
	visitor.VisitItParametersNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ItParametersNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ItParametersNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ItParametersNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ItParametersNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents a hash literal without opening and closing braces.
//
//	foo(a: b)
//	    ^^^^
type KeywordHashNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Elements []Node `json:"elements"`
}

// NewKeywordHashNode creates a new KeywordHashNode.
func NewKeywordHashNode(nodeID int, location Location, flags uint32, elements []Node) *KeywordHashNode {
	return &KeywordHashNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Elements: elements,
	}
}

// GetLocation returns the location of this node.
func (n *KeywordHashNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *KeywordHashNode) GetNodeID() int {
	return n.NodeID
}

// IsSYMBOL_KEYS returns true if this node has the SYMBOL_KEYS flag.
func (n *KeywordHashNode) IsSYMBOL_KEYS() bool {
	return (n.flags & KeywordHashNodeFlagsSYMBOL_KEYS) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *KeywordHashNode) Accept(visitor Visitor) {
	visitor.VisitKeywordHashNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *KeywordHashNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Elements...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *KeywordHashNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Elements...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *KeywordHashNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "KeywordHashNode",
		"location": n.Location,
		"flags":    n.flags,
		"elements": n.Elements,
	}
}

// Represents a keyword rest parameter to a method, block, or lambda definition.
//
//	def a(**b)
//	      ^^^
//	end
type KeywordRestParameterNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        *string   `json:"name"`
	NameLoc     *Location `json:"name_loc"`
	OperatorLoc Location  `json:"operator_loc"`
}

// NewKeywordRestParameterNode creates a new KeywordRestParameterNode.
func NewKeywordRestParameterNode(nodeID int, location Location, flags uint32, name *string, name_loc *Location, operator_loc Location) *KeywordRestParameterNode {
	return &KeywordRestParameterNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *KeywordRestParameterNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *KeywordRestParameterNode) GetNodeID() int {
	return n.NodeID
}

// IsREPEATED_PARAMETER returns true if this node has the REPEATED_PARAMETER flag.
func (n *KeywordRestParameterNode) IsREPEATED_PARAMETER() bool {
	return (n.flags & ParameterFlagsREPEATED_PARAMETER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *KeywordRestParameterNode) Accept(visitor Visitor) {
	visitor.VisitKeywordRestParameterNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *KeywordRestParameterNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *KeywordRestParameterNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *KeywordRestParameterNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "KeywordRestParameterNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents using a lambda literal (not the lambda method call).
//
//	->(value) { value * 2 }
//	^^^^^^^^^^^^^^^^^^^^^^^
type LambdaNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Locals      []string `json:"locals"`
	OperatorLoc Location `json:"operator_loc"`
	OpeningLoc  Location `json:"opening_loc"`
	ClosingLoc  Location `json:"closing_loc"`
	Parameters  Node     `json:"parameters"`
	Body        Node     `json:"body"`
}

// NewLambdaNode creates a new LambdaNode.
func NewLambdaNode(nodeID int, location Location, flags uint32, locals []string, operator_loc Location, opening_loc Location, closing_loc Location, parameters Node, body Node) *LambdaNode {
	return &LambdaNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Locals:      locals,
		OperatorLoc: operator_loc,
		OpeningLoc:  opening_loc,
		ClosingLoc:  closing_loc,
		Parameters:  parameters,
		Body:        body,
	}
}

// GetLocation returns the location of this node.
func (n *LambdaNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *LambdaNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *LambdaNode) Accept(visitor Visitor) {
	visitor.VisitLambdaNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *LambdaNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Parameters != nil {
		nodes = append(nodes, n.Parameters)
	}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *LambdaNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Parameters != nil {
		nodes = append(nodes, n.Parameters)
	}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *LambdaNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "LambdaNode",
		"location":     n.Location,
		"flags":        n.flags,
		"locals":       n.Locals,
		"operator_loc": n.OperatorLoc,
		"opening_loc":  n.OpeningLoc,
		"closing_loc":  n.ClosingLoc,
		"parameters":   n.Parameters,
		"body":         n.Body,
	}
}

// Represents the use of the `&&=` operator for assignment to a local variable.
//
//	target &&= value
//	^^^^^^^^^^^^^^^^
type LocalVariableAndWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
	Name        string   `json:"name"`
	Depth       uint32   `json:"depth"`
}

// NewLocalVariableAndWriteNode creates a new LocalVariableAndWriteNode.
func NewLocalVariableAndWriteNode(nodeID int, location Location, flags uint32, name_loc Location, operator_loc Location, value Node, name string, depth uint32) *LocalVariableAndWriteNode {
	return &LocalVariableAndWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
		Name:        name,
		Depth:       depth,
	}
}

// GetLocation returns the location of this node.
func (n *LocalVariableAndWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *LocalVariableAndWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *LocalVariableAndWriteNode) Accept(visitor Visitor) {
	visitor.VisitLocalVariableAndWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *LocalVariableAndWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *LocalVariableAndWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *LocalVariableAndWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "LocalVariableAndWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
		"name":         n.Name,
		"depth":        n.Depth,
	}
}

// Represents assigning to a local variable using an operator that isn't `=`.
//
//	target += value
//	^^^^^^^^^^^^^^^
type LocalVariableOperatorWriteNode struct {
	NodeID            int      `json:"nodeID"`
	Location          Location `json:"location"`
	flags             uint32
	NameLoc           Location `json:"name_loc"`
	BinaryOperatorLoc Location `json:"binary_operator_loc"`
	Value             Node     `json:"value"`
	Name              string   `json:"name"`
	BinaryOperator    string   `json:"binary_operator"`
	Depth             uint32   `json:"depth"`
}

// NewLocalVariableOperatorWriteNode creates a new LocalVariableOperatorWriteNode.
func NewLocalVariableOperatorWriteNode(nodeID int, location Location, flags uint32, name_loc Location, binary_operator_loc Location, value Node, name string, binary_operator string, depth uint32) *LocalVariableOperatorWriteNode {
	return &LocalVariableOperatorWriteNode{
		NodeID:            nodeID,
		Location:          location,
		flags:             flags,
		NameLoc:           name_loc,
		BinaryOperatorLoc: binary_operator_loc,
		Value:             value,
		Name:              name,
		BinaryOperator:    binary_operator,
		Depth:             depth,
	}
}

// GetLocation returns the location of this node.
func (n *LocalVariableOperatorWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *LocalVariableOperatorWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *LocalVariableOperatorWriteNode) Accept(visitor Visitor) {
	visitor.VisitLocalVariableOperatorWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *LocalVariableOperatorWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *LocalVariableOperatorWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *LocalVariableOperatorWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":                "LocalVariableOperatorWriteNode",
		"location":            n.Location,
		"flags":               n.flags,
		"name_loc":            n.NameLoc,
		"binary_operator_loc": n.BinaryOperatorLoc,
		"value":               n.Value,
		"name":                n.Name,
		"binary_operator":     n.BinaryOperator,
		"depth":               n.Depth,
	}
}

// Represents the use of the `||=` operator for assignment to a local variable.
//
//	target ||= value
//	^^^^^^^^^^^^^^^^
type LocalVariableOrWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
	Name        string   `json:"name"`
	Depth       uint32   `json:"depth"`
}

// NewLocalVariableOrWriteNode creates a new LocalVariableOrWriteNode.
func NewLocalVariableOrWriteNode(nodeID int, location Location, flags uint32, name_loc Location, operator_loc Location, value Node, name string, depth uint32) *LocalVariableOrWriteNode {
	return &LocalVariableOrWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
		Name:        name,
		Depth:       depth,
	}
}

// GetLocation returns the location of this node.
func (n *LocalVariableOrWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *LocalVariableOrWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *LocalVariableOrWriteNode) Accept(visitor Visitor) {
	visitor.VisitLocalVariableOrWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *LocalVariableOrWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *LocalVariableOrWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *LocalVariableOrWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "LocalVariableOrWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
		"name":         n.Name,
		"depth":        n.Depth,
	}
}

// Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
//
//	foo
//	^^^
type LocalVariableReadNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
	Depth    uint32 `json:"depth"`
}

// NewLocalVariableReadNode creates a new LocalVariableReadNode.
func NewLocalVariableReadNode(nodeID int, location Location, flags uint32, name string, depth uint32) *LocalVariableReadNode {
	return &LocalVariableReadNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
		Depth:    depth,
	}
}

// GetLocation returns the location of this node.
func (n *LocalVariableReadNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *LocalVariableReadNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *LocalVariableReadNode) Accept(visitor Visitor) {
	visitor.VisitLocalVariableReadNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *LocalVariableReadNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *LocalVariableReadNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *LocalVariableReadNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "LocalVariableReadNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
		"depth":    n.Depth,
	}
}

// Represents writing to a local variable in a context that doesn't have an explicit value.
//
//	foo, bar = baz
//	^^^  ^^^
type LocalVariableTargetNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
	Depth    uint32 `json:"depth"`
}

// NewLocalVariableTargetNode creates a new LocalVariableTargetNode.
func NewLocalVariableTargetNode(nodeID int, location Location, flags uint32, name string, depth uint32) *LocalVariableTargetNode {
	return &LocalVariableTargetNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
		Depth:    depth,
	}
}

// GetLocation returns the location of this node.
func (n *LocalVariableTargetNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *LocalVariableTargetNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *LocalVariableTargetNode) Accept(visitor Visitor) {
	visitor.VisitLocalVariableTargetNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *LocalVariableTargetNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *LocalVariableTargetNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *LocalVariableTargetNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "LocalVariableTargetNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
		"depth":    n.Depth,
	}
}

// Represents writing to a local variable.
//
//	foo = 1
//	^^^^^^^
type LocalVariableWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	Depth       uint32   `json:"depth"`
	NameLoc     Location `json:"name_loc"`
	Value       Node     `json:"value"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewLocalVariableWriteNode creates a new LocalVariableWriteNode.
func NewLocalVariableWriteNode(nodeID int, location Location, flags uint32, name string, depth uint32, name_loc Location, value Node, operator_loc Location) *LocalVariableWriteNode {
	return &LocalVariableWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		Depth:       depth,
		NameLoc:     name_loc,
		Value:       value,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *LocalVariableWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *LocalVariableWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *LocalVariableWriteNode) Accept(visitor Visitor) {
	visitor.VisitLocalVariableWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *LocalVariableWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *LocalVariableWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *LocalVariableWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "LocalVariableWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"depth":        n.Depth,
		"name_loc":     n.NameLoc,
		"value":        n.Value,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
//
//	if /foo/i then end
//	   ^^^^^^
type MatchLastLineNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc Location   `json:"opening_loc"`
	ContentLoc Location   `json:"content_loc"`
	ClosingLoc Location   `json:"closing_loc"`
	Unescaped  RubyString `json:"unescaped"`
}

// NewMatchLastLineNode creates a new MatchLastLineNode.
func NewMatchLastLineNode(nodeID int, location Location, flags uint32, opening_loc Location, content_loc Location, closing_loc Location, unescaped RubyString) *MatchLastLineNode {
	return &MatchLastLineNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		ContentLoc: content_loc,
		ClosingLoc: closing_loc,
		Unescaped:  unescaped,
	}
}

// GetLocation returns the location of this node.
func (n *MatchLastLineNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *MatchLastLineNode) GetNodeID() int {
	return n.NodeID
}

// IsIGNORE_CASE returns true if this node has the IGNORE_CASE flag.
func (n *MatchLastLineNode) IsIGNORE_CASE() bool {
	return (n.flags & RegularExpressionFlagsIGNORE_CASE) != 0
}

// IsEXTENDED returns true if this node has the EXTENDED flag.
func (n *MatchLastLineNode) IsEXTENDED() bool {
	return (n.flags & RegularExpressionFlagsEXTENDED) != 0
}

// IsMULTI_LINE returns true if this node has the MULTI_LINE flag.
func (n *MatchLastLineNode) IsMULTI_LINE() bool {
	return (n.flags & RegularExpressionFlagsMULTI_LINE) != 0
}

// IsONCE returns true if this node has the ONCE flag.
func (n *MatchLastLineNode) IsONCE() bool {
	return (n.flags & RegularExpressionFlagsONCE) != 0
}

// IsEUC_JP returns true if this node has the EUC_JP flag.
func (n *MatchLastLineNode) IsEUC_JP() bool {
	return (n.flags & RegularExpressionFlagsEUC_JP) != 0
}

// IsASCII_8BIT returns true if this node has the ASCII_8BIT flag.
func (n *MatchLastLineNode) IsASCII_8BIT() bool {
	return (n.flags & RegularExpressionFlagsASCII_8BIT) != 0
}

// IsWINDOWS_31J returns true if this node has the WINDOWS_31J flag.
func (n *MatchLastLineNode) IsWINDOWS_31J() bool {
	return (n.flags & RegularExpressionFlagsWINDOWS_31J) != 0
}

// IsUTF_8 returns true if this node has the UTF_8 flag.
func (n *MatchLastLineNode) IsUTF_8() bool {
	return (n.flags & RegularExpressionFlagsUTF_8) != 0
}

// IsFORCED_UTF8_ENCODING returns true if this node has the FORCED_UTF8_ENCODING flag.
func (n *MatchLastLineNode) IsFORCED_UTF8_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_UTF8_ENCODING) != 0
}

// IsFORCED_BINARY_ENCODING returns true if this node has the FORCED_BINARY_ENCODING flag.
func (n *MatchLastLineNode) IsFORCED_BINARY_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_BINARY_ENCODING) != 0
}

// IsFORCED_US_ASCII_ENCODING returns true if this node has the FORCED_US_ASCII_ENCODING flag.
func (n *MatchLastLineNode) IsFORCED_US_ASCII_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_US_ASCII_ENCODING) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *MatchLastLineNode) Accept(visitor Visitor) {
	visitor.VisitMatchLastLineNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *MatchLastLineNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *MatchLastLineNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *MatchLastLineNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "MatchLastLineNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"content_loc": n.ContentLoc,
		"closing_loc": n.ClosingLoc,
		"unescaped":   n.Unescaped,
	}
}

// Represents the use of the modifier `in` operator.
//
//	foo in bar
//	^^^^^^^^^^
type MatchPredicateNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Value       Node     `json:"value"`
	Pattern     Node     `json:"pattern"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewMatchPredicateNode creates a new MatchPredicateNode.
func NewMatchPredicateNode(nodeID int, location Location, flags uint32, value Node, pattern Node, operator_loc Location) *MatchPredicateNode {
	return &MatchPredicateNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Value:       value,
		Pattern:     pattern,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *MatchPredicateNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *MatchPredicateNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *MatchPredicateNode) Accept(visitor Visitor) {
	visitor.VisitMatchPredicateNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *MatchPredicateNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	nodes = append(nodes, n.Pattern)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *MatchPredicateNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	nodes = append(nodes, n.Pattern)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *MatchPredicateNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "MatchPredicateNode",
		"location":     n.Location,
		"flags":        n.flags,
		"value":        n.Value,
		"pattern":      n.Pattern,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents the use of the `=>` operator.
//
//	foo => bar
//	^^^^^^^^^^
type MatchRequiredNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Value       Node     `json:"value"`
	Pattern     Node     `json:"pattern"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewMatchRequiredNode creates a new MatchRequiredNode.
func NewMatchRequiredNode(nodeID int, location Location, flags uint32, value Node, pattern Node, operator_loc Location) *MatchRequiredNode {
	return &MatchRequiredNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Value:       value,
		Pattern:     pattern,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *MatchRequiredNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *MatchRequiredNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *MatchRequiredNode) Accept(visitor Visitor) {
	visitor.VisitMatchRequiredNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *MatchRequiredNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	nodes = append(nodes, n.Pattern)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *MatchRequiredNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	nodes = append(nodes, n.Pattern)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *MatchRequiredNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "MatchRequiredNode",
		"location":     n.Location,
		"flags":        n.flags,
		"value":        n.Value,
		"pattern":      n.Pattern,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents writing local variables using a regular expression match with named capture groups.
//
//	/(?<foo>bar)/ =~ baz
//	^^^^^^^^^^^^^^^^^^^^
type MatchWriteNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Call     *CallNode `json:"call"`
	Targets  []Node    `json:"targets"`
}

// NewMatchWriteNode creates a new MatchWriteNode.
func NewMatchWriteNode(nodeID int, location Location, flags uint32, call *CallNode, targets []Node) *MatchWriteNode {
	return &MatchWriteNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Call:     call,
		Targets:  targets,
	}
}

// GetLocation returns the location of this node.
func (n *MatchWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *MatchWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *MatchWriteNode) Accept(visitor Visitor) {
	visitor.VisitMatchWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *MatchWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Call)
	nodes = append(nodes, n.Targets...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *MatchWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Call)
	nodes = append(nodes, n.Targets...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *MatchWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "MatchWriteNode",
		"location": n.Location,
		"flags":    n.flags,
		"call":     n.Call,
		"targets":  n.Targets,
	}
}

// Represents a node that is missing from the source and results in a syntax error.
type MissingNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewMissingNode creates a new MissingNode.
func NewMissingNode(nodeID int, location Location, flags uint32) *MissingNode {
	return &MissingNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *MissingNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *MissingNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *MissingNode) Accept(visitor Visitor) {
	visitor.VisitMissingNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *MissingNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *MissingNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *MissingNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "MissingNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents a module declaration involving the `module` keyword.
//
//	module Foo end
//	^^^^^^^^^^^^^^
type ModuleNode struct {
	NodeID           int      `json:"nodeID"`
	Location         Location `json:"location"`
	flags            uint32
	Locals           []string `json:"locals"`
	ModuleKeywordLoc Location `json:"module_keyword_loc"`
	ConstantPath     Node     `json:"constant_path"`
	Body             Node     `json:"body"`
	EndKeywordLoc    Location `json:"end_keyword_loc"`
	Name             string   `json:"name"`
}

// NewModuleNode creates a new ModuleNode.
func NewModuleNode(nodeID int, location Location, flags uint32, locals []string, module_keyword_loc Location, constant_path Node, body Node, end_keyword_loc Location, name string) *ModuleNode {
	return &ModuleNode{
		NodeID:           nodeID,
		Location:         location,
		flags:            flags,
		Locals:           locals,
		ModuleKeywordLoc: module_keyword_loc,
		ConstantPath:     constant_path,
		Body:             body,
		EndKeywordLoc:    end_keyword_loc,
		Name:             name,
	}
}

// GetLocation returns the location of this node.
func (n *ModuleNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ModuleNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ModuleNode) Accept(visitor Visitor) {
	visitor.VisitModuleNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ModuleNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.ConstantPath)
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ModuleNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.ConstantPath)
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ModuleNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":               "ModuleNode",
		"location":           n.Location,
		"flags":              n.flags,
		"locals":             n.Locals,
		"module_keyword_loc": n.ModuleKeywordLoc,
		"constant_path":      n.ConstantPath,
		"body":               n.Body,
		"end_keyword_loc":    n.EndKeywordLoc,
		"name":               n.Name,
	}
}

// Represents a multi-target expression.
//
//	a, (b, c) = 1, 2, 3
//	   ^^^^^^
//
// This can be a part of `MultiWriteNode` as above, or the target of a `for` loop
//
//	for a, b in [[1, 2], [3, 4]]
//	    ^^^^
type MultiTargetNode struct {
	NodeID    int      `json:"nodeID"`
	Location  Location `json:"location"`
	flags     uint32
	Lefts     []Node    `json:"lefts"`
	Rest      Node      `json:"rest"`
	Rights    []Node    `json:"rights"`
	LparenLoc *Location `json:"lparen_loc"`
	RparenLoc *Location `json:"rparen_loc"`
}

// NewMultiTargetNode creates a new MultiTargetNode.
func NewMultiTargetNode(nodeID int, location Location, flags uint32, lefts []Node, rest Node, rights []Node, lparen_loc *Location, rparen_loc *Location) *MultiTargetNode {
	return &MultiTargetNode{
		NodeID:    nodeID,
		Location:  location,
		flags:     flags,
		Lefts:     lefts,
		Rest:      rest,
		Rights:    rights,
		LparenLoc: lparen_loc,
		RparenLoc: rparen_loc,
	}
}

// GetLocation returns the location of this node.
func (n *MultiTargetNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *MultiTargetNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *MultiTargetNode) Accept(visitor Visitor) {
	visitor.VisitMultiTargetNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *MultiTargetNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Lefts...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	nodes = append(nodes, n.Rights...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *MultiTargetNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Lefts...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	nodes = append(nodes, n.Rights...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *MultiTargetNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":       "MultiTargetNode",
		"location":   n.Location,
		"flags":      n.flags,
		"lefts":      n.Lefts,
		"rest":       n.Rest,
		"rights":     n.Rights,
		"lparen_loc": n.LparenLoc,
		"rparen_loc": n.RparenLoc,
	}
}

// Represents a write to a multi-target expression.
//
//	a, b, c = 1, 2, 3
//	^^^^^^^^^^^^^^^^^
type MultiWriteNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Lefts       []Node    `json:"lefts"`
	Rest        Node      `json:"rest"`
	Rights      []Node    `json:"rights"`
	LparenLoc   *Location `json:"lparen_loc"`
	RparenLoc   *Location `json:"rparen_loc"`
	OperatorLoc Location  `json:"operator_loc"`
	Value       Node      `json:"value"`
}

// NewMultiWriteNode creates a new MultiWriteNode.
func NewMultiWriteNode(nodeID int, location Location, flags uint32, lefts []Node, rest Node, rights []Node, lparen_loc *Location, rparen_loc *Location, operator_loc Location, value Node) *MultiWriteNode {
	return &MultiWriteNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Lefts:       lefts,
		Rest:        rest,
		Rights:      rights,
		LparenLoc:   lparen_loc,
		RparenLoc:   rparen_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *MultiWriteNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *MultiWriteNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *MultiWriteNode) Accept(visitor Visitor) {
	visitor.VisitMultiWriteNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *MultiWriteNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Lefts...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	nodes = append(nodes, n.Rights...)
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *MultiWriteNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Lefts...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	nodes = append(nodes, n.Rights...)
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *MultiWriteNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "MultiWriteNode",
		"location":     n.Location,
		"flags":        n.flags,
		"lefts":        n.Lefts,
		"rest":         n.Rest,
		"rights":       n.Rights,
		"lparen_loc":   n.LparenLoc,
		"rparen_loc":   n.RparenLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents the use of the `next` keyword.
//
//	next 1
//	^^^^^^
type NextNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Arguments  *ArgumentsNode `json:"arguments"`
	KeywordLoc Location       `json:"keyword_loc"`
}

// NewNextNode creates a new NextNode.
func NewNextNode(nodeID int, location Location, flags uint32, arguments *ArgumentsNode, keyword_loc Location) *NextNode {
	return &NextNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Arguments:  arguments,
		KeywordLoc: keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *NextNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *NextNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *NextNode) Accept(visitor Visitor) {
	visitor.VisitNextNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *NextNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *NextNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *NextNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "NextNode",
		"location":    n.Location,
		"flags":       n.flags,
		"arguments":   n.Arguments,
		"keyword_loc": n.KeywordLoc,
	}
}

// Represents the use of the `nil` keyword.
//
//	nil
//	^^^
type NilNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewNilNode creates a new NilNode.
func NewNilNode(nodeID int, location Location, flags uint32) *NilNode {
	return &NilNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *NilNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *NilNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *NilNode) Accept(visitor Visitor) {
	visitor.VisitNilNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *NilNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *NilNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *NilNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "NilNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents the use of `**nil` inside method arguments.
//
//	def a(**nil)
//	      ^^^^^
//	end
type NoKeywordsParameterNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	OperatorLoc Location `json:"operator_loc"`
	KeywordLoc  Location `json:"keyword_loc"`
}

// NewNoKeywordsParameterNode creates a new NoKeywordsParameterNode.
func NewNoKeywordsParameterNode(nodeID int, location Location, flags uint32, operator_loc Location, keyword_loc Location) *NoKeywordsParameterNode {
	return &NoKeywordsParameterNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		OperatorLoc: operator_loc,
		KeywordLoc:  keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *NoKeywordsParameterNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *NoKeywordsParameterNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *NoKeywordsParameterNode) Accept(visitor Visitor) {
	visitor.VisitNoKeywordsParameterNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *NoKeywordsParameterNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *NoKeywordsParameterNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *NoKeywordsParameterNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "NoKeywordsParameterNode",
		"location":     n.Location,
		"flags":        n.flags,
		"operator_loc": n.OperatorLoc,
		"keyword_loc":  n.KeywordLoc,
	}
}

// Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
//
//	-> { _1 + _2 }
//	^^^^^^^^^^^^^^
type NumberedParametersNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Maximum  uint8 `json:"maximum"`
}

// NewNumberedParametersNode creates a new NumberedParametersNode.
func NewNumberedParametersNode(nodeID int, location Location, flags uint32, maximum uint8) *NumberedParametersNode {
	return &NumberedParametersNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Maximum:  maximum,
	}
}

// GetLocation returns the location of this node.
func (n *NumberedParametersNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *NumberedParametersNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *NumberedParametersNode) Accept(visitor Visitor) {
	visitor.VisitNumberedParametersNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *NumberedParametersNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *NumberedParametersNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *NumberedParametersNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "NumberedParametersNode",
		"location": n.Location,
		"flags":    n.flags,
		"maximum":  n.Maximum,
	}
}

// Represents reading a numbered reference to a capture in the previous match.
//
//	$1
//	^^
type NumberedReferenceReadNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Number   uint32 `json:"number"`
}

// NewNumberedReferenceReadNode creates a new NumberedReferenceReadNode.
func NewNumberedReferenceReadNode(nodeID int, location Location, flags uint32, number uint32) *NumberedReferenceReadNode {
	return &NumberedReferenceReadNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Number:   number,
	}
}

// GetLocation returns the location of this node.
func (n *NumberedReferenceReadNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *NumberedReferenceReadNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *NumberedReferenceReadNode) Accept(visitor Visitor) {
	visitor.VisitNumberedReferenceReadNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *NumberedReferenceReadNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *NumberedReferenceReadNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *NumberedReferenceReadNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "NumberedReferenceReadNode",
		"location": n.Location,
		"flags":    n.flags,
		"number":   n.Number,
	}
}

// Represents an optional keyword parameter to a method, block, or lambda definition.
//
//	def a(b: 1)
//	      ^^^^
//	end
type OptionalKeywordParameterNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string   `json:"name"`
	NameLoc  Location `json:"name_loc"`
	Value    Node     `json:"value"`
}

// NewOptionalKeywordParameterNode creates a new OptionalKeywordParameterNode.
func NewOptionalKeywordParameterNode(nodeID int, location Location, flags uint32, name string, name_loc Location, value Node) *OptionalKeywordParameterNode {
	return &OptionalKeywordParameterNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
		NameLoc:  name_loc,
		Value:    value,
	}
}

// GetLocation returns the location of this node.
func (n *OptionalKeywordParameterNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *OptionalKeywordParameterNode) GetNodeID() int {
	return n.NodeID
}

// IsREPEATED_PARAMETER returns true if this node has the REPEATED_PARAMETER flag.
func (n *OptionalKeywordParameterNode) IsREPEATED_PARAMETER() bool {
	return (n.flags & ParameterFlagsREPEATED_PARAMETER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *OptionalKeywordParameterNode) Accept(visitor Visitor) {
	visitor.VisitOptionalKeywordParameterNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *OptionalKeywordParameterNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *OptionalKeywordParameterNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *OptionalKeywordParameterNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "OptionalKeywordParameterNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
		"name_loc": n.NameLoc,
		"value":    n.Value,
	}
}

// Represents an optional parameter to a method, block, or lambda definition.
//
//	def a(b = 1)
//	      ^^^^^
//	end
type OptionalParameterNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        string   `json:"name"`
	NameLoc     Location `json:"name_loc"`
	OperatorLoc Location `json:"operator_loc"`
	Value       Node     `json:"value"`
}

// NewOptionalParameterNode creates a new OptionalParameterNode.
func NewOptionalParameterNode(nodeID int, location Location, flags uint32, name string, name_loc Location, operator_loc Location, value Node) *OptionalParameterNode {
	return &OptionalParameterNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
		Value:       value,
	}
}

// GetLocation returns the location of this node.
func (n *OptionalParameterNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *OptionalParameterNode) GetNodeID() int {
	return n.NodeID
}

// IsREPEATED_PARAMETER returns true if this node has the REPEATED_PARAMETER flag.
func (n *OptionalParameterNode) IsREPEATED_PARAMETER() bool {
	return (n.flags & ParameterFlagsREPEATED_PARAMETER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *OptionalParameterNode) Accept(visitor Visitor) {
	visitor.VisitOptionalParameterNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *OptionalParameterNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *OptionalParameterNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Value)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *OptionalParameterNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "OptionalParameterNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
		"value":        n.Value,
	}
}

// Represents the use of the `||` operator or the `or` keyword.
//
//	left or right
//	^^^^^^^^^^^^^
type OrNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Left        Node     `json:"left"`
	Right       Node     `json:"right"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewOrNode creates a new OrNode.
func NewOrNode(nodeID int, location Location, flags uint32, left Node, right Node, operator_loc Location) *OrNode {
	return &OrNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Left:        left,
		Right:       right,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *OrNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *OrNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *OrNode) Accept(visitor Visitor) {
	visitor.VisitOrNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *OrNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Left)
	nodes = append(nodes, n.Right)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *OrNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Left)
	nodes = append(nodes, n.Right)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *OrNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "OrNode",
		"location":     n.Location,
		"flags":        n.flags,
		"left":         n.Left,
		"right":        n.Right,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents the list of parameters on a method, block, or lambda definition.
//
//	def a(b, c, d)
//	      ^^^^^^^
//	end
type ParametersNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Requireds   []Node              `json:"requireds"`
	Optionals   []Node              `json:"optionals"`
	Rest        Node                `json:"rest"`
	Posts       []Node              `json:"posts"`
	Keywords    []Node              `json:"keywords"`
	KeywordRest Node                `json:"keyword_rest"`
	Block       *BlockParameterNode `json:"block"`
}

// NewParametersNode creates a new ParametersNode.
func NewParametersNode(nodeID int, location Location, flags uint32, requireds []Node, optionals []Node, rest Node, posts []Node, keywords []Node, keyword_rest Node, block *BlockParameterNode) *ParametersNode {
	return &ParametersNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Requireds:   requireds,
		Optionals:   optionals,
		Rest:        rest,
		Posts:       posts,
		Keywords:    keywords,
		KeywordRest: keyword_rest,
		Block:       block,
	}
}

// GetLocation returns the location of this node.
func (n *ParametersNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ParametersNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ParametersNode) Accept(visitor Visitor) {
	visitor.VisitParametersNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ParametersNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Requireds...)
	nodes = append(nodes, n.Optionals...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	nodes = append(nodes, n.Posts...)
	nodes = append(nodes, n.Keywords...)
	if n.KeywordRest != nil {
		nodes = append(nodes, n.KeywordRest)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ParametersNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Requireds...)
	nodes = append(nodes, n.Optionals...)
	if n.Rest != nil {
		nodes = append(nodes, n.Rest)
	}
	nodes = append(nodes, n.Posts...)
	nodes = append(nodes, n.Keywords...)
	if n.KeywordRest != nil {
		nodes = append(nodes, n.KeywordRest)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ParametersNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "ParametersNode",
		"location":     n.Location,
		"flags":        n.flags,
		"requireds":    n.Requireds,
		"optionals":    n.Optionals,
		"rest":         n.Rest,
		"posts":        n.Posts,
		"keywords":     n.Keywords,
		"keyword_rest": n.KeywordRest,
		"block":        n.Block,
	}
}

// Represents a parenthesized expression
//
//	(10 + 34)
//	^^^^^^^^^
type ParenthesesNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Body       Node     `json:"body"`
	OpeningLoc Location `json:"opening_loc"`
	ClosingLoc Location `json:"closing_loc"`
}

// NewParenthesesNode creates a new ParenthesesNode.
func NewParenthesesNode(nodeID int, location Location, flags uint32, body Node, opening_loc Location, closing_loc Location) *ParenthesesNode {
	return &ParenthesesNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Body:       body,
		OpeningLoc: opening_loc,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *ParenthesesNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ParenthesesNode) GetNodeID() int {
	return n.NodeID
}

// IsMULTIPLE_STATEMENTS returns true if this node has the MULTIPLE_STATEMENTS flag.
func (n *ParenthesesNode) IsMULTIPLE_STATEMENTS() bool {
	return (n.flags & ParenthesesNodeFlagsMULTIPLE_STATEMENTS) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *ParenthesesNode) Accept(visitor Visitor) {
	visitor.VisitParenthesesNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ParenthesesNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ParenthesesNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ParenthesesNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "ParenthesesNode",
		"location":    n.Location,
		"flags":       n.flags,
		"body":        n.Body,
		"opening_loc": n.OpeningLoc,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
//
//	foo in ^(bar)
//	       ^^^^^^
type PinnedExpressionNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Expression  Node     `json:"expression"`
	OperatorLoc Location `json:"operator_loc"`
	LparenLoc   Location `json:"lparen_loc"`
	RparenLoc   Location `json:"rparen_loc"`
}

// NewPinnedExpressionNode creates a new PinnedExpressionNode.
func NewPinnedExpressionNode(nodeID int, location Location, flags uint32, expression Node, operator_loc Location, lparen_loc Location, rparen_loc Location) *PinnedExpressionNode {
	return &PinnedExpressionNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Expression:  expression,
		OperatorLoc: operator_loc,
		LparenLoc:   lparen_loc,
		RparenLoc:   rparen_loc,
	}
}

// GetLocation returns the location of this node.
func (n *PinnedExpressionNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *PinnedExpressionNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *PinnedExpressionNode) Accept(visitor Visitor) {
	visitor.VisitPinnedExpressionNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *PinnedExpressionNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Expression)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *PinnedExpressionNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Expression)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *PinnedExpressionNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "PinnedExpressionNode",
		"location":     n.Location,
		"flags":        n.flags,
		"expression":   n.Expression,
		"operator_loc": n.OperatorLoc,
		"lparen_loc":   n.LparenLoc,
		"rparen_loc":   n.RparenLoc,
	}
}

// Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
//
//	foo in ^bar
//	       ^^^^
type PinnedVariableNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Variable    Node     `json:"variable"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewPinnedVariableNode creates a new PinnedVariableNode.
func NewPinnedVariableNode(nodeID int, location Location, flags uint32, variable Node, operator_loc Location) *PinnedVariableNode {
	return &PinnedVariableNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Variable:    variable,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *PinnedVariableNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *PinnedVariableNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *PinnedVariableNode) Accept(visitor Visitor) {
	visitor.VisitPinnedVariableNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *PinnedVariableNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Variable)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *PinnedVariableNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Variable)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *PinnedVariableNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "PinnedVariableNode",
		"location":     n.Location,
		"flags":        n.flags,
		"variable":     n.Variable,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents the use of the `END` keyword.
//
//	END { foo }
//	^^^^^^^^^^^
type PostExecutionNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Statements *StatementsNode `json:"statements"`
	KeywordLoc Location        `json:"keyword_loc"`
	OpeningLoc Location        `json:"opening_loc"`
	ClosingLoc Location        `json:"closing_loc"`
}

// NewPostExecutionNode creates a new PostExecutionNode.
func NewPostExecutionNode(nodeID int, location Location, flags uint32, statements *StatementsNode, keyword_loc Location, opening_loc Location, closing_loc Location) *PostExecutionNode {
	return &PostExecutionNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Statements: statements,
		KeywordLoc: keyword_loc,
		OpeningLoc: opening_loc,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *PostExecutionNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *PostExecutionNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *PostExecutionNode) Accept(visitor Visitor) {
	visitor.VisitPostExecutionNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *PostExecutionNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *PostExecutionNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *PostExecutionNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "PostExecutionNode",
		"location":    n.Location,
		"flags":       n.flags,
		"statements":  n.Statements,
		"keyword_loc": n.KeywordLoc,
		"opening_loc": n.OpeningLoc,
		"closing_loc": n.ClosingLoc,
	}
}

// Represents the use of the `BEGIN` keyword.
//
//	BEGIN { foo }
//	^^^^^^^^^^^^^
type PreExecutionNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Statements *StatementsNode `json:"statements"`
	KeywordLoc Location        `json:"keyword_loc"`
	OpeningLoc Location        `json:"opening_loc"`
	ClosingLoc Location        `json:"closing_loc"`
}

// NewPreExecutionNode creates a new PreExecutionNode.
func NewPreExecutionNode(nodeID int, location Location, flags uint32, statements *StatementsNode, keyword_loc Location, opening_loc Location, closing_loc Location) *PreExecutionNode {
	return &PreExecutionNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Statements: statements,
		KeywordLoc: keyword_loc,
		OpeningLoc: opening_loc,
		ClosingLoc: closing_loc,
	}
}

// GetLocation returns the location of this node.
func (n *PreExecutionNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *PreExecutionNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *PreExecutionNode) Accept(visitor Visitor) {
	visitor.VisitPreExecutionNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *PreExecutionNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *PreExecutionNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *PreExecutionNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "PreExecutionNode",
		"location":    n.Location,
		"flags":       n.flags,
		"statements":  n.Statements,
		"keyword_loc": n.KeywordLoc,
		"opening_loc": n.OpeningLoc,
		"closing_loc": n.ClosingLoc,
	}
}

// The top level node of any parse tree.
type ProgramNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Locals     []string        `json:"locals"`
	Statements *StatementsNode `json:"statements"`
}

// NewProgramNode creates a new ProgramNode.
func NewProgramNode(nodeID int, location Location, flags uint32, locals []string, statements *StatementsNode) *ProgramNode {
	return &ProgramNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Locals:     locals,
		Statements: statements,
	}
}

// GetLocation returns the location of this node.
func (n *ProgramNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ProgramNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ProgramNode) Accept(visitor Visitor) {
	visitor.VisitProgramNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ProgramNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Statements)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ProgramNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Statements)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ProgramNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":       "ProgramNode",
		"location":   n.Location,
		"flags":      n.flags,
		"locals":     n.Locals,
		"statements": n.Statements,
	}
}

// Represents the use of the `..` or `...` operators.
//
//	1..2
//	^^^^
//
//	c if a =~ /left/ ... b =~ /right/
//	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
type RangeNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Left        Node     `json:"left"`
	Right       Node     `json:"right"`
	OperatorLoc Location `json:"operator_loc"`
}

// NewRangeNode creates a new RangeNode.
func NewRangeNode(nodeID int, location Location, flags uint32, left Node, right Node, operator_loc Location) *RangeNode {
	return &RangeNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Left:        left,
		Right:       right,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *RangeNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RangeNode) GetNodeID() int {
	return n.NodeID
}

// IsEXCLUDE_END returns true if this node has the EXCLUDE_END flag.
func (n *RangeNode) IsEXCLUDE_END() bool {
	return (n.flags & RangeFlagsEXCLUDE_END) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *RangeNode) Accept(visitor Visitor) {
	visitor.VisitRangeNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RangeNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Left != nil {
		nodes = append(nodes, n.Left)
	}
	if n.Right != nil {
		nodes = append(nodes, n.Right)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RangeNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Left != nil {
		nodes = append(nodes, n.Left)
	}
	if n.Right != nil {
		nodes = append(nodes, n.Right)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RangeNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "RangeNode",
		"location":     n.Location,
		"flags":        n.flags,
		"left":         n.Left,
		"right":        n.Right,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents a rational number literal.
//
//	1.0r
//	^^^^
type RationalNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Numerator   int64 `json:"numerator"`
	Denominator int64 `json:"denominator"`
}

// NewRationalNode creates a new RationalNode.
func NewRationalNode(nodeID int, location Location, flags uint32, numerator int64, denominator int64) *RationalNode {
	return &RationalNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Numerator:   numerator,
		Denominator: denominator,
	}
}

// GetLocation returns the location of this node.
func (n *RationalNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RationalNode) GetNodeID() int {
	return n.NodeID
}

// IsBINARY returns true if this node has the BINARY flag.
func (n *RationalNode) IsBINARY() bool {
	return (n.flags & IntegerBaseFlagsBINARY) != 0
}

// IsDECIMAL returns true if this node has the DECIMAL flag.
func (n *RationalNode) IsDECIMAL() bool {
	return (n.flags & IntegerBaseFlagsDECIMAL) != 0
}

// IsOCTAL returns true if this node has the OCTAL flag.
func (n *RationalNode) IsOCTAL() bool {
	return (n.flags & IntegerBaseFlagsOCTAL) != 0
}

// IsHEXADECIMAL returns true if this node has the HEXADECIMAL flag.
func (n *RationalNode) IsHEXADECIMAL() bool {
	return (n.flags & IntegerBaseFlagsHEXADECIMAL) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *RationalNode) Accept(visitor Visitor) {
	visitor.VisitRationalNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RationalNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RationalNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RationalNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "RationalNode",
		"location":    n.Location,
		"flags":       n.flags,
		"numerator":   n.Numerator,
		"denominator": n.Denominator,
	}
}

// Represents the use of the `redo` keyword.
//
//	redo
//	^^^^
type RedoNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewRedoNode creates a new RedoNode.
func NewRedoNode(nodeID int, location Location, flags uint32) *RedoNode {
	return &RedoNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *RedoNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RedoNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *RedoNode) Accept(visitor Visitor) {
	visitor.VisitRedoNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RedoNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RedoNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RedoNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "RedoNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents a regular expression literal with no interpolation.
//
//	/foo/i
//	^^^^^^
type RegularExpressionNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc Location   `json:"opening_loc"`
	ContentLoc Location   `json:"content_loc"`
	ClosingLoc Location   `json:"closing_loc"`
	Unescaped  RubyString `json:"unescaped"`
}

// NewRegularExpressionNode creates a new RegularExpressionNode.
func NewRegularExpressionNode(nodeID int, location Location, flags uint32, opening_loc Location, content_loc Location, closing_loc Location, unescaped RubyString) *RegularExpressionNode {
	return &RegularExpressionNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		ContentLoc: content_loc,
		ClosingLoc: closing_loc,
		Unescaped:  unescaped,
	}
}

// GetLocation returns the location of this node.
func (n *RegularExpressionNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RegularExpressionNode) GetNodeID() int {
	return n.NodeID
}

// IsIGNORE_CASE returns true if this node has the IGNORE_CASE flag.
func (n *RegularExpressionNode) IsIGNORE_CASE() bool {
	return (n.flags & RegularExpressionFlagsIGNORE_CASE) != 0
}

// IsEXTENDED returns true if this node has the EXTENDED flag.
func (n *RegularExpressionNode) IsEXTENDED() bool {
	return (n.flags & RegularExpressionFlagsEXTENDED) != 0
}

// IsMULTI_LINE returns true if this node has the MULTI_LINE flag.
func (n *RegularExpressionNode) IsMULTI_LINE() bool {
	return (n.flags & RegularExpressionFlagsMULTI_LINE) != 0
}

// IsONCE returns true if this node has the ONCE flag.
func (n *RegularExpressionNode) IsONCE() bool {
	return (n.flags & RegularExpressionFlagsONCE) != 0
}

// IsEUC_JP returns true if this node has the EUC_JP flag.
func (n *RegularExpressionNode) IsEUC_JP() bool {
	return (n.flags & RegularExpressionFlagsEUC_JP) != 0
}

// IsASCII_8BIT returns true if this node has the ASCII_8BIT flag.
func (n *RegularExpressionNode) IsASCII_8BIT() bool {
	return (n.flags & RegularExpressionFlagsASCII_8BIT) != 0
}

// IsWINDOWS_31J returns true if this node has the WINDOWS_31J flag.
func (n *RegularExpressionNode) IsWINDOWS_31J() bool {
	return (n.flags & RegularExpressionFlagsWINDOWS_31J) != 0
}

// IsUTF_8 returns true if this node has the UTF_8 flag.
func (n *RegularExpressionNode) IsUTF_8() bool {
	return (n.flags & RegularExpressionFlagsUTF_8) != 0
}

// IsFORCED_UTF8_ENCODING returns true if this node has the FORCED_UTF8_ENCODING flag.
func (n *RegularExpressionNode) IsFORCED_UTF8_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_UTF8_ENCODING) != 0
}

// IsFORCED_BINARY_ENCODING returns true if this node has the FORCED_BINARY_ENCODING flag.
func (n *RegularExpressionNode) IsFORCED_BINARY_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_BINARY_ENCODING) != 0
}

// IsFORCED_US_ASCII_ENCODING returns true if this node has the FORCED_US_ASCII_ENCODING flag.
func (n *RegularExpressionNode) IsFORCED_US_ASCII_ENCODING() bool {
	return (n.flags & RegularExpressionFlagsFORCED_US_ASCII_ENCODING) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *RegularExpressionNode) Accept(visitor Visitor) {
	visitor.VisitRegularExpressionNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RegularExpressionNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RegularExpressionNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RegularExpressionNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "RegularExpressionNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"content_loc": n.ContentLoc,
		"closing_loc": n.ClosingLoc,
		"unescaped":   n.Unescaped,
	}
}

// Represents a required keyword parameter to a method, block, or lambda definition.
//
//	def a(b: )
//	      ^^
//	end
type RequiredKeywordParameterNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string   `json:"name"`
	NameLoc  Location `json:"name_loc"`
}

// NewRequiredKeywordParameterNode creates a new RequiredKeywordParameterNode.
func NewRequiredKeywordParameterNode(nodeID int, location Location, flags uint32, name string, name_loc Location) *RequiredKeywordParameterNode {
	return &RequiredKeywordParameterNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
		NameLoc:  name_loc,
	}
}

// GetLocation returns the location of this node.
func (n *RequiredKeywordParameterNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RequiredKeywordParameterNode) GetNodeID() int {
	return n.NodeID
}

// IsREPEATED_PARAMETER returns true if this node has the REPEATED_PARAMETER flag.
func (n *RequiredKeywordParameterNode) IsREPEATED_PARAMETER() bool {
	return (n.flags & ParameterFlagsREPEATED_PARAMETER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *RequiredKeywordParameterNode) Accept(visitor Visitor) {
	visitor.VisitRequiredKeywordParameterNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RequiredKeywordParameterNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RequiredKeywordParameterNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RequiredKeywordParameterNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "RequiredKeywordParameterNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
		"name_loc": n.NameLoc,
	}
}

// Represents a required parameter to a method, block, or lambda definition.
//
//	def a(b)
//	      ^
//	end
type RequiredParameterNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Name     string `json:"name"`
}

// NewRequiredParameterNode creates a new RequiredParameterNode.
func NewRequiredParameterNode(nodeID int, location Location, flags uint32, name string) *RequiredParameterNode {
	return &RequiredParameterNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Name:     name,
	}
}

// GetLocation returns the location of this node.
func (n *RequiredParameterNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RequiredParameterNode) GetNodeID() int {
	return n.NodeID
}

// IsREPEATED_PARAMETER returns true if this node has the REPEATED_PARAMETER flag.
func (n *RequiredParameterNode) IsREPEATED_PARAMETER() bool {
	return (n.flags & ParameterFlagsREPEATED_PARAMETER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *RequiredParameterNode) Accept(visitor Visitor) {
	visitor.VisitRequiredParameterNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RequiredParameterNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RequiredParameterNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RequiredParameterNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "RequiredParameterNode",
		"location": n.Location,
		"flags":    n.flags,
		"name":     n.Name,
	}
}

// Represents an expression modified with a rescue.
//
//	foo rescue nil
//	^^^^^^^^^^^^^^
type RescueModifierNode struct {
	NodeID           int      `json:"nodeID"`
	Location         Location `json:"location"`
	flags            uint32
	Expression       Node     `json:"expression"`
	KeywordLoc       Location `json:"keyword_loc"`
	RescueExpression Node     `json:"rescue_expression"`
}

// NewRescueModifierNode creates a new RescueModifierNode.
func NewRescueModifierNode(nodeID int, location Location, flags uint32, expression Node, keyword_loc Location, rescue_expression Node) *RescueModifierNode {
	return &RescueModifierNode{
		NodeID:           nodeID,
		Location:         location,
		flags:            flags,
		Expression:       expression,
		KeywordLoc:       keyword_loc,
		RescueExpression: rescue_expression,
	}
}

// GetLocation returns the location of this node.
func (n *RescueModifierNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RescueModifierNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *RescueModifierNode) Accept(visitor Visitor) {
	visitor.VisitRescueModifierNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RescueModifierNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Expression)
	nodes = append(nodes, n.RescueExpression)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RescueModifierNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Expression)
	nodes = append(nodes, n.RescueExpression)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RescueModifierNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":              "RescueModifierNode",
		"location":          n.Location,
		"flags":             n.flags,
		"expression":        n.Expression,
		"keyword_loc":       n.KeywordLoc,
		"rescue_expression": n.RescueExpression,
	}
}

// Represents a rescue statement.
//
//	begin
//	rescue Foo, *splat, Bar => ex
//	  foo
//	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//	end
//
// `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `reference` field.
type RescueNode struct {
	NodeID         int      `json:"nodeID"`
	Location       Location `json:"location"`
	flags          uint32
	KeywordLoc     Location        `json:"keyword_loc"`
	Exceptions     []Node          `json:"exceptions"`
	OperatorLoc    *Location       `json:"operator_loc"`
	Reference      Node            `json:"reference"`
	ThenKeywordLoc *Location       `json:"then_keyword_loc"`
	Statements     *StatementsNode `json:"statements"`
	Subsequent     *RescueNode     `json:"subsequent"`
}

// NewRescueNode creates a new RescueNode.
func NewRescueNode(nodeID int, location Location, flags uint32, keyword_loc Location, exceptions []Node, operator_loc *Location, reference Node, then_keyword_loc *Location, statements *StatementsNode, subsequent *RescueNode) *RescueNode {
	return &RescueNode{
		NodeID:         nodeID,
		Location:       location,
		flags:          flags,
		KeywordLoc:     keyword_loc,
		Exceptions:     exceptions,
		OperatorLoc:    operator_loc,
		Reference:      reference,
		ThenKeywordLoc: then_keyword_loc,
		Statements:     statements,
		Subsequent:     subsequent,
	}
}

// GetLocation returns the location of this node.
func (n *RescueNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RescueNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *RescueNode) Accept(visitor Visitor) {
	visitor.VisitRescueNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RescueNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Exceptions...)
	if n.Reference != nil {
		nodes = append(nodes, n.Reference)
	}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	if n.Subsequent != nil {
		nodes = append(nodes, n.Subsequent)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RescueNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Exceptions...)
	if n.Reference != nil {
		nodes = append(nodes, n.Reference)
	}
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	if n.Subsequent != nil {
		nodes = append(nodes, n.Subsequent)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RescueNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":             "RescueNode",
		"location":         n.Location,
		"flags":            n.flags,
		"keyword_loc":      n.KeywordLoc,
		"exceptions":       n.Exceptions,
		"operator_loc":     n.OperatorLoc,
		"reference":        n.Reference,
		"then_keyword_loc": n.ThenKeywordLoc,
		"statements":       n.Statements,
		"subsequent":       n.Subsequent,
	}
}

// Represents a rest parameter to a method, block, or lambda definition.
//
//	def a(*b)
//	      ^^
//	end
type RestParameterNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	Name        *string   `json:"name"`
	NameLoc     *Location `json:"name_loc"`
	OperatorLoc Location  `json:"operator_loc"`
}

// NewRestParameterNode creates a new RestParameterNode.
func NewRestParameterNode(nodeID int, location Location, flags uint32, name *string, name_loc *Location, operator_loc Location) *RestParameterNode {
	return &RestParameterNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		Name:        name,
		NameLoc:     name_loc,
		OperatorLoc: operator_loc,
	}
}

// GetLocation returns the location of this node.
func (n *RestParameterNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RestParameterNode) GetNodeID() int {
	return n.NodeID
}

// IsREPEATED_PARAMETER returns true if this node has the REPEATED_PARAMETER flag.
func (n *RestParameterNode) IsREPEATED_PARAMETER() bool {
	return (n.flags & ParameterFlagsREPEATED_PARAMETER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *RestParameterNode) Accept(visitor Visitor) {
	visitor.VisitRestParameterNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RestParameterNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RestParameterNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RestParameterNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "RestParameterNode",
		"location":     n.Location,
		"flags":        n.flags,
		"name":         n.Name,
		"name_loc":     n.NameLoc,
		"operator_loc": n.OperatorLoc,
	}
}

// Represents the use of the `retry` keyword.
//
//	retry
//	^^^^^
type RetryNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewRetryNode creates a new RetryNode.
func NewRetryNode(nodeID int, location Location, flags uint32) *RetryNode {
	return &RetryNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *RetryNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *RetryNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *RetryNode) Accept(visitor Visitor) {
	visitor.VisitRetryNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *RetryNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *RetryNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *RetryNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "RetryNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents the use of the `return` keyword.
//
//	return 1
//	^^^^^^^^
type ReturnNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	KeywordLoc Location       `json:"keyword_loc"`
	Arguments  *ArgumentsNode `json:"arguments"`
}

// NewReturnNode creates a new ReturnNode.
func NewReturnNode(nodeID int, location Location, flags uint32, keyword_loc Location, arguments *ArgumentsNode) *ReturnNode {
	return &ReturnNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		KeywordLoc: keyword_loc,
		Arguments:  arguments,
	}
}

// GetLocation returns the location of this node.
func (n *ReturnNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ReturnNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *ReturnNode) Accept(visitor Visitor) {
	visitor.VisitReturnNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ReturnNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ReturnNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ReturnNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "ReturnNode",
		"location":    n.Location,
		"flags":       n.flags,
		"keyword_loc": n.KeywordLoc,
		"arguments":   n.Arguments,
	}
}

// Represents the `self` keyword.
//
//	self
//	^^^^
type SelfNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewSelfNode creates a new SelfNode.
func NewSelfNode(nodeID int, location Location, flags uint32) *SelfNode {
	return &SelfNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *SelfNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *SelfNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *SelfNode) Accept(visitor Visitor) {
	visitor.VisitSelfNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *SelfNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *SelfNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *SelfNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "SelfNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.
//
//	# shareable_constant_value: literal
//	C = { a: 1 }
//	^^^^^^^^^^^^
type ShareableConstantNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Write    Node `json:"write"`
}

// NewShareableConstantNode creates a new ShareableConstantNode.
func NewShareableConstantNode(nodeID int, location Location, flags uint32, write Node) *ShareableConstantNode {
	return &ShareableConstantNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Write:    write,
	}
}

// GetLocation returns the location of this node.
func (n *ShareableConstantNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *ShareableConstantNode) GetNodeID() int {
	return n.NodeID
}

// IsLITERAL returns true if this node has the LITERAL flag.
func (n *ShareableConstantNode) IsLITERAL() bool {
	return (n.flags & ShareableConstantNodeFlagsLITERAL) != 0
}

// IsEXPERIMENTAL_EVERYTHING returns true if this node has the EXPERIMENTAL_EVERYTHING flag.
func (n *ShareableConstantNode) IsEXPERIMENTAL_EVERYTHING() bool {
	return (n.flags & ShareableConstantNodeFlagsEXPERIMENTAL_EVERYTHING) != 0
}

// IsEXPERIMENTAL_COPY returns true if this node has the EXPERIMENTAL_COPY flag.
func (n *ShareableConstantNode) IsEXPERIMENTAL_COPY() bool {
	return (n.flags & ShareableConstantNodeFlagsEXPERIMENTAL_COPY) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *ShareableConstantNode) Accept(visitor Visitor) {
	visitor.VisitShareableConstantNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *ShareableConstantNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Write)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *ShareableConstantNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Write)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *ShareableConstantNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "ShareableConstantNode",
		"location": n.Location,
		"flags":    n.flags,
		"write":    n.Write,
	}
}

// Represents a singleton class declaration involving the `class` keyword.
//
//	class << self end
//	^^^^^^^^^^^^^^^^^
type SingletonClassNode struct {
	NodeID          int      `json:"nodeID"`
	Location        Location `json:"location"`
	flags           uint32
	Locals          []string `json:"locals"`
	ClassKeywordLoc Location `json:"class_keyword_loc"`
	OperatorLoc     Location `json:"operator_loc"`
	Expression      Node     `json:"expression"`
	Body            Node     `json:"body"`
	EndKeywordLoc   Location `json:"end_keyword_loc"`
}

// NewSingletonClassNode creates a new SingletonClassNode.
func NewSingletonClassNode(nodeID int, location Location, flags uint32, locals []string, class_keyword_loc Location, operator_loc Location, expression Node, body Node, end_keyword_loc Location) *SingletonClassNode {
	return &SingletonClassNode{
		NodeID:          nodeID,
		Location:        location,
		flags:           flags,
		Locals:          locals,
		ClassKeywordLoc: class_keyword_loc,
		OperatorLoc:     operator_loc,
		Expression:      expression,
		Body:            body,
		EndKeywordLoc:   end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *SingletonClassNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *SingletonClassNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *SingletonClassNode) Accept(visitor Visitor) {
	visitor.VisitSingletonClassNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *SingletonClassNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Expression)
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *SingletonClassNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Expression)
	if n.Body != nil {
		nodes = append(nodes, n.Body)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *SingletonClassNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":              "SingletonClassNode",
		"location":          n.Location,
		"flags":             n.flags,
		"locals":            n.Locals,
		"class_keyword_loc": n.ClassKeywordLoc,
		"operator_loc":      n.OperatorLoc,
		"expression":        n.Expression,
		"body":              n.Body,
		"end_keyword_loc":   n.EndKeywordLoc,
	}
}

// Represents the use of the `__ENCODING__` keyword.
//
//	__ENCODING__
//	^^^^^^^^^^^^
type SourceEncodingNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewSourceEncodingNode creates a new SourceEncodingNode.
func NewSourceEncodingNode(nodeID int, location Location, flags uint32) *SourceEncodingNode {
	return &SourceEncodingNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *SourceEncodingNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *SourceEncodingNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *SourceEncodingNode) Accept(visitor Visitor) {
	visitor.VisitSourceEncodingNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *SourceEncodingNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *SourceEncodingNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *SourceEncodingNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "SourceEncodingNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents the use of the `__FILE__` keyword.
//
//	__FILE__
//	^^^^^^^^
type SourceFileNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Filepath RubyString `json:"filepath"`
}

// NewSourceFileNode creates a new SourceFileNode.
func NewSourceFileNode(nodeID int, location Location, flags uint32, filepath RubyString) *SourceFileNode {
	return &SourceFileNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Filepath: filepath,
	}
}

// GetLocation returns the location of this node.
func (n *SourceFileNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *SourceFileNode) GetNodeID() int {
	return n.NodeID
}

// IsFORCED_UTF8_ENCODING returns true if this node has the FORCED_UTF8_ENCODING flag.
func (n *SourceFileNode) IsFORCED_UTF8_ENCODING() bool {
	return (n.flags & StringFlagsFORCED_UTF8_ENCODING) != 0
}

// IsFORCED_BINARY_ENCODING returns true if this node has the FORCED_BINARY_ENCODING flag.
func (n *SourceFileNode) IsFORCED_BINARY_ENCODING() bool {
	return (n.flags & StringFlagsFORCED_BINARY_ENCODING) != 0
}

// IsFROZEN returns true if this node has the FROZEN flag.
func (n *SourceFileNode) IsFROZEN() bool {
	return (n.flags & StringFlagsFROZEN) != 0
}

// IsMUTABLE returns true if this node has the MUTABLE flag.
func (n *SourceFileNode) IsMUTABLE() bool {
	return (n.flags & StringFlagsMUTABLE) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *SourceFileNode) Accept(visitor Visitor) {
	visitor.VisitSourceFileNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *SourceFileNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *SourceFileNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *SourceFileNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "SourceFileNode",
		"location": n.Location,
		"flags":    n.flags,
		"filepath": n.Filepath,
	}
}

// Represents the use of the `__LINE__` keyword.
//
//	__LINE__
//	^^^^^^^^
type SourceLineNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewSourceLineNode creates a new SourceLineNode.
func NewSourceLineNode(nodeID int, location Location, flags uint32) *SourceLineNode {
	return &SourceLineNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *SourceLineNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *SourceLineNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *SourceLineNode) Accept(visitor Visitor) {
	visitor.VisitSourceLineNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *SourceLineNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *SourceLineNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *SourceLineNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "SourceLineNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents the use of the splat operator.
//
//	[*a]
//	 ^^
type SplatNode struct {
	NodeID      int      `json:"nodeID"`
	Location    Location `json:"location"`
	flags       uint32
	OperatorLoc Location `json:"operator_loc"`
	Expression  Node     `json:"expression"`
}

// NewSplatNode creates a new SplatNode.
func NewSplatNode(nodeID int, location Location, flags uint32, operator_loc Location, expression Node) *SplatNode {
	return &SplatNode{
		NodeID:      nodeID,
		Location:    location,
		flags:       flags,
		OperatorLoc: operator_loc,
		Expression:  expression,
	}
}

// GetLocation returns the location of this node.
func (n *SplatNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *SplatNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *SplatNode) Accept(visitor Visitor) {
	visitor.VisitSplatNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *SplatNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Expression != nil {
		nodes = append(nodes, n.Expression)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *SplatNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Expression != nil {
		nodes = append(nodes, n.Expression)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *SplatNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":         "SplatNode",
		"location":     n.Location,
		"flags":        n.flags,
		"operator_loc": n.OperatorLoc,
		"expression":   n.Expression,
	}
}

// Represents a set of statements contained within some scope.
//
//	foo; bar; baz
//	^^^^^^^^^^^^^
type StatementsNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
	Body     []Node `json:"body"`
}

// NewStatementsNode creates a new StatementsNode.
func NewStatementsNode(nodeID int, location Location, flags uint32, body []Node) *StatementsNode {
	return &StatementsNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
		Body:     body,
	}
}

// GetLocation returns the location of this node.
func (n *StatementsNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *StatementsNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *StatementsNode) Accept(visitor Visitor) {
	visitor.VisitStatementsNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *StatementsNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Body...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *StatementsNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Body...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *StatementsNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "StatementsNode",
		"location": n.Location,
		"flags":    n.flags,
		"body":     n.Body,
	}
}

// Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
//
//	"foo"
//	^^^^^
//
//	%w[foo]
//	   ^^^
//
//	"foo #{bar} baz"
//	 ^^^^      ^^^^
type StringNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc *Location  `json:"opening_loc"`
	ContentLoc Location   `json:"content_loc"`
	ClosingLoc *Location  `json:"closing_loc"`
	Unescaped  RubyString `json:"unescaped"`
}

// NewStringNode creates a new StringNode.
func NewStringNode(nodeID int, location Location, flags uint32, opening_loc *Location, content_loc Location, closing_loc *Location, unescaped RubyString) *StringNode {
	return &StringNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		ContentLoc: content_loc,
		ClosingLoc: closing_loc,
		Unescaped:  unescaped,
	}
}

// GetLocation returns the location of this node.
func (n *StringNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *StringNode) GetNodeID() int {
	return n.NodeID
}

// IsFORCED_UTF8_ENCODING returns true if this node has the FORCED_UTF8_ENCODING flag.
func (n *StringNode) IsFORCED_UTF8_ENCODING() bool {
	return (n.flags & StringFlagsFORCED_UTF8_ENCODING) != 0
}

// IsFORCED_BINARY_ENCODING returns true if this node has the FORCED_BINARY_ENCODING flag.
func (n *StringNode) IsFORCED_BINARY_ENCODING() bool {
	return (n.flags & StringFlagsFORCED_BINARY_ENCODING) != 0
}

// IsFROZEN returns true if this node has the FROZEN flag.
func (n *StringNode) IsFROZEN() bool {
	return (n.flags & StringFlagsFROZEN) != 0
}

// IsMUTABLE returns true if this node has the MUTABLE flag.
func (n *StringNode) IsMUTABLE() bool {
	return (n.flags & StringFlagsMUTABLE) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *StringNode) Accept(visitor Visitor) {
	visitor.VisitStringNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *StringNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *StringNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *StringNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "StringNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"content_loc": n.ContentLoc,
		"closing_loc": n.ClosingLoc,
		"unescaped":   n.Unescaped,
	}
}

// Represents the use of the `super` keyword with parentheses or arguments.
//
//	super()
//	^^^^^^^
//
//	super foo, bar
//	^^^^^^^^^^^^^^
type SuperNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	KeywordLoc Location       `json:"keyword_loc"`
	LparenLoc  *Location      `json:"lparen_loc"`
	Arguments  *ArgumentsNode `json:"arguments"`
	RparenLoc  *Location      `json:"rparen_loc"`
	Block      Node           `json:"block"`
}

// NewSuperNode creates a new SuperNode.
func NewSuperNode(nodeID int, location Location, flags uint32, keyword_loc Location, lparen_loc *Location, arguments *ArgumentsNode, rparen_loc *Location, block Node) *SuperNode {
	return &SuperNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		KeywordLoc: keyword_loc,
		LparenLoc:  lparen_loc,
		Arguments:  arguments,
		RparenLoc:  rparen_loc,
		Block:      block,
	}
}

// GetLocation returns the location of this node.
func (n *SuperNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *SuperNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *SuperNode) Accept(visitor Visitor) {
	visitor.VisitSuperNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *SuperNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *SuperNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	if n.Block != nil {
		nodes = append(nodes, n.Block)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *SuperNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "SuperNode",
		"location":    n.Location,
		"flags":       n.flags,
		"keyword_loc": n.KeywordLoc,
		"lparen_loc":  n.LparenLoc,
		"arguments":   n.Arguments,
		"rparen_loc":  n.RparenLoc,
		"block":       n.Block,
	}
}

// Represents a symbol literal or a symbol contained within a `%i` list.
//
//	:foo
//	^^^^
//
//	%i[foo]
//	   ^^^
type SymbolNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc *Location  `json:"opening_loc"`
	ValueLoc   *Location  `json:"value_loc"`
	ClosingLoc *Location  `json:"closing_loc"`
	Unescaped  RubyString `json:"unescaped"`
}

// NewSymbolNode creates a new SymbolNode.
func NewSymbolNode(nodeID int, location Location, flags uint32, opening_loc *Location, value_loc *Location, closing_loc *Location, unescaped RubyString) *SymbolNode {
	return &SymbolNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		ValueLoc:   value_loc,
		ClosingLoc: closing_loc,
		Unescaped:  unescaped,
	}
}

// GetLocation returns the location of this node.
func (n *SymbolNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *SymbolNode) GetNodeID() int {
	return n.NodeID
}

// IsFORCED_UTF8_ENCODING returns true if this node has the FORCED_UTF8_ENCODING flag.
func (n *SymbolNode) IsFORCED_UTF8_ENCODING() bool {
	return (n.flags & SymbolFlagsFORCED_UTF8_ENCODING) != 0
}

// IsFORCED_BINARY_ENCODING returns true if this node has the FORCED_BINARY_ENCODING flag.
func (n *SymbolNode) IsFORCED_BINARY_ENCODING() bool {
	return (n.flags & SymbolFlagsFORCED_BINARY_ENCODING) != 0
}

// IsFORCED_US_ASCII_ENCODING returns true if this node has the FORCED_US_ASCII_ENCODING flag.
func (n *SymbolNode) IsFORCED_US_ASCII_ENCODING() bool {
	return (n.flags & SymbolFlagsFORCED_US_ASCII_ENCODING) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *SymbolNode) Accept(visitor Visitor) {
	visitor.VisitSymbolNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *SymbolNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *SymbolNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *SymbolNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "SymbolNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"value_loc":   n.ValueLoc,
		"closing_loc": n.ClosingLoc,
		"unescaped":   n.Unescaped,
	}
}

// Represents the use of the literal `true` keyword.
//
//	true
//	^^^^
type TrueNode struct {
	NodeID   int      `json:"nodeID"`
	Location Location `json:"location"`
	flags    uint32
}

// NewTrueNode creates a new TrueNode.
func NewTrueNode(nodeID int, location Location, flags uint32) *TrueNode {
	return &TrueNode{
		NodeID:   nodeID,
		Location: location,
		flags:    flags,
	}
}

// GetLocation returns the location of this node.
func (n *TrueNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *TrueNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *TrueNode) Accept(visitor Visitor) {
	visitor.VisitTrueNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *TrueNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *TrueNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *TrueNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":     "TrueNode",
		"location": n.Location,
		"flags":    n.flags,
	}
}

// Represents the use of the `undef` keyword.
//
//	undef :foo, :bar, :baz
//	^^^^^^^^^^^^^^^^^^^^^^
type UndefNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	Names      []Node   `json:"names"`
	KeywordLoc Location `json:"keyword_loc"`
}

// NewUndefNode creates a new UndefNode.
func NewUndefNode(nodeID int, location Location, flags uint32, names []Node, keyword_loc Location) *UndefNode {
	return &UndefNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		Names:      names,
		KeywordLoc: keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *UndefNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *UndefNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *UndefNode) Accept(visitor Visitor) {
	visitor.VisitUndefNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *UndefNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Names...)
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *UndefNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Names...)
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *UndefNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "UndefNode",
		"location":    n.Location,
		"flags":       n.flags,
		"names":       n.Names,
		"keyword_loc": n.KeywordLoc,
	}
}

// Represents the use of the `unless` keyword, either in the block form or the modifier form.
//
//	bar unless foo
//	^^^^^^^^^^^^^^
//
//	unless foo then bar end
//	^^^^^^^^^^^^^^^^^^^^^^^
type UnlessNode struct {
	NodeID         int      `json:"nodeID"`
	Location       Location `json:"location"`
	flags          uint32
	KeywordLoc     Location        `json:"keyword_loc"`
	Predicate      Node            `json:"predicate"`
	ThenKeywordLoc *Location       `json:"then_keyword_loc"`
	Statements     *StatementsNode `json:"statements"`
	ElseClause     *ElseNode       `json:"else_clause"`
	EndKeywordLoc  *Location       `json:"end_keyword_loc"`
}

// NewUnlessNode creates a new UnlessNode.
func NewUnlessNode(nodeID int, location Location, flags uint32, keyword_loc Location, predicate Node, then_keyword_loc *Location, statements *StatementsNode, else_clause *ElseNode, end_keyword_loc *Location) *UnlessNode {
	return &UnlessNode{
		NodeID:         nodeID,
		Location:       location,
		flags:          flags,
		KeywordLoc:     keyword_loc,
		Predicate:      predicate,
		ThenKeywordLoc: then_keyword_loc,
		Statements:     statements,
		ElseClause:     else_clause,
		EndKeywordLoc:  end_keyword_loc,
	}
}

// GetLocation returns the location of this node.
func (n *UnlessNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *UnlessNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *UnlessNode) Accept(visitor Visitor) {
	visitor.VisitUnlessNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *UnlessNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Predicate)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	if n.ElseClause != nil {
		nodes = append(nodes, n.ElseClause)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *UnlessNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Predicate)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	if n.ElseClause != nil {
		nodes = append(nodes, n.ElseClause)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *UnlessNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":             "UnlessNode",
		"location":         n.Location,
		"flags":            n.flags,
		"keyword_loc":      n.KeywordLoc,
		"predicate":        n.Predicate,
		"then_keyword_loc": n.ThenKeywordLoc,
		"statements":       n.Statements,
		"else_clause":      n.ElseClause,
		"end_keyword_loc":  n.EndKeywordLoc,
	}
}

// Represents the use of the `until` keyword, either in the block form or the modifier form.
//
//	bar until foo
//	^^^^^^^^^^^^^
//
//	until foo do bar end
//	^^^^^^^^^^^^^^^^^^^^
type UntilNode struct {
	NodeID       int      `json:"nodeID"`
	Location     Location `json:"location"`
	flags        uint32
	KeywordLoc   Location        `json:"keyword_loc"`
	DoKeywordLoc *Location       `json:"do_keyword_loc"`
	ClosingLoc   *Location       `json:"closing_loc"`
	Predicate    Node            `json:"predicate"`
	Statements   *StatementsNode `json:"statements"`
}

// NewUntilNode creates a new UntilNode.
func NewUntilNode(nodeID int, location Location, flags uint32, keyword_loc Location, do_keyword_loc *Location, closing_loc *Location, predicate Node, statements *StatementsNode) *UntilNode {
	return &UntilNode{
		NodeID:       nodeID,
		Location:     location,
		flags:        flags,
		KeywordLoc:   keyword_loc,
		DoKeywordLoc: do_keyword_loc,
		ClosingLoc:   closing_loc,
		Predicate:    predicate,
		Statements:   statements,
	}
}

// GetLocation returns the location of this node.
func (n *UntilNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *UntilNode) GetNodeID() int {
	return n.NodeID
}

// IsBEGIN_MODIFIER returns true if this node has the BEGIN_MODIFIER flag.
func (n *UntilNode) IsBEGIN_MODIFIER() bool {
	return (n.flags & LoopFlagsBEGIN_MODIFIER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *UntilNode) Accept(visitor Visitor) {
	visitor.VisitUntilNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *UntilNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Predicate)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *UntilNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Predicate)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *UntilNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":           "UntilNode",
		"location":       n.Location,
		"flags":          n.flags,
		"keyword_loc":    n.KeywordLoc,
		"do_keyword_loc": n.DoKeywordLoc,
		"closing_loc":    n.ClosingLoc,
		"predicate":      n.Predicate,
		"statements":     n.Statements,
	}
}

// Represents the use of the `when` keyword within a case statement.
//
//	case true
//	when true
//	^^^^^^^^^
//	end
type WhenNode struct {
	NodeID         int      `json:"nodeID"`
	Location       Location `json:"location"`
	flags          uint32
	KeywordLoc     Location        `json:"keyword_loc"`
	Conditions     []Node          `json:"conditions"`
	ThenKeywordLoc *Location       `json:"then_keyword_loc"`
	Statements     *StatementsNode `json:"statements"`
}

// NewWhenNode creates a new WhenNode.
func NewWhenNode(nodeID int, location Location, flags uint32, keyword_loc Location, conditions []Node, then_keyword_loc *Location, statements *StatementsNode) *WhenNode {
	return &WhenNode{
		NodeID:         nodeID,
		Location:       location,
		flags:          flags,
		KeywordLoc:     keyword_loc,
		Conditions:     conditions,
		ThenKeywordLoc: then_keyword_loc,
		Statements:     statements,
	}
}

// GetLocation returns the location of this node.
func (n *WhenNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *WhenNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *WhenNode) Accept(visitor Visitor) {
	visitor.VisitWhenNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *WhenNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Conditions...)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *WhenNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Conditions...)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *WhenNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":             "WhenNode",
		"location":         n.Location,
		"flags":            n.flags,
		"keyword_loc":      n.KeywordLoc,
		"conditions":       n.Conditions,
		"then_keyword_loc": n.ThenKeywordLoc,
		"statements":       n.Statements,
	}
}

// Represents the use of the `while` keyword, either in the block form or the modifier form.
//
//	bar while foo
//	^^^^^^^^^^^^^
//
//	while foo do bar end
//	^^^^^^^^^^^^^^^^^^^^
type WhileNode struct {
	NodeID       int      `json:"nodeID"`
	Location     Location `json:"location"`
	flags        uint32
	KeywordLoc   Location        `json:"keyword_loc"`
	DoKeywordLoc *Location       `json:"do_keyword_loc"`
	ClosingLoc   *Location       `json:"closing_loc"`
	Predicate    Node            `json:"predicate"`
	Statements   *StatementsNode `json:"statements"`
}

// NewWhileNode creates a new WhileNode.
func NewWhileNode(nodeID int, location Location, flags uint32, keyword_loc Location, do_keyword_loc *Location, closing_loc *Location, predicate Node, statements *StatementsNode) *WhileNode {
	return &WhileNode{
		NodeID:       nodeID,
		Location:     location,
		flags:        flags,
		KeywordLoc:   keyword_loc,
		DoKeywordLoc: do_keyword_loc,
		ClosingLoc:   closing_loc,
		Predicate:    predicate,
		Statements:   statements,
	}
}

// GetLocation returns the location of this node.
func (n *WhileNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *WhileNode) GetNodeID() int {
	return n.NodeID
}

// IsBEGIN_MODIFIER returns true if this node has the BEGIN_MODIFIER flag.
func (n *WhileNode) IsBEGIN_MODIFIER() bool {
	return (n.flags & LoopFlagsBEGIN_MODIFIER) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *WhileNode) Accept(visitor Visitor) {
	visitor.VisitWhileNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *WhileNode) ChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Predicate)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *WhileNode) CompactChildNodes() []Node {
	nodes := []Node{}
	nodes = append(nodes, n.Predicate)
	if n.Statements != nil {
		nodes = append(nodes, n.Statements)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *WhileNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":           "WhileNode",
		"location":       n.Location,
		"flags":          n.flags,
		"keyword_loc":    n.KeywordLoc,
		"do_keyword_loc": n.DoKeywordLoc,
		"closing_loc":    n.ClosingLoc,
		"predicate":      n.Predicate,
		"statements":     n.Statements,
	}
}

// Represents an xstring literal with no interpolation.
//
//	`foo`
//	^^^^^
type XStringNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	OpeningLoc Location   `json:"opening_loc"`
	ContentLoc Location   `json:"content_loc"`
	ClosingLoc Location   `json:"closing_loc"`
	Unescaped  RubyString `json:"unescaped"`
}

// NewXStringNode creates a new XStringNode.
func NewXStringNode(nodeID int, location Location, flags uint32, opening_loc Location, content_loc Location, closing_loc Location, unescaped RubyString) *XStringNode {
	return &XStringNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		OpeningLoc: opening_loc,
		ContentLoc: content_loc,
		ClosingLoc: closing_loc,
		Unescaped:  unescaped,
	}
}

// GetLocation returns the location of this node.
func (n *XStringNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *XStringNode) GetNodeID() int {
	return n.NodeID
}

// IsFORCED_UTF8_ENCODING returns true if this node has the FORCED_UTF8_ENCODING flag.
func (n *XStringNode) IsFORCED_UTF8_ENCODING() bool {
	return (n.flags & EncodingFlagsFORCED_UTF8_ENCODING) != 0
}

// IsFORCED_BINARY_ENCODING returns true if this node has the FORCED_BINARY_ENCODING flag.
func (n *XStringNode) IsFORCED_BINARY_ENCODING() bool {
	return (n.flags & EncodingFlagsFORCED_BINARY_ENCODING) != 0
}

// Accept calls the appropriate visit method on the visitor.
func (n *XStringNode) Accept(visitor Visitor) {
	visitor.VisitXStringNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *XStringNode) ChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *XStringNode) CompactChildNodes() []Node {
	nodes := []Node{}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *XStringNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "XStringNode",
		"location":    n.Location,
		"flags":       n.flags,
		"opening_loc": n.OpeningLoc,
		"content_loc": n.ContentLoc,
		"closing_loc": n.ClosingLoc,
		"unescaped":   n.Unescaped,
	}
}

// Represents the use of the `yield` keyword.
//
//	yield 1
//	^^^^^^^
type YieldNode struct {
	NodeID     int      `json:"nodeID"`
	Location   Location `json:"location"`
	flags      uint32
	KeywordLoc Location       `json:"keyword_loc"`
	LparenLoc  *Location      `json:"lparen_loc"`
	Arguments  *ArgumentsNode `json:"arguments"`
	RparenLoc  *Location      `json:"rparen_loc"`
}

// NewYieldNode creates a new YieldNode.
func NewYieldNode(nodeID int, location Location, flags uint32, keyword_loc Location, lparen_loc *Location, arguments *ArgumentsNode, rparen_loc *Location) *YieldNode {
	return &YieldNode{
		NodeID:     nodeID,
		Location:   location,
		flags:      flags,
		KeywordLoc: keyword_loc,
		LparenLoc:  lparen_loc,
		Arguments:  arguments,
		RparenLoc:  rparen_loc,
	}
}

// GetLocation returns the location of this node.
func (n *YieldNode) GetLocation() Location {
	return n.Location
}

// GetNodeID returns the node ID of this node.
func (n *YieldNode) GetNodeID() int {
	return n.NodeID
}

// Accept calls the appropriate visit method on the visitor.
func (n *YieldNode) Accept(visitor Visitor) {
	visitor.VisitYieldNode(n)
}

// ChildNodes returns all child nodes of the current node.
func (n *YieldNode) ChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	return nodes
}

// CompactChildNodes returns all non-nil child nodes.
func (n *YieldNode) CompactChildNodes() []Node {
	nodes := []Node{}
	if n.Arguments != nil {
		nodes = append(nodes, n.Arguments)
	}
	return nodes
}

// ToJSON converts the node to a JSON-serializable map.
func (n *YieldNode) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"type":        "YieldNode",
		"location":    n.Location,
		"flags":       n.flags,
		"keyword_loc": n.KeywordLoc,
		"lparen_loc":  n.LparenLoc,
		"arguments":   n.Arguments,
		"rparen_loc":  n.RparenLoc,
	}
}
