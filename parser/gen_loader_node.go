/******************************************************************************/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/gen_loader_node.go.erb                                           */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/

package parser

import (
	"fmt"

	"github.com/rotisserie/eris"
)

func loadNode(buff *buffer, src []byte, pool *constantPool) (Node, error) {
	nodeType, err := buff.readByte()
	if err != nil {
		return nil, eris.Wrap(err, "error reading node type")
	}

	nodeLoc, err := loadLocation(buff)
	if err != nil {
		return nil, eris.Wrap(err, "error reading node location")
	}

	switch nodeType {
	case 1:
		newName_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param newName")
		}

		newName := newName_

		oldName_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param oldName")
		}

		oldName := oldName_

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		return NewAliasGlobalVariableNode(newName, oldName, keywordLoc, nodeLoc), nil
	case 2:
		newName_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param newName")
		}

		newName := newName_

		oldName_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param oldName")
		}

		oldName := oldName_

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		return NewAliasMethodNode(newName, oldName, keywordLoc, nodeLoc), nil
	case 3:
		left_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param left")
		}

		left := left_

		right_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param right")
		}

		right := right_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewAlternationPatternNode(left, right, operatorLoc, nodeLoc), nil
	case 4:
		left_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param left")
		}

		left := left_

		right_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param right")
		}

		right := right_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewAndNode(left, right, operatorLoc, nodeLoc), nil
	case 5:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ArgumentsNodeFlags(flags_)

		argumentsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param argumentsCount")
		}

		arguments := make([]Node, argumentsCount)
		for i := range argumentsCount {
			arguments[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param arguments")
			}
		}

		return NewArgumentsNode(flags, arguments, nodeLoc), nil
	case 6:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ArrayNodeFlags(flags_)

		elementsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param elementsCount")
		}

		elements := make([]Node, elementsCount)
		for i := range elementsCount {
			elements[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param elements")
			}
		}

		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewArrayNode(flags, elements, openingLoc, closingLoc, nodeLoc), nil
	case 7:
		constant_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param constant")
		}

		constant := constant_

		requiredsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param requiredsCount")
		}

		requireds := make([]Node, requiredsCount)
		for i := range requiredsCount {
			requireds[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param requireds")
			}
		}

		rest_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rest")
		}

		rest := rest_

		postsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param postsCount")
		}

		posts := make([]Node, postsCount)
		for i := range postsCount {
			posts[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param posts")
			}
		}

		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewArrayPatternNode(constant, requireds, rest, posts, openingLoc, closingLoc, nodeLoc), nil
	case 8:
		key_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param key")
		}

		key := key_

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewAssocNode(key, value, operatorLoc, nodeLoc), nil
	case 9:
		value_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewAssocSplatNode(value, operatorLoc, nodeLoc), nil
	case 10:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewBackReferenceReadNode(name, nodeLoc), nil
	case 11:
		beginKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param beginKeywordLoc")
		}

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		rescueClause_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rescueClause")
		}

		rescueClause, ok := rescueClause_.(*RescueNode)
		if !ok && rescueClause_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param rescueClause: expected RescueNode, got %T", rescueClause_))
		}

		elseClause_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param elseClause")
		}

		elseClause, ok := elseClause_.(*ElseNode)
		if !ok && elseClause_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param elseClause: expected ElseNode, got %T", elseClause_))
		}

		ensureClause_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param ensureClause")
		}

		ensureClause, ok := ensureClause_.(*EnsureNode)
		if !ok && ensureClause_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param ensureClause: expected EnsureNode, got %T", ensureClause_))
		}

		endKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewBeginNode(beginKeywordLoc, statements, rescueClause, elseClause, ensureClause, endKeywordLoc, nodeLoc), nil
	case 12:
		expression_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param expression")
		}

		expression := expression_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewBlockArgumentNode(expression, operatorLoc, nodeLoc), nil
	case 13:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ParameterFlags(flags_)

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewBlockLocalVariableNode(flags, name, nodeLoc), nil
	case 14:
		locals, err := loadConstants(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param locals")
		}

		parameters_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param parameters")
		}

		parameters := parameters_

		body_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param body")
		}

		body := body_

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewBlockNode(locals, parameters, body, openingLoc, closingLoc, nodeLoc), nil
	case 15:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ParameterFlags(flags_)

		name, err := loadOptionalConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewBlockParameterNode(flags, name, nameLoc, operatorLoc, nodeLoc), nil
	case 16:
		parameters_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param parameters")
		}

		parameters, ok := parameters_.(*ParametersNode)
		if !ok && parameters_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param parameters: expected ParametersNode, got %T", parameters_))
		}

		localsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param localsCount")
		}

		locals := make([]Node, localsCount)
		for i := range localsCount {
			locals[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param locals")
			}
		}

		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewBlockParametersNode(parameters, locals, openingLoc, closingLoc, nodeLoc), nil
	case 17:
		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		return NewBreakNode(arguments, keywordLoc, nodeLoc), nil
	case 18:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := CallNodeFlags(flags_)

		receiver_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		callOperatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param callOperatorLoc")
		}

		messageLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param messageLoc")
		}

		readName, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param readName")
		}

		writeName, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param writeName")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewCallAndWriteNode(flags, receiver, callOperatorLoc, messageLoc, readName, writeName, operatorLoc, value, nodeLoc), nil
	case 19:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := CallNodeFlags(flags_)

		receiver_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		callOperatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param callOperatorLoc")
		}

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		messageLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param messageLoc")
		}

		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		block_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param block")
		}

		block := block_

		return NewCallNode(flags, receiver, callOperatorLoc, name, messageLoc, openingLoc, arguments, closingLoc, block, nodeLoc), nil
	case 20:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := CallNodeFlags(flags_)

		receiver_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		callOperatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param callOperatorLoc")
		}

		messageLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param messageLoc")
		}

		readName, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param readName")
		}

		writeName, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param writeName")
		}

		operator, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operator")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewCallOperatorWriteNode(flags, receiver, callOperatorLoc, messageLoc, readName, writeName, operator, operatorLoc, value, nodeLoc), nil
	case 21:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := CallNodeFlags(flags_)

		receiver_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		callOperatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param callOperatorLoc")
		}

		messageLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param messageLoc")
		}

		readName, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param readName")
		}

		writeName, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param writeName")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewCallOrWriteNode(flags, receiver, callOperatorLoc, messageLoc, readName, writeName, operatorLoc, value, nodeLoc), nil
	case 22:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := CallNodeFlags(flags_)

		receiver_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		callOperatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param callOperatorLoc")
		}

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		messageLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param messageLoc")
		}

		return NewCallTargetNode(flags, receiver, callOperatorLoc, name, messageLoc, nodeLoc), nil
	case 23:
		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		target_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param target")
		}

		target := target_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewCapturePatternNode(value, target, operatorLoc, nodeLoc), nil
	case 24:
		predicate_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param predicate")
		}

		predicate := predicate_

		conditionsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param conditionsCount")
		}

		conditions := make([]Node, conditionsCount)
		for i := range conditionsCount {
			conditions[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param conditions")
			}
		}

		consequent_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param consequent")
		}

		consequent, ok := consequent_.(*ElseNode)
		if !ok && consequent_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param consequent: expected ElseNode, got %T", consequent_))
		}

		caseKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param caseKeywordLoc")
		}

		endKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewCaseMatchNode(predicate, conditions, consequent, caseKeywordLoc, endKeywordLoc, nodeLoc), nil
	case 25:
		predicate_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param predicate")
		}

		predicate := predicate_

		conditionsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param conditionsCount")
		}

		conditions := make([]Node, conditionsCount)
		for i := range conditionsCount {
			conditions[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param conditions")
			}
		}

		consequent_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param consequent")
		}

		consequent, ok := consequent_.(*ElseNode)
		if !ok && consequent_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param consequent: expected ElseNode, got %T", consequent_))
		}

		caseKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param caseKeywordLoc")
		}

		endKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewCaseNode(predicate, conditions, consequent, caseKeywordLoc, endKeywordLoc, nodeLoc), nil
	case 26:
		locals, err := loadConstants(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param locals")
		}

		classKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param classKeywordLoc")
		}

		constantPath_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param constantPath")
		}

		constantPath := constantPath_

		inheritanceOperatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param inheritanceOperatorLoc")
		}

		superclass_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param superclass")
		}

		superclass := superclass_

		body_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param body")
		}

		body := body_

		endKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewClassNode(locals, classKeywordLoc, constantPath, inheritanceOperatorLoc, superclass, body, endKeywordLoc, name, nodeLoc), nil
	case 27:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewClassVariableAndWriteNode(name, nameLoc, operatorLoc, value, nodeLoc), nil
	case 28:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operator, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operator")
		}

		return NewClassVariableOperatorWriteNode(name, nameLoc, operatorLoc, value, operator, nodeLoc), nil
	case 29:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewClassVariableOrWriteNode(name, nameLoc, operatorLoc, value, nodeLoc), nil
	case 30:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewClassVariableReadNode(name, nodeLoc), nil
	case 31:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewClassVariableTargetNode(name, nodeLoc), nil
	case 32:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewClassVariableWriteNode(name, nameLoc, value, operatorLoc, nodeLoc), nil
	case 33:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewConstantAndWriteNode(name, nameLoc, operatorLoc, value, nodeLoc), nil
	case 34:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operator, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operator")
		}

		return NewConstantOperatorWriteNode(name, nameLoc, operatorLoc, value, operator, nodeLoc), nil
	case 35:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewConstantOrWriteNode(name, nameLoc, operatorLoc, value, nodeLoc), nil
	case 36:
		target_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param target")
		}

		target, ok := target_.(*ConstantPathNode)
		if !ok && target_ != nil {
			return nil, eris.Wrapf(err, "error reading param target: expected ConstantPathNode, got %T", target_)
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewConstantPathAndWriteNode(target, operatorLoc, value, nodeLoc), nil
	case 37:
		parent_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param parent")
		}

		parent := parent_

		child_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param child")
		}

		child := child_

		delimiterLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param delimiterLoc")
		}

		return NewConstantPathNode(parent, child, delimiterLoc, nodeLoc), nil
	case 38:
		target_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param target")
		}

		target, ok := target_.(*ConstantPathNode)
		if !ok && target_ != nil {
			return nil, eris.Wrapf(err, "error reading param target: expected ConstantPathNode, got %T", target_)
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operator, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operator")
		}

		return NewConstantPathOperatorWriteNode(target, operatorLoc, value, operator, nodeLoc), nil
	case 39:
		target_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param target")
		}

		target, ok := target_.(*ConstantPathNode)
		if !ok && target_ != nil {
			return nil, eris.Wrapf(err, "error reading param target: expected ConstantPathNode, got %T", target_)
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewConstantPathOrWriteNode(target, operatorLoc, value, nodeLoc), nil
	case 40:
		parent_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param parent")
		}

		parent := parent_

		child_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param child")
		}

		child := child_

		delimiterLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param delimiterLoc")
		}

		return NewConstantPathTargetNode(parent, child, delimiterLoc, nodeLoc), nil
	case 41:
		target_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param target")
		}

		target, ok := target_.(*ConstantPathNode)
		if !ok && target_ != nil {
			return nil, eris.Wrapf(err, "error reading param target: expected ConstantPathNode, got %T", target_)
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewConstantPathWriteNode(target, operatorLoc, value, nodeLoc), nil
	case 42:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewConstantReadNode(name, nodeLoc), nil
	case 43:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewConstantTargetNode(name, nodeLoc), nil
	case 44:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewConstantWriteNode(name, nameLoc, value, operatorLoc, nodeLoc), nil
	case 45:
		buff.readUInt32()

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		receiver_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		parameters_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param parameters")
		}

		parameters, ok := parameters_.(*ParametersNode)
		if !ok && parameters_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param parameters: expected ParametersNode, got %T", parameters_))
		}

		body_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param body")
		}

		body := body_

		locals, err := loadConstants(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param locals")
		}

		defKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param defKeywordLoc")
		}

		operatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		lparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param lparenLoc")
		}

		rparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rparenLoc")
		}

		equalLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param equalLoc")
		}

		endKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewDefNode(name, nameLoc, receiver, parameters, body, locals, defKeywordLoc, operatorLoc, lparenLoc, rparenLoc, equalLoc, endKeywordLoc, nodeLoc), nil
	case 46:
		lparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param lparenLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		rparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rparenLoc")
		}

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		return NewDefinedNode(lparenLoc, value, rparenLoc, keywordLoc, nodeLoc), nil
	case 47:
		elseKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param elseKeywordLoc")
		}

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		endKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewElseNode(elseKeywordLoc, statements, endKeywordLoc, nodeLoc), nil
	case 48:
		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewEmbeddedStatementsNode(openingLoc, statements, closingLoc, nodeLoc), nil
	case 49:
		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		variable_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param variable")
		}

		variable := variable_

		return NewEmbeddedVariableNode(operatorLoc, variable, nodeLoc), nil
	case 50:
		ensureKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param ensureKeywordLoc")
		}

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		endKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewEnsureNode(ensureKeywordLoc, statements, endKeywordLoc, nodeLoc), nil
	case 51:
		return NewFalseNode(nodeLoc), nil
	case 52:
		constant_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param constant")
		}

		constant := constant_

		left_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param left")
		}

		left := left_

		requiredsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param requiredsCount")
		}

		requireds := make([]Node, requiredsCount)
		for i := range requiredsCount {
			requireds[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param requireds")
			}
		}

		right_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param right")
		}

		right := right_

		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewFindPatternNode(constant, left, requireds, right, openingLoc, closingLoc, nodeLoc), nil
	case 53:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := RangeFlags(flags_)

		left_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param left")
		}

		left := left_

		right_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param right")
		}

		right := right_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewFlipFlopNode(flags, left, right, operatorLoc, nodeLoc), nil
	case 54:
		value := buff.readFloat64()

		return NewFloatNode(value, nodeLoc), nil
	case 55:
		index_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param index")
		}

		index := index_

		collection_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param collection")
		}

		collection := collection_

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		forKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param forKeywordLoc")
		}

		inKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param inKeywordLoc")
		}

		doKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param doKeywordLoc")
		}

		endKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewForNode(index, collection, statements, forKeywordLoc, inKeywordLoc, doKeywordLoc, endKeywordLoc, nodeLoc), nil
	case 56:
		return NewForwardingArgumentsNode(nodeLoc), nil
	case 57:
		return NewForwardingParameterNode(nodeLoc), nil
	case 58:
		block_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param block")
		}

		block, ok := block_.(*BlockNode)
		if !ok && block_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param block: expected BlockNode, got %T", block_))
		}

		return NewForwardingSuperNode(block, nodeLoc), nil
	case 59:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewGlobalVariableAndWriteNode(name, nameLoc, operatorLoc, value, nodeLoc), nil
	case 60:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operator, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operator")
		}

		return NewGlobalVariableOperatorWriteNode(name, nameLoc, operatorLoc, value, operator, nodeLoc), nil
	case 61:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewGlobalVariableOrWriteNode(name, nameLoc, operatorLoc, value, nodeLoc), nil
	case 62:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewGlobalVariableReadNode(name, nodeLoc), nil
	case 63:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewGlobalVariableTargetNode(name, nodeLoc), nil
	case 64:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewGlobalVariableWriteNode(name, nameLoc, value, operatorLoc, nodeLoc), nil
	case 65:
		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		elementsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param elementsCount")
		}

		elements := make([]Node, elementsCount)
		for i := range elementsCount {
			elements[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param elements")
			}
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewHashNode(openingLoc, elements, closingLoc, nodeLoc), nil
	case 66:
		constant_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param constant")
		}

		constant := constant_

		elementsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param elementsCount")
		}

		elements := make([]Node, elementsCount)
		for i := range elementsCount {
			elements[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param elements")
			}
		}

		rest_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rest")
		}

		rest := rest_

		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewHashPatternNode(constant, elements, rest, openingLoc, closingLoc, nodeLoc), nil
	case 67:
		ifKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param ifKeywordLoc")
		}

		predicate_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param predicate")
		}

		predicate := predicate_

		thenKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param thenKeywordLoc")
		}

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		consequent_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param consequent")
		}

		consequent := consequent_

		endKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewIfNode(ifKeywordLoc, predicate, thenKeywordLoc, statements, consequent, endKeywordLoc, nodeLoc), nil
	case 68:
		numeric_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param numeric")
		}

		numeric := numeric_

		return NewImaginaryNode(numeric, nodeLoc), nil
	case 69:
		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewImplicitNode(value, nodeLoc), nil
	case 70:
		return NewImplicitRestNode(nodeLoc), nil
	case 71:
		pattern_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param pattern")
		}

		pattern := pattern_

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		inLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param inLoc")
		}

		thenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param thenLoc")
		}

		return NewInNode(pattern, statements, inLoc, thenLoc, nodeLoc), nil
	case 72:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := CallNodeFlags(flags_)

		receiver_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		callOperatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param callOperatorLoc")
		}

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		block_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param block")
		}

		block := block_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewIndexAndWriteNode(flags, receiver, callOperatorLoc, openingLoc, arguments, closingLoc, block, operatorLoc, value, nodeLoc), nil
	case 73:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := CallNodeFlags(flags_)

		receiver_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		callOperatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param callOperatorLoc")
		}

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		block_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param block")
		}

		block := block_

		operator, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operator")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewIndexOperatorWriteNode(flags, receiver, callOperatorLoc, openingLoc, arguments, closingLoc, block, operator, operatorLoc, value, nodeLoc), nil
	case 74:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := CallNodeFlags(flags_)

		receiver_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		callOperatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param callOperatorLoc")
		}

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		block_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param block")
		}

		block := block_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewIndexOrWriteNode(flags, receiver, callOperatorLoc, openingLoc, arguments, closingLoc, block, operatorLoc, value, nodeLoc), nil
	case 75:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := CallNodeFlags(flags_)

		receiver_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param receiver")
		}

		receiver := receiver_

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		block_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param block")
		}

		block := block_

		return NewIndexTargetNode(flags, receiver, openingLoc, arguments, closingLoc, block, nodeLoc), nil
	case 76:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewInstanceVariableAndWriteNode(name, nameLoc, operatorLoc, value, nodeLoc), nil
	case 77:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operator, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operator")
		}

		return NewInstanceVariableOperatorWriteNode(name, nameLoc, operatorLoc, value, operator, nodeLoc), nil
	case 78:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewInstanceVariableOrWriteNode(name, nameLoc, operatorLoc, value, nodeLoc), nil
	case 79:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewInstanceVariableReadNode(name, nodeLoc), nil
	case 80:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewInstanceVariableTargetNode(name, nodeLoc), nil
	case 81:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewInstanceVariableWriteNode(name, nameLoc, value, operatorLoc, nodeLoc), nil
	case 82:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := IntegerBaseFlags(flags_)

		value, err := loadInteger(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		return NewIntegerNode(flags, value, nodeLoc), nil
	case 83:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := RegularExpressionFlags(flags_)

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		partsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param partsCount")
		}

		parts := make([]Node, partsCount)
		for i := range partsCount {
			parts[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param parts")
			}
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewInterpolatedMatchLastLineNode(flags, openingLoc, parts, closingLoc, nodeLoc), nil
	case 84:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := RegularExpressionFlags(flags_)

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		partsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param partsCount")
		}

		parts := make([]Node, partsCount)
		for i := range partsCount {
			parts[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param parts")
			}
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewInterpolatedRegularExpressionNode(flags, openingLoc, parts, closingLoc, nodeLoc), nil
	case 85:
		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		partsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param partsCount")
		}

		parts := make([]Node, partsCount)
		for i := range partsCount {
			parts[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param parts")
			}
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewInterpolatedStringNode(openingLoc, parts, closingLoc, nodeLoc), nil
	case 86:
		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		partsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param partsCount")
		}

		parts := make([]Node, partsCount)
		for i := range partsCount {
			parts[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param parts")
			}
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewInterpolatedSymbolNode(openingLoc, parts, closingLoc, nodeLoc), nil
	case 87:
		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		partsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param partsCount")
		}

		parts := make([]Node, partsCount)
		for i := range partsCount {
			parts[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param parts")
			}
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewInterpolatedXStringNode(openingLoc, parts, closingLoc, nodeLoc), nil
	case 88:
		return NewItParametersNode(nodeLoc), nil
	case 89:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := KeywordHashNodeFlags(flags_)

		elementsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param elementsCount")
		}

		elements := make([]Node, elementsCount)
		for i := range elementsCount {
			elements[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param elements")
			}
		}

		return NewKeywordHashNode(flags, elements, nodeLoc), nil
	case 90:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ParameterFlags(flags_)

		name, err := loadOptionalConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewKeywordRestParameterNode(flags, name, nameLoc, operatorLoc, nodeLoc), nil
	case 91:
		locals, err := loadConstants(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param locals")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		parameters_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param parameters")
		}

		parameters := parameters_

		body_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param body")
		}

		body := body_

		return NewLambdaNode(locals, operatorLoc, openingLoc, closingLoc, parameters, body, nodeLoc), nil
	case 92:
		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		depth, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param depth")
		}

		return NewLocalVariableAndWriteNode(nameLoc, operatorLoc, value, name, depth, nodeLoc), nil
	case 93:
		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		operator, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operator")
		}

		depth, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param depth")
		}

		return NewLocalVariableOperatorWriteNode(nameLoc, operatorLoc, value, name, operator, depth, nodeLoc), nil
	case 94:
		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		depth, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param depth")
		}

		return NewLocalVariableOrWriteNode(nameLoc, operatorLoc, value, name, depth, nodeLoc), nil
	case 95:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		depth, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param depth")
		}

		return NewLocalVariableReadNode(name, depth, nodeLoc), nil
	case 96:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		depth, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param depth")
		}

		return NewLocalVariableTargetNode(name, depth, nodeLoc), nil
	case 97:
		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		depth, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param depth")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewLocalVariableWriteNode(name, depth, nameLoc, value, operatorLoc, nodeLoc), nil
	case 98:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := RegularExpressionFlags(flags_)

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		contentLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param contentLoc")
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		unescaped_, err := loadStr(buff, src)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param unescaped")
		}
		unescaped := string(unescaped_)

		return NewMatchLastLineNode(flags, openingLoc, contentLoc, closingLoc, unescaped, nodeLoc), nil
	case 99:
		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		pattern_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param pattern")
		}

		pattern := pattern_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewMatchPredicateNode(value, pattern, operatorLoc, nodeLoc), nil
	case 100:
		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		pattern_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param pattern")
		}

		pattern := pattern_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewMatchRequiredNode(value, pattern, operatorLoc, nodeLoc), nil
	case 101:
		call_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param call")
		}

		call, ok := call_.(*CallNode)
		if !ok && call_ != nil {
			return nil, eris.Wrapf(err, "error reading param call: expected CallNode, got %T", call_)
		}

		targetsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param targetsCount")
		}

		targets := make([]Node, targetsCount)
		for i := range targetsCount {
			targets[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param targets")
			}
		}

		return NewMatchWriteNode(call, targets, nodeLoc), nil
	case 102:
		return NewMissingNode(nodeLoc), nil
	case 103:
		locals, err := loadConstants(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param locals")
		}

		moduleKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param moduleKeywordLoc")
		}

		constantPath_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param constantPath")
		}

		constantPath := constantPath_

		body_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param body")
		}

		body := body_

		endKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewModuleNode(locals, moduleKeywordLoc, constantPath, body, endKeywordLoc, name, nodeLoc), nil
	case 104:
		leftsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param leftsCount")
		}

		lefts := make([]Node, leftsCount)
		for i := range leftsCount {
			lefts[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param lefts")
			}
		}

		rest_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rest")
		}

		rest := rest_

		rightsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rightsCount")
		}

		rights := make([]Node, rightsCount)
		for i := range rightsCount {
			rights[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param rights")
			}
		}

		lparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param lparenLoc")
		}

		rparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rparenLoc")
		}

		return NewMultiTargetNode(lefts, rest, rights, lparenLoc, rparenLoc, nodeLoc), nil
	case 105:
		leftsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param leftsCount")
		}

		lefts := make([]Node, leftsCount)
		for i := range leftsCount {
			lefts[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param lefts")
			}
		}

		rest_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rest")
		}

		rest := rest_

		rightsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rightsCount")
		}

		rights := make([]Node, rightsCount)
		for i := range rightsCount {
			rights[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param rights")
			}
		}

		lparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param lparenLoc")
		}

		rparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rparenLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewMultiWriteNode(lefts, rest, rights, lparenLoc, rparenLoc, operatorLoc, value, nodeLoc), nil
	case 106:
		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		return NewNextNode(arguments, keywordLoc, nodeLoc), nil
	case 107:
		return NewNilNode(nodeLoc), nil
	case 108:
		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		return NewNoKeywordsParameterNode(operatorLoc, keywordLoc, nodeLoc), nil
	case 109:
		maximum, err := buff.readByte()
		if err != nil {
			return nil, eris.Wrap(err, "error reading param maximum")
		}

		return NewNumberedParametersNode(maximum, nodeLoc), nil
	case 110:
		number, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param number")
		}

		return NewNumberedReferenceReadNode(number, nodeLoc), nil
	case 111:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ParameterFlags(flags_)

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewOptionalKeywordParameterNode(flags, name, nameLoc, value, nodeLoc), nil
	case 112:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ParameterFlags(flags_)

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		value_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param value")
		}

		value := value_

		return NewOptionalParameterNode(flags, name, nameLoc, operatorLoc, value, nodeLoc), nil
	case 113:
		left_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param left")
		}

		left := left_

		right_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param right")
		}

		right := right_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewOrNode(left, right, operatorLoc, nodeLoc), nil
	case 114:
		requiredsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param requiredsCount")
		}

		requireds := make([]Node, requiredsCount)
		for i := range requiredsCount {
			requireds[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param requireds")
			}
		}

		optionalsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param optionalsCount")
		}

		optionals := make([]Node, optionalsCount)
		for i := range optionalsCount {
			optionals[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param optionals")
			}
		}

		rest_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rest")
		}

		rest := rest_

		postsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param postsCount")
		}

		posts := make([]Node, postsCount)
		for i := range postsCount {
			posts[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param posts")
			}
		}

		keywordsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordsCount")
		}

		keywords := make([]Node, keywordsCount)
		for i := range keywordsCount {
			keywords[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param keywords")
			}
		}

		keywordRest_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordRest")
		}

		keywordRest := keywordRest_

		block_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param block")
		}

		block, ok := block_.(*BlockParameterNode)
		if !ok && block_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param block: expected BlockParameterNode, got %T", block_))
		}

		return NewParametersNode(requireds, optionals, rest, posts, keywords, keywordRest, block, nodeLoc), nil
	case 115:
		body_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param body")
		}

		body := body_

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewParenthesesNode(body, openingLoc, closingLoc, nodeLoc), nil
	case 116:
		expression_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param expression")
		}

		expression := expression_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		lparenLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param lparenLoc")
		}

		rparenLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rparenLoc")
		}

		return NewPinnedExpressionNode(expression, operatorLoc, lparenLoc, rparenLoc, nodeLoc), nil
	case 117:
		variable_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param variable")
		}

		variable := variable_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewPinnedVariableNode(variable, operatorLoc, nodeLoc), nil
	case 118:
		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewPostExecutionNode(statements, keywordLoc, openingLoc, closingLoc, nodeLoc), nil
	case 119:
		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		return NewPreExecutionNode(statements, keywordLoc, openingLoc, closingLoc, nodeLoc), nil
	case 120:
		locals, err := loadConstants(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param locals")
		}

		statements_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrapf(err, "error reading param statements: expected StatementsNode, got %T", statements_)
		}

		return NewProgramNode(locals, statements, nodeLoc), nil
	case 121:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := RangeFlags(flags_)

		left_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param left")
		}

		left := left_

		right_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param right")
		}

		right := right_

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewRangeNode(flags, left, right, operatorLoc, nodeLoc), nil
	case 122:
		numeric_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param numeric")
		}

		numeric := numeric_

		return NewRationalNode(numeric, nodeLoc), nil
	case 123:
		return NewRedoNode(nodeLoc), nil
	case 124:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := RegularExpressionFlags(flags_)

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		contentLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param contentLoc")
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		unescaped_, err := loadStr(buff, src)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param unescaped")
		}
		unescaped := string(unescaped_)

		return NewRegularExpressionNode(flags, openingLoc, contentLoc, closingLoc, unescaped, nodeLoc), nil
	case 125:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ParameterFlags(flags_)

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		return NewRequiredKeywordParameterNode(flags, name, nameLoc, nodeLoc), nil
	case 126:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ParameterFlags(flags_)

		name, err := loadConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		return NewRequiredParameterNode(flags, name, nodeLoc), nil
	case 127:
		expression_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param expression")
		}

		expression := expression_

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		rescueExpression_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rescueExpression")
		}

		rescueExpression := rescueExpression_

		return NewRescueModifierNode(expression, keywordLoc, rescueExpression, nodeLoc), nil
	case 128:
		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		exceptionsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param exceptionsCount")
		}

		exceptions := make([]Node, exceptionsCount)
		for i := range exceptionsCount {
			exceptions[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param exceptions")
			}
		}

		operatorLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		reference_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param reference")
		}

		reference := reference_

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		consequent_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param consequent")
		}

		consequent, ok := consequent_.(*RescueNode)
		if !ok && consequent_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param consequent: expected RescueNode, got %T", consequent_))
		}

		return NewRescueNode(keywordLoc, exceptions, operatorLoc, reference, statements, consequent, nodeLoc), nil
	case 129:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := ParameterFlags(flags_)

		name, err := loadOptionalConstant(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param name")
		}

		nameLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param nameLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		return NewRestParameterNode(flags, name, nameLoc, operatorLoc, nodeLoc), nil
	case 130:
		return NewRetryNode(nodeLoc), nil
	case 131:
		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		return NewReturnNode(keywordLoc, arguments, nodeLoc), nil
	case 132:
		return NewSelfNode(nodeLoc), nil
	case 133:
		locals, err := loadConstants(buff, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param locals")
		}

		classKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param classKeywordLoc")
		}

		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		expression_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param expression")
		}

		expression := expression_

		body_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param body")
		}

		body := body_

		endKeywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewSingletonClassNode(locals, classKeywordLoc, operatorLoc, expression, body, endKeywordLoc, nodeLoc), nil
	case 134:
		return NewSourceEncodingNode(nodeLoc), nil
	case 135:
		filepath_, err := loadStr(buff, src)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param filepath")
		}
		filepath := string(filepath_)

		return NewSourceFileNode(filepath, nodeLoc), nil
	case 136:
		return NewSourceLineNode(nodeLoc), nil
	case 137:
		operatorLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param operatorLoc")
		}

		expression_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param expression")
		}

		expression := expression_

		return NewSplatNode(operatorLoc, expression, nodeLoc), nil
	case 138:
		bodyCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param bodyCount")
		}

		body := make([]Node, bodyCount)
		for i := range bodyCount {
			body[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param body")
			}
		}

		return NewStatementsNode(body, nodeLoc), nil
	case 139:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := StringFlags(flags_)

		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		contentLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param contentLoc")
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		unescaped_, err := loadStr(buff, src)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param unescaped")
		}
		unescaped := string(unescaped_)

		return NewStringNode(flags, openingLoc, contentLoc, closingLoc, unescaped, nodeLoc), nil
	case 140:
		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		lparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param lparenLoc")
		}

		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		rparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rparenLoc")
		}

		block_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param block")
		}

		block := block_

		return NewSuperNode(keywordLoc, lparenLoc, arguments, rparenLoc, block, nodeLoc), nil
	case 141:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := SymbolFlags(flags_)

		openingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		valueLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param valueLoc")
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		unescaped_, err := loadStr(buff, src)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param unescaped")
		}
		unescaped := string(unescaped_)

		return NewSymbolNode(flags, openingLoc, valueLoc, closingLoc, unescaped, nodeLoc), nil
	case 142:
		return NewTrueNode(nodeLoc), nil
	case 143:
		namesCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param namesCount")
		}

		names := make([]Node, namesCount)
		for i := range namesCount {
			names[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param names")
			}
		}

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		return NewUndefNode(names, keywordLoc, nodeLoc), nil
	case 144:
		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		predicate_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param predicate")
		}

		predicate := predicate_

		thenKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param thenKeywordLoc")
		}

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		consequent_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param consequent")
		}

		consequent, ok := consequent_.(*ElseNode)
		if !ok && consequent_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param consequent: expected ElseNode, got %T", consequent_))
		}

		endKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param endKeywordLoc")
		}

		return NewUnlessNode(keywordLoc, predicate, thenKeywordLoc, statements, consequent, endKeywordLoc, nodeLoc), nil
	case 145:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := LoopFlags(flags_)

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		predicate_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param predicate")
		}

		predicate := predicate_

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		return NewUntilNode(flags, keywordLoc, closingLoc, predicate, statements, nodeLoc), nil
	case 146:
		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		conditionsCount, err := loadVarUInt(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param conditionsCount")
		}

		conditions := make([]Node, conditionsCount)
		for i := range conditionsCount {
			conditions[i], err = loadNode(buff, src, pool)
			if err != nil {
				return nil, eris.Wrap(err, "error reading param conditions")
			}
		}

		thenKeywordLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param thenKeywordLoc")
		}

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		return NewWhenNode(keywordLoc, conditions, thenKeywordLoc, statements, nodeLoc), nil
	case 147:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := LoopFlags(flags_)

		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		closingLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		predicate_, err := loadNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param predicate")
		}

		predicate := predicate_

		statements_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param statements")
		}

		statements, ok := statements_.(*StatementsNode)
		if !ok && statements_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param statements: expected StatementsNode, got %T", statements_))
		}

		return NewWhileNode(flags, keywordLoc, closingLoc, predicate, statements, nodeLoc), nil
	case 148:
		flags_, err := loadFlags(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param flags")
		}
		flags := EncodingFlags(flags_)

		openingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param openingLoc")
		}

		contentLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param contentLoc")
		}

		closingLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param closingLoc")
		}

		unescaped_, err := loadStr(buff, src)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param unescaped")
		}
		unescaped := string(unescaped_)

		return NewXStringNode(flags, openingLoc, contentLoc, closingLoc, unescaped, nodeLoc), nil
	case 149:
		keywordLoc, err := loadLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param keywordLoc")
		}

		lparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param lparenLoc")
		}

		arguments_, err := loadOptionalNode(buff, src, pool)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param arguments")
		}

		arguments, ok := arguments_.(*ArgumentsNode)
		if !ok && arguments_ != nil {
			return nil, eris.Wrap(err, fmt.Sprintf("error reading param arguments: expected ArgumentsNode, got %T", arguments_))
		}

		rparenLoc, err := loadOptionalLocation(buff)
		if err != nil {
			return nil, eris.Wrap(err, "error reading param rparenLoc")
		}

		return NewYieldNode(keywordLoc, lparenLoc, arguments, rparenLoc, nodeLoc), nil
	default:
		return nil, eris.Errorf("unknown node type: %d", nodeType)
	}
}
