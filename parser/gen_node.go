/******************************************************************************/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/gen_node.go.erb                                                  */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/

package parser

import (
	"encoding/json"
	"math/big"
)

type NodeVisitor interface {
	Visit(Node)
}

type Node interface {
	Accept(NodeVisitor)
	Children() []Node
}

type AliasGlobalVariableNode struct {
	Newname    Node
	Oldname    Node
	Keywordloc *Location
	Loc        *Location
}

func NewAliasGlobalVariableNode(newName Node, oldName Node, keywordLoc *Location, loc *Location) *AliasGlobalVariableNode {
	return &AliasGlobalVariableNode{
		Newname:    newName,
		Oldname:    oldName,
		Keywordloc: keywordLoc,
		Loc:        loc,
	}
}

func (node *AliasGlobalVariableNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *AliasGlobalVariableNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Newname)

	children = append(children, node.Oldname)

	return children
}

func (node *AliasGlobalVariableNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "AliasGlobalVariableNode",
		"newName":    node.Newname,
		"oldName":    node.Oldname,
		"keywordLoc": node.Keywordloc,
		"loc":        node.Loc,
	})
}

type AliasMethodNode struct {
	Newname    Node
	Oldname    Node
	Keywordloc *Location
	Loc        *Location
}

func NewAliasMethodNode(newName Node, oldName Node, keywordLoc *Location, loc *Location) *AliasMethodNode {
	return &AliasMethodNode{
		Newname:    newName,
		Oldname:    oldName,
		Keywordloc: keywordLoc,
		Loc:        loc,
	}
}

func (node *AliasMethodNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *AliasMethodNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Newname)

	children = append(children, node.Oldname)

	return children
}

func (node *AliasMethodNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "AliasMethodNode",
		"newName":    node.Newname,
		"oldName":    node.Oldname,
		"keywordLoc": node.Keywordloc,
		"loc":        node.Loc,
	})
}

type AlternationPatternNode struct {
	Left        Node
	Right       Node
	Operatorloc *Location
	Loc         *Location
}

func NewAlternationPatternNode(left Node, right Node, operatorLoc *Location, loc *Location) *AlternationPatternNode {
	return &AlternationPatternNode{
		Left:        left,
		Right:       right,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *AlternationPatternNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *AlternationPatternNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Left)

	children = append(children, node.Right)

	return children
}

func (node *AlternationPatternNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "AlternationPatternNode",
		"left":        node.Left,
		"right":       node.Right,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type AndNode struct {
	Left        Node
	Right       Node
	Operatorloc *Location
	Loc         *Location
}

func NewAndNode(left Node, right Node, operatorLoc *Location, loc *Location) *AndNode {
	return &AndNode{
		Left:        left,
		Right:       right,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *AndNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *AndNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Left)

	children = append(children, node.Right)

	return children
}

func (node *AndNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "AndNode",
		"left":        node.Left,
		"right":       node.Right,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type ArgumentsNode struct {
	Flags     ArgumentsNodeFlags
	Arguments []Node
	Loc       *Location
}

func NewArgumentsNode(flags ArgumentsNodeFlags, arguments []Node, loc *Location) *ArgumentsNode {
	return &ArgumentsNode{
		Flags:     flags,
		Arguments: arguments,
		Loc:       loc,
	}
}

func (node *ArgumentsNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ArgumentsNode) IsContainsKeywordSplat() bool {
	return (node.Flags & ARGUMENTS_NODE_CONTAINS_KEYWORD_SPLAT) != 0
}

func (node *ArgumentsNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Arguments...)

	return children
}

func (node *ArgumentsNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":  "ArgumentsNode",
		"flags":     node.Flags,
		"arguments": node.Arguments,
		"loc":       node.Loc,
	})
}

type ArrayNode struct {
	Flags      ArrayNodeFlags
	Elements   []Node
	Openingloc *Location
	Closingloc *Location
	Loc        *Location
}

func NewArrayNode(flags ArrayNodeFlags, elements []Node, openingLoc *Location, closingLoc *Location, loc *Location) *ArrayNode {
	return &ArrayNode{
		Flags:      flags,
		Elements:   elements,
		Openingloc: openingLoc,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *ArrayNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ArrayNode) IsContainsSplat() bool {
	return (node.Flags & ARRAY_NODE_CONTAINS_SPLAT) != 0
}

func (node *ArrayNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Elements...)

	return children
}

func (node *ArrayNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "ArrayNode",
		"flags":      node.Flags,
		"elements":   node.Elements,
		"openingLoc": node.Openingloc,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type ArrayPatternNode struct {
	Constant   Node
	Requireds  []Node
	Rest       Node
	Posts      []Node
	Openingloc *Location
	Closingloc *Location
	Loc        *Location
}

func NewArrayPatternNode(constant Node, requireds []Node, rest Node, posts []Node, openingLoc *Location, closingLoc *Location, loc *Location) *ArrayPatternNode {
	return &ArrayPatternNode{
		Constant:   constant,
		Requireds:  requireds,
		Rest:       rest,
		Posts:      posts,
		Openingloc: openingLoc,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *ArrayPatternNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ArrayPatternNode) Children() []Node {
	children := make([]Node, 0)

	if node.Constant != nil {
		children = append(children, node.Constant)
	}

	children = append(children, node.Requireds...)

	if node.Rest != nil {
		children = append(children, node.Rest)
	}

	children = append(children, node.Posts...)

	return children
}

func (node *ArrayPatternNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "ArrayPatternNode",
		"constant":   node.Constant,
		"requireds":  node.Requireds,
		"rest":       node.Rest,
		"posts":      node.Posts,
		"openingLoc": node.Openingloc,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type AssocNode struct {
	Key         Node
	Value       Node
	Operatorloc *Location
	Loc         *Location
}

func NewAssocNode(key Node, value Node, operatorLoc *Location, loc *Location) *AssocNode {
	return &AssocNode{
		Key:         key,
		Value:       value,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *AssocNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *AssocNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Key)

	children = append(children, node.Value)

	return children
}

func (node *AssocNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "AssocNode",
		"key":         node.Key,
		"value":       node.Value,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type AssocSplatNode struct {
	Value       Node
	Operatorloc *Location
	Loc         *Location
}

func NewAssocSplatNode(value Node, operatorLoc *Location, loc *Location) *AssocSplatNode {
	return &AssocSplatNode{
		Value:       value,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *AssocSplatNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *AssocSplatNode) Children() []Node {
	children := make([]Node, 0)

	if node.Value != nil {
		children = append(children, node.Value)
	}

	return children
}

func (node *AssocSplatNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "AssocSplatNode",
		"value":       node.Value,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type BackReferenceReadNode struct {
	Name string
	Loc  *Location
}

func NewBackReferenceReadNode(name string, loc *Location) *BackReferenceReadNode {
	return &BackReferenceReadNode{
		Name: name,
		Loc:  loc,
	}
}

func (node *BackReferenceReadNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *BackReferenceReadNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *BackReferenceReadNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "BackReferenceReadNode",
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type BeginNode struct {
	Beginkeywordloc *Location
	Statements      *StatementsNode
	Rescueclause    *RescueNode
	Elseclause      *ElseNode
	Ensureclause    *EnsureNode
	Endkeywordloc   *Location
	Loc             *Location
}

func NewBeginNode(beginKeywordLoc *Location, statements *StatementsNode, rescueClause *RescueNode, elseClause *ElseNode, ensureClause *EnsureNode, endKeywordLoc *Location, loc *Location) *BeginNode {
	return &BeginNode{
		Beginkeywordloc: beginKeywordLoc,
		Statements:      statements,
		Rescueclause:    rescueClause,
		Elseclause:      elseClause,
		Ensureclause:    ensureClause,
		Endkeywordloc:   endKeywordLoc,
		Loc:             loc,
	}
}

func (node *BeginNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *BeginNode) Children() []Node {
	children := make([]Node, 0)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	if node.Rescueclause != nil {
		children = append(children, node.Rescueclause)
	}

	if node.Elseclause != nil {
		children = append(children, node.Elseclause)
	}

	if node.Ensureclause != nil {
		children = append(children, node.Ensureclause)
	}

	return children
}

func (node *BeginNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "BeginNode",
		"beginKeywordLoc": node.Beginkeywordloc,
		"statements":      node.Statements,
		"rescueClause":    node.Rescueclause,
		"elseClause":      node.Elseclause,
		"ensureClause":    node.Ensureclause,
		"endKeywordLoc":   node.Endkeywordloc,
		"loc":             node.Loc,
	})
}

type BlockArgumentNode struct {
	Expression  Node
	Operatorloc *Location
	Loc         *Location
}

func NewBlockArgumentNode(expression Node, operatorLoc *Location, loc *Location) *BlockArgumentNode {
	return &BlockArgumentNode{
		Expression:  expression,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *BlockArgumentNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *BlockArgumentNode) Children() []Node {
	children := make([]Node, 0)

	if node.Expression != nil {
		children = append(children, node.Expression)
	}

	return children
}

func (node *BlockArgumentNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "BlockArgumentNode",
		"expression":  node.Expression,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type BlockLocalVariableNode struct {
	Flags ParameterFlags
	Name  string
	Loc   *Location
}

func NewBlockLocalVariableNode(flags ParameterFlags, name string, loc *Location) *BlockLocalVariableNode {
	return &BlockLocalVariableNode{
		Flags: flags,
		Name:  name,
		Loc:   loc,
	}
}

func (node *BlockLocalVariableNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *BlockLocalVariableNode) IsRepeatedParameter() bool {
	return (node.Flags & PARAMETER_REPEATED_PARAMETER) != 0
}

func (node *BlockLocalVariableNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *BlockLocalVariableNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "BlockLocalVariableNode",
		"flags":    node.Flags,
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type BlockNode struct {
	Locals     []string
	Parameters Node
	Body       Node
	Openingloc *Location
	Closingloc *Location
	Loc        *Location
}

func NewBlockNode(locals []string, parameters Node, body Node, openingLoc *Location, closingLoc *Location, loc *Location) *BlockNode {
	return &BlockNode{
		Locals:     locals,
		Parameters: parameters,
		Body:       body,
		Openingloc: openingLoc,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *BlockNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *BlockNode) Children() []Node {
	children := make([]Node, 0)

	if node.Parameters != nil {
		children = append(children, node.Parameters)
	}

	if node.Body != nil {
		children = append(children, node.Body)
	}

	return children
}

func (node *BlockNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "BlockNode",
		"locals":     node.Locals,
		"parameters": node.Parameters,
		"body":       node.Body,
		"openingLoc": node.Openingloc,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type BlockParameterNode struct {
	Flags       ParameterFlags
	Name        *string
	Nameloc     *Location
	Operatorloc *Location
	Loc         *Location
}

func NewBlockParameterNode(flags ParameterFlags, name *string, nameLoc *Location, operatorLoc *Location, loc *Location) *BlockParameterNode {
	return &BlockParameterNode{
		Flags:       flags,
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *BlockParameterNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *BlockParameterNode) IsRepeatedParameter() bool {
	return (node.Flags & PARAMETER_REPEATED_PARAMETER) != 0
}

func (node *BlockParameterNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *BlockParameterNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "BlockParameterNode",
		"flags":       node.Flags,
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type BlockParametersNode struct {
	Parameters *ParametersNode
	Locals     []Node
	Openingloc *Location
	Closingloc *Location
	Loc        *Location
}

func NewBlockParametersNode(parameters *ParametersNode, locals []Node, openingLoc *Location, closingLoc *Location, loc *Location) *BlockParametersNode {
	return &BlockParametersNode{
		Parameters: parameters,
		Locals:     locals,
		Openingloc: openingLoc,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *BlockParametersNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *BlockParametersNode) Children() []Node {
	children := make([]Node, 0)

	if node.Parameters != nil {
		children = append(children, node.Parameters)
	}

	children = append(children, node.Locals...)

	return children
}

func (node *BlockParametersNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "BlockParametersNode",
		"parameters": node.Parameters,
		"locals":     node.Locals,
		"openingLoc": node.Openingloc,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type BreakNode struct {
	Arguments  *ArgumentsNode
	Keywordloc *Location
	Loc        *Location
}

func NewBreakNode(arguments *ArgumentsNode, keywordLoc *Location, loc *Location) *BreakNode {
	return &BreakNode{
		Arguments:  arguments,
		Keywordloc: keywordLoc,
		Loc:        loc,
	}
}

func (node *BreakNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *BreakNode) Children() []Node {
	children := make([]Node, 0)

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	return children
}

func (node *BreakNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "BreakNode",
		"arguments":  node.Arguments,
		"keywordLoc": node.Keywordloc,
		"loc":        node.Loc,
	})
}

type CallAndWriteNode struct {
	Flags           CallNodeFlags
	Receiver        Node
	Calloperatorloc *Location
	Messageloc      *Location
	Readname        string
	Writename       string
	Operatorloc     *Location
	Value           Node
	Loc             *Location
}

func NewCallAndWriteNode(flags CallNodeFlags, receiver Node, callOperatorLoc *Location, messageLoc *Location, readName string, writeName string, operatorLoc *Location, value Node, loc *Location) *CallAndWriteNode {
	return &CallAndWriteNode{
		Flags:           flags,
		Receiver:        receiver,
		Calloperatorloc: callOperatorLoc,
		Messageloc:      messageLoc,
		Readname:        readName,
		Writename:       writeName,
		Operatorloc:     operatorLoc,
		Value:           value,
		Loc:             loc,
	}
}

func (node *CallAndWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *CallAndWriteNode) IsSafeNavigation() bool {
	return (node.Flags & CALL_NODE_SAFE_NAVIGATION) != 0
}

func (node *CallAndWriteNode) IsVariableCall() bool {
	return (node.Flags & CALL_NODE_VARIABLE_CALL) != 0
}

func (node *CallAndWriteNode) IsAttributeWrite() bool {
	return (node.Flags & CALL_NODE_ATTRIBUTE_WRITE) != 0
}

func (node *CallAndWriteNode) IsIgnoreVisibility() bool {
	return (node.Flags & CALL_NODE_IGNORE_VISIBILITY) != 0
}

func (node *CallAndWriteNode) Children() []Node {
	children := make([]Node, 0)

	if node.Receiver != nil {
		children = append(children, node.Receiver)
	}

	children = append(children, node.Value)

	return children
}

func (node *CallAndWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "CallAndWriteNode",
		"flags":           node.Flags,
		"receiver":        node.Receiver,
		"callOperatorLoc": node.Calloperatorloc,
		"messageLoc":      node.Messageloc,
		"readName":        node.Readname,
		"writeName":       node.Writename,
		"operatorLoc":     node.Operatorloc,
		"value":           node.Value,
		"loc":             node.Loc,
	})
}

type CallNode struct {
	Flags           CallNodeFlags
	Receiver        Node
	Calloperatorloc *Location
	Name            string
	Messageloc      *Location
	Openingloc      *Location
	Arguments       *ArgumentsNode
	Closingloc      *Location
	Block           Node
	Loc             *Location
}

func NewCallNode(flags CallNodeFlags, receiver Node, callOperatorLoc *Location, name string, messageLoc *Location, openingLoc *Location, arguments *ArgumentsNode, closingLoc *Location, block Node, loc *Location) *CallNode {
	return &CallNode{
		Flags:           flags,
		Receiver:        receiver,
		Calloperatorloc: callOperatorLoc,
		Name:            name,
		Messageloc:      messageLoc,
		Openingloc:      openingLoc,
		Arguments:       arguments,
		Closingloc:      closingLoc,
		Block:           block,
		Loc:             loc,
	}
}

func (node *CallNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *CallNode) IsSafeNavigation() bool {
	return (node.Flags & CALL_NODE_SAFE_NAVIGATION) != 0
}

func (node *CallNode) IsVariableCall() bool {
	return (node.Flags & CALL_NODE_VARIABLE_CALL) != 0
}

func (node *CallNode) IsAttributeWrite() bool {
	return (node.Flags & CALL_NODE_ATTRIBUTE_WRITE) != 0
}

func (node *CallNode) IsIgnoreVisibility() bool {
	return (node.Flags & CALL_NODE_IGNORE_VISIBILITY) != 0
}

func (node *CallNode) Children() []Node {
	children := make([]Node, 0)

	if node.Receiver != nil {
		children = append(children, node.Receiver)
	}

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	if node.Block != nil {
		children = append(children, node.Block)
	}

	return children
}

func (node *CallNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "CallNode",
		"flags":           node.Flags,
		"receiver":        node.Receiver,
		"callOperatorLoc": node.Calloperatorloc,
		"name":            node.Name,
		"messageLoc":      node.Messageloc,
		"openingLoc":      node.Openingloc,
		"arguments":       node.Arguments,
		"closingLoc":      node.Closingloc,
		"block":           node.Block,
		"loc":             node.Loc,
	})
}

type CallOperatorWriteNode struct {
	Flags           CallNodeFlags
	Receiver        Node
	Calloperatorloc *Location
	Messageloc      *Location
	Readname        string
	Writename       string
	Operator        string
	Operatorloc     *Location
	Value           Node
	Loc             *Location
}

func NewCallOperatorWriteNode(flags CallNodeFlags, receiver Node, callOperatorLoc *Location, messageLoc *Location, readName string, writeName string, operator string, operatorLoc *Location, value Node, loc *Location) *CallOperatorWriteNode {
	return &CallOperatorWriteNode{
		Flags:           flags,
		Receiver:        receiver,
		Calloperatorloc: callOperatorLoc,
		Messageloc:      messageLoc,
		Readname:        readName,
		Writename:       writeName,
		Operator:        operator,
		Operatorloc:     operatorLoc,
		Value:           value,
		Loc:             loc,
	}
}

func (node *CallOperatorWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *CallOperatorWriteNode) IsSafeNavigation() bool {
	return (node.Flags & CALL_NODE_SAFE_NAVIGATION) != 0
}

func (node *CallOperatorWriteNode) IsVariableCall() bool {
	return (node.Flags & CALL_NODE_VARIABLE_CALL) != 0
}

func (node *CallOperatorWriteNode) IsAttributeWrite() bool {
	return (node.Flags & CALL_NODE_ATTRIBUTE_WRITE) != 0
}

func (node *CallOperatorWriteNode) IsIgnoreVisibility() bool {
	return (node.Flags & CALL_NODE_IGNORE_VISIBILITY) != 0
}

func (node *CallOperatorWriteNode) Children() []Node {
	children := make([]Node, 0)

	if node.Receiver != nil {
		children = append(children, node.Receiver)
	}

	children = append(children, node.Value)

	return children
}

func (node *CallOperatorWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "CallOperatorWriteNode",
		"flags":           node.Flags,
		"receiver":        node.Receiver,
		"callOperatorLoc": node.Calloperatorloc,
		"messageLoc":      node.Messageloc,
		"readName":        node.Readname,
		"writeName":       node.Writename,
		"operator":        node.Operator,
		"operatorLoc":     node.Operatorloc,
		"value":           node.Value,
		"loc":             node.Loc,
	})
}

type CallOrWriteNode struct {
	Flags           CallNodeFlags
	Receiver        Node
	Calloperatorloc *Location
	Messageloc      *Location
	Readname        string
	Writename       string
	Operatorloc     *Location
	Value           Node
	Loc             *Location
}

func NewCallOrWriteNode(flags CallNodeFlags, receiver Node, callOperatorLoc *Location, messageLoc *Location, readName string, writeName string, operatorLoc *Location, value Node, loc *Location) *CallOrWriteNode {
	return &CallOrWriteNode{
		Flags:           flags,
		Receiver:        receiver,
		Calloperatorloc: callOperatorLoc,
		Messageloc:      messageLoc,
		Readname:        readName,
		Writename:       writeName,
		Operatorloc:     operatorLoc,
		Value:           value,
		Loc:             loc,
	}
}

func (node *CallOrWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *CallOrWriteNode) IsSafeNavigation() bool {
	return (node.Flags & CALL_NODE_SAFE_NAVIGATION) != 0
}

func (node *CallOrWriteNode) IsVariableCall() bool {
	return (node.Flags & CALL_NODE_VARIABLE_CALL) != 0
}

func (node *CallOrWriteNode) IsAttributeWrite() bool {
	return (node.Flags & CALL_NODE_ATTRIBUTE_WRITE) != 0
}

func (node *CallOrWriteNode) IsIgnoreVisibility() bool {
	return (node.Flags & CALL_NODE_IGNORE_VISIBILITY) != 0
}

func (node *CallOrWriteNode) Children() []Node {
	children := make([]Node, 0)

	if node.Receiver != nil {
		children = append(children, node.Receiver)
	}

	children = append(children, node.Value)

	return children
}

func (node *CallOrWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "CallOrWriteNode",
		"flags":           node.Flags,
		"receiver":        node.Receiver,
		"callOperatorLoc": node.Calloperatorloc,
		"messageLoc":      node.Messageloc,
		"readName":        node.Readname,
		"writeName":       node.Writename,
		"operatorLoc":     node.Operatorloc,
		"value":           node.Value,
		"loc":             node.Loc,
	})
}

type CallTargetNode struct {
	Flags           CallNodeFlags
	Receiver        Node
	Calloperatorloc *Location
	Name            string
	Messageloc      *Location
	Loc             *Location
}

func NewCallTargetNode(flags CallNodeFlags, receiver Node, callOperatorLoc *Location, name string, messageLoc *Location, loc *Location) *CallTargetNode {
	return &CallTargetNode{
		Flags:           flags,
		Receiver:        receiver,
		Calloperatorloc: callOperatorLoc,
		Name:            name,
		Messageloc:      messageLoc,
		Loc:             loc,
	}
}

func (node *CallTargetNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *CallTargetNode) IsSafeNavigation() bool {
	return (node.Flags & CALL_NODE_SAFE_NAVIGATION) != 0
}

func (node *CallTargetNode) IsVariableCall() bool {
	return (node.Flags & CALL_NODE_VARIABLE_CALL) != 0
}

func (node *CallTargetNode) IsAttributeWrite() bool {
	return (node.Flags & CALL_NODE_ATTRIBUTE_WRITE) != 0
}

func (node *CallTargetNode) IsIgnoreVisibility() bool {
	return (node.Flags & CALL_NODE_IGNORE_VISIBILITY) != 0
}

func (node *CallTargetNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Receiver)

	return children
}

func (node *CallTargetNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "CallTargetNode",
		"flags":           node.Flags,
		"receiver":        node.Receiver,
		"callOperatorLoc": node.Calloperatorloc,
		"name":            node.Name,
		"messageLoc":      node.Messageloc,
		"loc":             node.Loc,
	})
}

type CapturePatternNode struct {
	Value       Node
	Target      Node
	Operatorloc *Location
	Loc         *Location
}

func NewCapturePatternNode(value Node, target Node, operatorLoc *Location, loc *Location) *CapturePatternNode {
	return &CapturePatternNode{
		Value:       value,
		Target:      target,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *CapturePatternNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *CapturePatternNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	children = append(children, node.Target)

	return children
}

func (node *CapturePatternNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "CapturePatternNode",
		"value":       node.Value,
		"target":      node.Target,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type CaseMatchNode struct {
	Predicate      Node
	Conditions     []Node
	Consequent     *ElseNode
	Casekeywordloc *Location
	Endkeywordloc  *Location
	Loc            *Location
}

func NewCaseMatchNode(predicate Node, conditions []Node, consequent *ElseNode, caseKeywordLoc *Location, endKeywordLoc *Location, loc *Location) *CaseMatchNode {
	return &CaseMatchNode{
		Predicate:      predicate,
		Conditions:     conditions,
		Consequent:     consequent,
		Casekeywordloc: caseKeywordLoc,
		Endkeywordloc:  endKeywordLoc,
		Loc:            loc,
	}
}

func (node *CaseMatchNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *CaseMatchNode) Children() []Node {
	children := make([]Node, 0)

	if node.Predicate != nil {
		children = append(children, node.Predicate)
	}

	children = append(children, node.Conditions...)

	if node.Consequent != nil {
		children = append(children, node.Consequent)
	}

	return children
}

func (node *CaseMatchNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":       "CaseMatchNode",
		"predicate":      node.Predicate,
		"conditions":     node.Conditions,
		"consequent":     node.Consequent,
		"caseKeywordLoc": node.Casekeywordloc,
		"endKeywordLoc":  node.Endkeywordloc,
		"loc":            node.Loc,
	})
}

type CaseNode struct {
	Predicate      Node
	Conditions     []Node
	Consequent     *ElseNode
	Casekeywordloc *Location
	Endkeywordloc  *Location
	Loc            *Location
}

func NewCaseNode(predicate Node, conditions []Node, consequent *ElseNode, caseKeywordLoc *Location, endKeywordLoc *Location, loc *Location) *CaseNode {
	return &CaseNode{
		Predicate:      predicate,
		Conditions:     conditions,
		Consequent:     consequent,
		Casekeywordloc: caseKeywordLoc,
		Endkeywordloc:  endKeywordLoc,
		Loc:            loc,
	}
}

func (node *CaseNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *CaseNode) Children() []Node {
	children := make([]Node, 0)

	if node.Predicate != nil {
		children = append(children, node.Predicate)
	}

	children = append(children, node.Conditions...)

	if node.Consequent != nil {
		children = append(children, node.Consequent)
	}

	return children
}

func (node *CaseNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":       "CaseNode",
		"predicate":      node.Predicate,
		"conditions":     node.Conditions,
		"consequent":     node.Consequent,
		"caseKeywordLoc": node.Casekeywordloc,
		"endKeywordLoc":  node.Endkeywordloc,
		"loc":            node.Loc,
	})
}

type ClassNode struct {
	Locals                 []string
	Classkeywordloc        *Location
	Constantpath           Node
	Inheritanceoperatorloc *Location
	Superclass             Node
	Body                   Node
	Endkeywordloc          *Location
	Name                   string
	Loc                    *Location
}

func NewClassNode(locals []string, classKeywordLoc *Location, constantPath Node, inheritanceOperatorLoc *Location, superclass Node, body Node, endKeywordLoc *Location, name string, loc *Location) *ClassNode {
	return &ClassNode{
		Locals:                 locals,
		Classkeywordloc:        classKeywordLoc,
		Constantpath:           constantPath,
		Inheritanceoperatorloc: inheritanceOperatorLoc,
		Superclass:             superclass,
		Body:                   body,
		Endkeywordloc:          endKeywordLoc,
		Name:                   name,
		Loc:                    loc,
	}
}

func (node *ClassNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ClassNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Constantpath)

	if node.Superclass != nil {
		children = append(children, node.Superclass)
	}

	if node.Body != nil {
		children = append(children, node.Body)
	}

	return children
}

func (node *ClassNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":               "ClassNode",
		"locals":                 node.Locals,
		"classKeywordLoc":        node.Classkeywordloc,
		"constantPath":           node.Constantpath,
		"inheritanceOperatorLoc": node.Inheritanceoperatorloc,
		"superclass":             node.Superclass,
		"body":                   node.Body,
		"endKeywordLoc":          node.Endkeywordloc,
		"name":                   node.Name,
		"loc":                    node.Loc,
	})
}

type ClassVariableAndWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewClassVariableAndWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, loc *Location) *ClassVariableAndWriteNode {
	return &ClassVariableAndWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *ClassVariableAndWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ClassVariableAndWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *ClassVariableAndWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ClassVariableAndWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type ClassVariableOperatorWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Operator    string
	Loc         *Location
}

func NewClassVariableOperatorWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, operator string, loc *Location) *ClassVariableOperatorWriteNode {
	return &ClassVariableOperatorWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Operator:    operator,
		Loc:         loc,
	}
}

func (node *ClassVariableOperatorWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ClassVariableOperatorWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *ClassVariableOperatorWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ClassVariableOperatorWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"operator":    node.Operator,
		"loc":         node.Loc,
	})
}

type ClassVariableOrWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewClassVariableOrWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, loc *Location) *ClassVariableOrWriteNode {
	return &ClassVariableOrWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *ClassVariableOrWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ClassVariableOrWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *ClassVariableOrWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ClassVariableOrWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type ClassVariableReadNode struct {
	Name string
	Loc  *Location
}

func NewClassVariableReadNode(name string, loc *Location) *ClassVariableReadNode {
	return &ClassVariableReadNode{
		Name: name,
		Loc:  loc,
	}
}

func (node *ClassVariableReadNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ClassVariableReadNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *ClassVariableReadNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ClassVariableReadNode",
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type ClassVariableTargetNode struct {
	Name string
	Loc  *Location
}

func NewClassVariableTargetNode(name string, loc *Location) *ClassVariableTargetNode {
	return &ClassVariableTargetNode{
		Name: name,
		Loc:  loc,
	}
}

func (node *ClassVariableTargetNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ClassVariableTargetNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *ClassVariableTargetNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ClassVariableTargetNode",
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type ClassVariableWriteNode struct {
	Name        string
	Nameloc     *Location
	Value       Node
	Operatorloc *Location
	Loc         *Location
}

func NewClassVariableWriteNode(name string, nameLoc *Location, value Node, operatorLoc *Location, loc *Location) *ClassVariableWriteNode {
	return &ClassVariableWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Value:       value,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *ClassVariableWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ClassVariableWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *ClassVariableWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ClassVariableWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"value":       node.Value,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type ConstantAndWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewConstantAndWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, loc *Location) *ConstantAndWriteNode {
	return &ConstantAndWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *ConstantAndWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantAndWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *ConstantAndWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ConstantAndWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type ConstantOperatorWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Operator    string
	Loc         *Location
}

func NewConstantOperatorWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, operator string, loc *Location) *ConstantOperatorWriteNode {
	return &ConstantOperatorWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Operator:    operator,
		Loc:         loc,
	}
}

func (node *ConstantOperatorWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantOperatorWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *ConstantOperatorWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ConstantOperatorWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"operator":    node.Operator,
		"loc":         node.Loc,
	})
}

type ConstantOrWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewConstantOrWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, loc *Location) *ConstantOrWriteNode {
	return &ConstantOrWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *ConstantOrWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantOrWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *ConstantOrWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ConstantOrWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type ConstantPathAndWriteNode struct {
	Target      *ConstantPathNode
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewConstantPathAndWriteNode(target *ConstantPathNode, operatorLoc *Location, value Node, loc *Location) *ConstantPathAndWriteNode {
	return &ConstantPathAndWriteNode{
		Target:      target,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *ConstantPathAndWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantPathAndWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Target)

	children = append(children, node.Value)

	return children
}

func (node *ConstantPathAndWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ConstantPathAndWriteNode",
		"target":      node.Target,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type ConstantPathNode struct {
	Parent       Node
	Child        Node
	Delimiterloc *Location
	Loc          *Location
}

func NewConstantPathNode(parent Node, child Node, delimiterLoc *Location, loc *Location) *ConstantPathNode {
	return &ConstantPathNode{
		Parent:       parent,
		Child:        child,
		Delimiterloc: delimiterLoc,
		Loc:          loc,
	}
}

func (node *ConstantPathNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantPathNode) Children() []Node {
	children := make([]Node, 0)

	if node.Parent != nil {
		children = append(children, node.Parent)
	}

	children = append(children, node.Child)

	return children
}

func (node *ConstantPathNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":     "ConstantPathNode",
		"parent":       node.Parent,
		"child":        node.Child,
		"delimiterLoc": node.Delimiterloc,
		"loc":          node.Loc,
	})
}

type ConstantPathOperatorWriteNode struct {
	Target      *ConstantPathNode
	Operatorloc *Location
	Value       Node
	Operator    string
	Loc         *Location
}

func NewConstantPathOperatorWriteNode(target *ConstantPathNode, operatorLoc *Location, value Node, operator string, loc *Location) *ConstantPathOperatorWriteNode {
	return &ConstantPathOperatorWriteNode{
		Target:      target,
		Operatorloc: operatorLoc,
		Value:       value,
		Operator:    operator,
		Loc:         loc,
	}
}

func (node *ConstantPathOperatorWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantPathOperatorWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Target)

	children = append(children, node.Value)

	return children
}

func (node *ConstantPathOperatorWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ConstantPathOperatorWriteNode",
		"target":      node.Target,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"operator":    node.Operator,
		"loc":         node.Loc,
	})
}

type ConstantPathOrWriteNode struct {
	Target      *ConstantPathNode
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewConstantPathOrWriteNode(target *ConstantPathNode, operatorLoc *Location, value Node, loc *Location) *ConstantPathOrWriteNode {
	return &ConstantPathOrWriteNode{
		Target:      target,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *ConstantPathOrWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantPathOrWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Target)

	children = append(children, node.Value)

	return children
}

func (node *ConstantPathOrWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ConstantPathOrWriteNode",
		"target":      node.Target,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type ConstantPathTargetNode struct {
	Parent       Node
	Child        Node
	Delimiterloc *Location
	Loc          *Location
}

func NewConstantPathTargetNode(parent Node, child Node, delimiterLoc *Location, loc *Location) *ConstantPathTargetNode {
	return &ConstantPathTargetNode{
		Parent:       parent,
		Child:        child,
		Delimiterloc: delimiterLoc,
		Loc:          loc,
	}
}

func (node *ConstantPathTargetNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantPathTargetNode) Children() []Node {
	children := make([]Node, 0)

	if node.Parent != nil {
		children = append(children, node.Parent)
	}

	children = append(children, node.Child)

	return children
}

func (node *ConstantPathTargetNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":     "ConstantPathTargetNode",
		"parent":       node.Parent,
		"child":        node.Child,
		"delimiterLoc": node.Delimiterloc,
		"loc":          node.Loc,
	})
}

type ConstantPathWriteNode struct {
	Target      *ConstantPathNode
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewConstantPathWriteNode(target *ConstantPathNode, operatorLoc *Location, value Node, loc *Location) *ConstantPathWriteNode {
	return &ConstantPathWriteNode{
		Target:      target,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *ConstantPathWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantPathWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Target)

	children = append(children, node.Value)

	return children
}

func (node *ConstantPathWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ConstantPathWriteNode",
		"target":      node.Target,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type ConstantReadNode struct {
	Name string
	Loc  *Location
}

func NewConstantReadNode(name string, loc *Location) *ConstantReadNode {
	return &ConstantReadNode{
		Name: name,
		Loc:  loc,
	}
}

func (node *ConstantReadNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantReadNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *ConstantReadNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ConstantReadNode",
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type ConstantTargetNode struct {
	Name string
	Loc  *Location
}

func NewConstantTargetNode(name string, loc *Location) *ConstantTargetNode {
	return &ConstantTargetNode{
		Name: name,
		Loc:  loc,
	}
}

func (node *ConstantTargetNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantTargetNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *ConstantTargetNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ConstantTargetNode",
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type ConstantWriteNode struct {
	Name        string
	Nameloc     *Location
	Value       Node
	Operatorloc *Location
	Loc         *Location
}

func NewConstantWriteNode(name string, nameLoc *Location, value Node, operatorLoc *Location, loc *Location) *ConstantWriteNode {
	return &ConstantWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Value:       value,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *ConstantWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ConstantWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *ConstantWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ConstantWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"value":       node.Value,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type DefNode struct {
	Name          string
	Nameloc       *Location
	Receiver      Node
	Parameters    *ParametersNode
	Body          Node
	Locals        []string
	Defkeywordloc *Location
	Operatorloc   *Location
	Lparenloc     *Location
	Rparenloc     *Location
	Equalloc      *Location
	Endkeywordloc *Location
	Loc           *Location
}

func NewDefNode(name string, nameLoc *Location, receiver Node, parameters *ParametersNode, body Node, locals []string, defKeywordLoc *Location, operatorLoc *Location, lparenLoc *Location, rparenLoc *Location, equalLoc *Location, endKeywordLoc *Location, loc *Location) *DefNode {
	return &DefNode{
		Name:          name,
		Nameloc:       nameLoc,
		Receiver:      receiver,
		Parameters:    parameters,
		Body:          body,
		Locals:        locals,
		Defkeywordloc: defKeywordLoc,
		Operatorloc:   operatorLoc,
		Lparenloc:     lparenLoc,
		Rparenloc:     rparenLoc,
		Equalloc:      equalLoc,
		Endkeywordloc: endKeywordLoc,
		Loc:           loc,
	}
}

func (node *DefNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *DefNode) Children() []Node {
	children := make([]Node, 0)

	if node.Receiver != nil {
		children = append(children, node.Receiver)
	}

	if node.Parameters != nil {
		children = append(children, node.Parameters)
	}

	if node.Body != nil {
		children = append(children, node.Body)
	}

	return children
}

func (node *DefNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":      "DefNode",
		"name":          node.Name,
		"nameLoc":       node.Nameloc,
		"receiver":      node.Receiver,
		"parameters":    node.Parameters,
		"body":          node.Body,
		"locals":        node.Locals,
		"defKeywordLoc": node.Defkeywordloc,
		"operatorLoc":   node.Operatorloc,
		"lparenLoc":     node.Lparenloc,
		"rparenLoc":     node.Rparenloc,
		"equalLoc":      node.Equalloc,
		"endKeywordLoc": node.Endkeywordloc,
		"loc":           node.Loc,
	})
}

type DefinedNode struct {
	Lparenloc  *Location
	Value      Node
	Rparenloc  *Location
	Keywordloc *Location
	Loc        *Location
}

func NewDefinedNode(lparenLoc *Location, value Node, rparenLoc *Location, keywordLoc *Location, loc *Location) *DefinedNode {
	return &DefinedNode{
		Lparenloc:  lparenLoc,
		Value:      value,
		Rparenloc:  rparenLoc,
		Keywordloc: keywordLoc,
		Loc:        loc,
	}
}

func (node *DefinedNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *DefinedNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *DefinedNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "DefinedNode",
		"lparenLoc":  node.Lparenloc,
		"value":      node.Value,
		"rparenLoc":  node.Rparenloc,
		"keywordLoc": node.Keywordloc,
		"loc":        node.Loc,
	})
}

type ElseNode struct {
	Elsekeywordloc *Location
	Statements     *StatementsNode
	Endkeywordloc  *Location
	Loc            *Location
}

func NewElseNode(elseKeywordLoc *Location, statements *StatementsNode, endKeywordLoc *Location, loc *Location) *ElseNode {
	return &ElseNode{
		Elsekeywordloc: elseKeywordLoc,
		Statements:     statements,
		Endkeywordloc:  endKeywordLoc,
		Loc:            loc,
	}
}

func (node *ElseNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ElseNode) Children() []Node {
	children := make([]Node, 0)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *ElseNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":       "ElseNode",
		"elseKeywordLoc": node.Elsekeywordloc,
		"statements":     node.Statements,
		"endKeywordLoc":  node.Endkeywordloc,
		"loc":            node.Loc,
	})
}

type EmbeddedStatementsNode struct {
	Openingloc *Location
	Statements *StatementsNode
	Closingloc *Location
	Loc        *Location
}

func NewEmbeddedStatementsNode(openingLoc *Location, statements *StatementsNode, closingLoc *Location, loc *Location) *EmbeddedStatementsNode {
	return &EmbeddedStatementsNode{
		Openingloc: openingLoc,
		Statements: statements,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *EmbeddedStatementsNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *EmbeddedStatementsNode) Children() []Node {
	children := make([]Node, 0)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *EmbeddedStatementsNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "EmbeddedStatementsNode",
		"openingLoc": node.Openingloc,
		"statements": node.Statements,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type EmbeddedVariableNode struct {
	Operatorloc *Location
	Variable    Node
	Loc         *Location
}

func NewEmbeddedVariableNode(operatorLoc *Location, variable Node, loc *Location) *EmbeddedVariableNode {
	return &EmbeddedVariableNode{
		Operatorloc: operatorLoc,
		Variable:    variable,
		Loc:         loc,
	}
}

func (node *EmbeddedVariableNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *EmbeddedVariableNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Variable)

	return children
}

func (node *EmbeddedVariableNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "EmbeddedVariableNode",
		"operatorLoc": node.Operatorloc,
		"variable":    node.Variable,
		"loc":         node.Loc,
	})
}

type EnsureNode struct {
	Ensurekeywordloc *Location
	Statements       *StatementsNode
	Endkeywordloc    *Location
	Loc              *Location
}

func NewEnsureNode(ensureKeywordLoc *Location, statements *StatementsNode, endKeywordLoc *Location, loc *Location) *EnsureNode {
	return &EnsureNode{
		Ensurekeywordloc: ensureKeywordLoc,
		Statements:       statements,
		Endkeywordloc:    endKeywordLoc,
		Loc:              loc,
	}
}

func (node *EnsureNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *EnsureNode) Children() []Node {
	children := make([]Node, 0)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *EnsureNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":         "EnsureNode",
		"ensureKeywordLoc": node.Ensurekeywordloc,
		"statements":       node.Statements,
		"endKeywordLoc":    node.Endkeywordloc,
		"loc":              node.Loc,
	})
}

type FalseNode struct {
	Loc *Location
}

func NewFalseNode(loc *Location) *FalseNode {
	return &FalseNode{
		Loc: loc,
	}
}

func (node *FalseNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *FalseNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *FalseNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "FalseNode",
		"loc":      node.Loc,
	})
}

type FindPatternNode struct {
	Constant   Node
	Left       Node
	Requireds  []Node
	Right      Node
	Openingloc *Location
	Closingloc *Location
	Loc        *Location
}

func NewFindPatternNode(constant Node, left Node, requireds []Node, right Node, openingLoc *Location, closingLoc *Location, loc *Location) *FindPatternNode {
	return &FindPatternNode{
		Constant:   constant,
		Left:       left,
		Requireds:  requireds,
		Right:      right,
		Openingloc: openingLoc,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *FindPatternNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *FindPatternNode) Children() []Node {
	children := make([]Node, 0)

	if node.Constant != nil {
		children = append(children, node.Constant)
	}

	children = append(children, node.Left)

	children = append(children, node.Requireds...)

	children = append(children, node.Right)

	return children
}

func (node *FindPatternNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "FindPatternNode",
		"constant":   node.Constant,
		"left":       node.Left,
		"requireds":  node.Requireds,
		"right":      node.Right,
		"openingLoc": node.Openingloc,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type FlipFlopNode struct {
	Flags       RangeFlags
	Left        Node
	Right       Node
	Operatorloc *Location
	Loc         *Location
}

func NewFlipFlopNode(flags RangeFlags, left Node, right Node, operatorLoc *Location, loc *Location) *FlipFlopNode {
	return &FlipFlopNode{
		Flags:       flags,
		Left:        left,
		Right:       right,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *FlipFlopNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *FlipFlopNode) IsExcludeEnd() bool {
	return (node.Flags & RANGE_EXCLUDE_END) != 0
}

func (node *FlipFlopNode) Children() []Node {
	children := make([]Node, 0)

	if node.Left != nil {
		children = append(children, node.Left)
	}

	if node.Right != nil {
		children = append(children, node.Right)
	}

	return children
}

func (node *FlipFlopNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "FlipFlopNode",
		"flags":       node.Flags,
		"left":        node.Left,
		"right":       node.Right,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type FloatNode struct {
	Value float64
	Loc   *Location
}

func NewFloatNode(value float64, loc *Location) *FloatNode {
	return &FloatNode{
		Value: value,
		Loc:   loc,
	}
}

func (node *FloatNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *FloatNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *FloatNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "FloatNode",
		"value":    node.Value,
		"loc":      node.Loc,
	})
}

type ForNode struct {
	Index         Node
	Collection    Node
	Statements    *StatementsNode
	Forkeywordloc *Location
	Inkeywordloc  *Location
	Dokeywordloc  *Location
	Endkeywordloc *Location
	Loc           *Location
}

func NewForNode(index Node, collection Node, statements *StatementsNode, forKeywordLoc *Location, inKeywordLoc *Location, doKeywordLoc *Location, endKeywordLoc *Location, loc *Location) *ForNode {
	return &ForNode{
		Index:         index,
		Collection:    collection,
		Statements:    statements,
		Forkeywordloc: forKeywordLoc,
		Inkeywordloc:  inKeywordLoc,
		Dokeywordloc:  doKeywordLoc,
		Endkeywordloc: endKeywordLoc,
		Loc:           loc,
	}
}

func (node *ForNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ForNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Index)

	children = append(children, node.Collection)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *ForNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":      "ForNode",
		"index":         node.Index,
		"collection":    node.Collection,
		"statements":    node.Statements,
		"forKeywordLoc": node.Forkeywordloc,
		"inKeywordLoc":  node.Inkeywordloc,
		"doKeywordLoc":  node.Dokeywordloc,
		"endKeywordLoc": node.Endkeywordloc,
		"loc":           node.Loc,
	})
}

type ForwardingArgumentsNode struct {
	Loc *Location
}

func NewForwardingArgumentsNode(loc *Location) *ForwardingArgumentsNode {
	return &ForwardingArgumentsNode{
		Loc: loc,
	}
}

func (node *ForwardingArgumentsNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ForwardingArgumentsNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *ForwardingArgumentsNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ForwardingArgumentsNode",
		"loc":      node.Loc,
	})
}

type ForwardingParameterNode struct {
	Loc *Location
}

func NewForwardingParameterNode(loc *Location) *ForwardingParameterNode {
	return &ForwardingParameterNode{
		Loc: loc,
	}
}

func (node *ForwardingParameterNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ForwardingParameterNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *ForwardingParameterNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ForwardingParameterNode",
		"loc":      node.Loc,
	})
}

type ForwardingSuperNode struct {
	Block *BlockNode
	Loc   *Location
}

func NewForwardingSuperNode(block *BlockNode, loc *Location) *ForwardingSuperNode {
	return &ForwardingSuperNode{
		Block: block,
		Loc:   loc,
	}
}

func (node *ForwardingSuperNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ForwardingSuperNode) Children() []Node {
	children := make([]Node, 0)

	if node.Block != nil {
		children = append(children, node.Block)
	}

	return children
}

func (node *ForwardingSuperNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ForwardingSuperNode",
		"block":    node.Block,
		"loc":      node.Loc,
	})
}

type GlobalVariableAndWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewGlobalVariableAndWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, loc *Location) *GlobalVariableAndWriteNode {
	return &GlobalVariableAndWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *GlobalVariableAndWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *GlobalVariableAndWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *GlobalVariableAndWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "GlobalVariableAndWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type GlobalVariableOperatorWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Operator    string
	Loc         *Location
}

func NewGlobalVariableOperatorWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, operator string, loc *Location) *GlobalVariableOperatorWriteNode {
	return &GlobalVariableOperatorWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Operator:    operator,
		Loc:         loc,
	}
}

func (node *GlobalVariableOperatorWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *GlobalVariableOperatorWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *GlobalVariableOperatorWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "GlobalVariableOperatorWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"operator":    node.Operator,
		"loc":         node.Loc,
	})
}

type GlobalVariableOrWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewGlobalVariableOrWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, loc *Location) *GlobalVariableOrWriteNode {
	return &GlobalVariableOrWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *GlobalVariableOrWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *GlobalVariableOrWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *GlobalVariableOrWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "GlobalVariableOrWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type GlobalVariableReadNode struct {
	Name string
	Loc  *Location
}

func NewGlobalVariableReadNode(name string, loc *Location) *GlobalVariableReadNode {
	return &GlobalVariableReadNode{
		Name: name,
		Loc:  loc,
	}
}

func (node *GlobalVariableReadNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *GlobalVariableReadNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *GlobalVariableReadNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "GlobalVariableReadNode",
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type GlobalVariableTargetNode struct {
	Name string
	Loc  *Location
}

func NewGlobalVariableTargetNode(name string, loc *Location) *GlobalVariableTargetNode {
	return &GlobalVariableTargetNode{
		Name: name,
		Loc:  loc,
	}
}

func (node *GlobalVariableTargetNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *GlobalVariableTargetNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *GlobalVariableTargetNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "GlobalVariableTargetNode",
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type GlobalVariableWriteNode struct {
	Name        string
	Nameloc     *Location
	Value       Node
	Operatorloc *Location
	Loc         *Location
}

func NewGlobalVariableWriteNode(name string, nameLoc *Location, value Node, operatorLoc *Location, loc *Location) *GlobalVariableWriteNode {
	return &GlobalVariableWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Value:       value,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *GlobalVariableWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *GlobalVariableWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *GlobalVariableWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "GlobalVariableWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"value":       node.Value,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type HashNode struct {
	Openingloc *Location
	Elements   []Node
	Closingloc *Location
	Loc        *Location
}

func NewHashNode(openingLoc *Location, elements []Node, closingLoc *Location, loc *Location) *HashNode {
	return &HashNode{
		Openingloc: openingLoc,
		Elements:   elements,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *HashNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *HashNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Elements...)

	return children
}

func (node *HashNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "HashNode",
		"openingLoc": node.Openingloc,
		"elements":   node.Elements,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type HashPatternNode struct {
	Constant   Node
	Elements   []Node
	Rest       Node
	Openingloc *Location
	Closingloc *Location
	Loc        *Location
}

func NewHashPatternNode(constant Node, elements []Node, rest Node, openingLoc *Location, closingLoc *Location, loc *Location) *HashPatternNode {
	return &HashPatternNode{
		Constant:   constant,
		Elements:   elements,
		Rest:       rest,
		Openingloc: openingLoc,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *HashPatternNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *HashPatternNode) Children() []Node {
	children := make([]Node, 0)

	if node.Constant != nil {
		children = append(children, node.Constant)
	}

	children = append(children, node.Elements...)

	if node.Rest != nil {
		children = append(children, node.Rest)
	}

	return children
}

func (node *HashPatternNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "HashPatternNode",
		"constant":   node.Constant,
		"elements":   node.Elements,
		"rest":       node.Rest,
		"openingLoc": node.Openingloc,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type IfNode struct {
	Ifkeywordloc   *Location
	Predicate      Node
	Thenkeywordloc *Location
	Statements     *StatementsNode
	Consequent     Node
	Endkeywordloc  *Location
	Loc            *Location
}

func NewIfNode(ifKeywordLoc *Location, predicate Node, thenKeywordLoc *Location, statements *StatementsNode, consequent Node, endKeywordLoc *Location, loc *Location) *IfNode {
	return &IfNode{
		Ifkeywordloc:   ifKeywordLoc,
		Predicate:      predicate,
		Thenkeywordloc: thenKeywordLoc,
		Statements:     statements,
		Consequent:     consequent,
		Endkeywordloc:  endKeywordLoc,
		Loc:            loc,
	}
}

func (node *IfNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *IfNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Predicate)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	if node.Consequent != nil {
		children = append(children, node.Consequent)
	}

	return children
}

func (node *IfNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":       "IfNode",
		"ifKeywordLoc":   node.Ifkeywordloc,
		"predicate":      node.Predicate,
		"thenKeywordLoc": node.Thenkeywordloc,
		"statements":     node.Statements,
		"consequent":     node.Consequent,
		"endKeywordLoc":  node.Endkeywordloc,
		"loc":            node.Loc,
	})
}

type ImaginaryNode struct {
	Numeric Node
	Loc     *Location
}

func NewImaginaryNode(numeric Node, loc *Location) *ImaginaryNode {
	return &ImaginaryNode{
		Numeric: numeric,
		Loc:     loc,
	}
}

func (node *ImaginaryNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ImaginaryNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Numeric)

	return children
}

func (node *ImaginaryNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ImaginaryNode",
		"numeric":  node.Numeric,
		"loc":      node.Loc,
	})
}

type ImplicitNode struct {
	Value Node
	Loc   *Location
}

func NewImplicitNode(value Node, loc *Location) *ImplicitNode {
	return &ImplicitNode{
		Value: value,
		Loc:   loc,
	}
}

func (node *ImplicitNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ImplicitNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *ImplicitNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ImplicitNode",
		"value":    node.Value,
		"loc":      node.Loc,
	})
}

type ImplicitRestNode struct {
	Loc *Location
}

func NewImplicitRestNode(loc *Location) *ImplicitRestNode {
	return &ImplicitRestNode{
		Loc: loc,
	}
}

func (node *ImplicitRestNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ImplicitRestNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *ImplicitRestNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ImplicitRestNode",
		"loc":      node.Loc,
	})
}

type InNode struct {
	Pattern    Node
	Statements *StatementsNode
	Inloc      *Location
	Thenloc    *Location
	Loc        *Location
}

func NewInNode(pattern Node, statements *StatementsNode, inLoc *Location, thenLoc *Location, loc *Location) *InNode {
	return &InNode{
		Pattern:    pattern,
		Statements: statements,
		Inloc:      inLoc,
		Thenloc:    thenLoc,
		Loc:        loc,
	}
}

func (node *InNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Pattern)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *InNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "InNode",
		"pattern":    node.Pattern,
		"statements": node.Statements,
		"inLoc":      node.Inloc,
		"thenLoc":    node.Thenloc,
		"loc":        node.Loc,
	})
}

type IndexAndWriteNode struct {
	Flags           CallNodeFlags
	Receiver        Node
	Calloperatorloc *Location
	Openingloc      *Location
	Arguments       *ArgumentsNode
	Closingloc      *Location
	Block           Node
	Operatorloc     *Location
	Value           Node
	Loc             *Location
}

func NewIndexAndWriteNode(flags CallNodeFlags, receiver Node, callOperatorLoc *Location, openingLoc *Location, arguments *ArgumentsNode, closingLoc *Location, block Node, operatorLoc *Location, value Node, loc *Location) *IndexAndWriteNode {
	return &IndexAndWriteNode{
		Flags:           flags,
		Receiver:        receiver,
		Calloperatorloc: callOperatorLoc,
		Openingloc:      openingLoc,
		Arguments:       arguments,
		Closingloc:      closingLoc,
		Block:           block,
		Operatorloc:     operatorLoc,
		Value:           value,
		Loc:             loc,
	}
}

func (node *IndexAndWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *IndexAndWriteNode) IsSafeNavigation() bool {
	return (node.Flags & CALL_NODE_SAFE_NAVIGATION) != 0
}

func (node *IndexAndWriteNode) IsVariableCall() bool {
	return (node.Flags & CALL_NODE_VARIABLE_CALL) != 0
}

func (node *IndexAndWriteNode) IsAttributeWrite() bool {
	return (node.Flags & CALL_NODE_ATTRIBUTE_WRITE) != 0
}

func (node *IndexAndWriteNode) IsIgnoreVisibility() bool {
	return (node.Flags & CALL_NODE_IGNORE_VISIBILITY) != 0
}

func (node *IndexAndWriteNode) Children() []Node {
	children := make([]Node, 0)

	if node.Receiver != nil {
		children = append(children, node.Receiver)
	}

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	if node.Block != nil {
		children = append(children, node.Block)
	}

	children = append(children, node.Value)

	return children
}

func (node *IndexAndWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "IndexAndWriteNode",
		"flags":           node.Flags,
		"receiver":        node.Receiver,
		"callOperatorLoc": node.Calloperatorloc,
		"openingLoc":      node.Openingloc,
		"arguments":       node.Arguments,
		"closingLoc":      node.Closingloc,
		"block":           node.Block,
		"operatorLoc":     node.Operatorloc,
		"value":           node.Value,
		"loc":             node.Loc,
	})
}

type IndexOperatorWriteNode struct {
	Flags           CallNodeFlags
	Receiver        Node
	Calloperatorloc *Location
	Openingloc      *Location
	Arguments       *ArgumentsNode
	Closingloc      *Location
	Block           Node
	Operator        string
	Operatorloc     *Location
	Value           Node
	Loc             *Location
}

func NewIndexOperatorWriteNode(flags CallNodeFlags, receiver Node, callOperatorLoc *Location, openingLoc *Location, arguments *ArgumentsNode, closingLoc *Location, block Node, operator string, operatorLoc *Location, value Node, loc *Location) *IndexOperatorWriteNode {
	return &IndexOperatorWriteNode{
		Flags:           flags,
		Receiver:        receiver,
		Calloperatorloc: callOperatorLoc,
		Openingloc:      openingLoc,
		Arguments:       arguments,
		Closingloc:      closingLoc,
		Block:           block,
		Operator:        operator,
		Operatorloc:     operatorLoc,
		Value:           value,
		Loc:             loc,
	}
}

func (node *IndexOperatorWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *IndexOperatorWriteNode) IsSafeNavigation() bool {
	return (node.Flags & CALL_NODE_SAFE_NAVIGATION) != 0
}

func (node *IndexOperatorWriteNode) IsVariableCall() bool {
	return (node.Flags & CALL_NODE_VARIABLE_CALL) != 0
}

func (node *IndexOperatorWriteNode) IsAttributeWrite() bool {
	return (node.Flags & CALL_NODE_ATTRIBUTE_WRITE) != 0
}

func (node *IndexOperatorWriteNode) IsIgnoreVisibility() bool {
	return (node.Flags & CALL_NODE_IGNORE_VISIBILITY) != 0
}

func (node *IndexOperatorWriteNode) Children() []Node {
	children := make([]Node, 0)

	if node.Receiver != nil {
		children = append(children, node.Receiver)
	}

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	if node.Block != nil {
		children = append(children, node.Block)
	}

	children = append(children, node.Value)

	return children
}

func (node *IndexOperatorWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "IndexOperatorWriteNode",
		"flags":           node.Flags,
		"receiver":        node.Receiver,
		"callOperatorLoc": node.Calloperatorloc,
		"openingLoc":      node.Openingloc,
		"arguments":       node.Arguments,
		"closingLoc":      node.Closingloc,
		"block":           node.Block,
		"operator":        node.Operator,
		"operatorLoc":     node.Operatorloc,
		"value":           node.Value,
		"loc":             node.Loc,
	})
}

type IndexOrWriteNode struct {
	Flags           CallNodeFlags
	Receiver        Node
	Calloperatorloc *Location
	Openingloc      *Location
	Arguments       *ArgumentsNode
	Closingloc      *Location
	Block           Node
	Operatorloc     *Location
	Value           Node
	Loc             *Location
}

func NewIndexOrWriteNode(flags CallNodeFlags, receiver Node, callOperatorLoc *Location, openingLoc *Location, arguments *ArgumentsNode, closingLoc *Location, block Node, operatorLoc *Location, value Node, loc *Location) *IndexOrWriteNode {
	return &IndexOrWriteNode{
		Flags:           flags,
		Receiver:        receiver,
		Calloperatorloc: callOperatorLoc,
		Openingloc:      openingLoc,
		Arguments:       arguments,
		Closingloc:      closingLoc,
		Block:           block,
		Operatorloc:     operatorLoc,
		Value:           value,
		Loc:             loc,
	}
}

func (node *IndexOrWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *IndexOrWriteNode) IsSafeNavigation() bool {
	return (node.Flags & CALL_NODE_SAFE_NAVIGATION) != 0
}

func (node *IndexOrWriteNode) IsVariableCall() bool {
	return (node.Flags & CALL_NODE_VARIABLE_CALL) != 0
}

func (node *IndexOrWriteNode) IsAttributeWrite() bool {
	return (node.Flags & CALL_NODE_ATTRIBUTE_WRITE) != 0
}

func (node *IndexOrWriteNode) IsIgnoreVisibility() bool {
	return (node.Flags & CALL_NODE_IGNORE_VISIBILITY) != 0
}

func (node *IndexOrWriteNode) Children() []Node {
	children := make([]Node, 0)

	if node.Receiver != nil {
		children = append(children, node.Receiver)
	}

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	if node.Block != nil {
		children = append(children, node.Block)
	}

	children = append(children, node.Value)

	return children
}

func (node *IndexOrWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "IndexOrWriteNode",
		"flags":           node.Flags,
		"receiver":        node.Receiver,
		"callOperatorLoc": node.Calloperatorloc,
		"openingLoc":      node.Openingloc,
		"arguments":       node.Arguments,
		"closingLoc":      node.Closingloc,
		"block":           node.Block,
		"operatorLoc":     node.Operatorloc,
		"value":           node.Value,
		"loc":             node.Loc,
	})
}

type IndexTargetNode struct {
	Flags      CallNodeFlags
	Receiver   Node
	Openingloc *Location
	Arguments  *ArgumentsNode
	Closingloc *Location
	Block      Node
	Loc        *Location
}

func NewIndexTargetNode(flags CallNodeFlags, receiver Node, openingLoc *Location, arguments *ArgumentsNode, closingLoc *Location, block Node, loc *Location) *IndexTargetNode {
	return &IndexTargetNode{
		Flags:      flags,
		Receiver:   receiver,
		Openingloc: openingLoc,
		Arguments:  arguments,
		Closingloc: closingLoc,
		Block:      block,
		Loc:        loc,
	}
}

func (node *IndexTargetNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *IndexTargetNode) IsSafeNavigation() bool {
	return (node.Flags & CALL_NODE_SAFE_NAVIGATION) != 0
}

func (node *IndexTargetNode) IsVariableCall() bool {
	return (node.Flags & CALL_NODE_VARIABLE_CALL) != 0
}

func (node *IndexTargetNode) IsAttributeWrite() bool {
	return (node.Flags & CALL_NODE_ATTRIBUTE_WRITE) != 0
}

func (node *IndexTargetNode) IsIgnoreVisibility() bool {
	return (node.Flags & CALL_NODE_IGNORE_VISIBILITY) != 0
}

func (node *IndexTargetNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Receiver)

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	if node.Block != nil {
		children = append(children, node.Block)
	}

	return children
}

func (node *IndexTargetNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "IndexTargetNode",
		"flags":      node.Flags,
		"receiver":   node.Receiver,
		"openingLoc": node.Openingloc,
		"arguments":  node.Arguments,
		"closingLoc": node.Closingloc,
		"block":      node.Block,
		"loc":        node.Loc,
	})
}

type InstanceVariableAndWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewInstanceVariableAndWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, loc *Location) *InstanceVariableAndWriteNode {
	return &InstanceVariableAndWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *InstanceVariableAndWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InstanceVariableAndWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *InstanceVariableAndWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "InstanceVariableAndWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type InstanceVariableOperatorWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Operator    string
	Loc         *Location
}

func NewInstanceVariableOperatorWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, operator string, loc *Location) *InstanceVariableOperatorWriteNode {
	return &InstanceVariableOperatorWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Operator:    operator,
		Loc:         loc,
	}
}

func (node *InstanceVariableOperatorWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InstanceVariableOperatorWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *InstanceVariableOperatorWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "InstanceVariableOperatorWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"operator":    node.Operator,
		"loc":         node.Loc,
	})
}

type InstanceVariableOrWriteNode struct {
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewInstanceVariableOrWriteNode(name string, nameLoc *Location, operatorLoc *Location, value Node, loc *Location) *InstanceVariableOrWriteNode {
	return &InstanceVariableOrWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *InstanceVariableOrWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InstanceVariableOrWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *InstanceVariableOrWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "InstanceVariableOrWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type InstanceVariableReadNode struct {
	Name string
	Loc  *Location
}

func NewInstanceVariableReadNode(name string, loc *Location) *InstanceVariableReadNode {
	return &InstanceVariableReadNode{
		Name: name,
		Loc:  loc,
	}
}

func (node *InstanceVariableReadNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InstanceVariableReadNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *InstanceVariableReadNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "InstanceVariableReadNode",
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type InstanceVariableTargetNode struct {
	Name string
	Loc  *Location
}

func NewInstanceVariableTargetNode(name string, loc *Location) *InstanceVariableTargetNode {
	return &InstanceVariableTargetNode{
		Name: name,
		Loc:  loc,
	}
}

func (node *InstanceVariableTargetNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InstanceVariableTargetNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *InstanceVariableTargetNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "InstanceVariableTargetNode",
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type InstanceVariableWriteNode struct {
	Name        string
	Nameloc     *Location
	Value       Node
	Operatorloc *Location
	Loc         *Location
}

func NewInstanceVariableWriteNode(name string, nameLoc *Location, value Node, operatorLoc *Location, loc *Location) *InstanceVariableWriteNode {
	return &InstanceVariableWriteNode{
		Name:        name,
		Nameloc:     nameLoc,
		Value:       value,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *InstanceVariableWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InstanceVariableWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *InstanceVariableWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "InstanceVariableWriteNode",
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"value":       node.Value,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type IntegerNode struct {
	Flags IntegerBaseFlags
	Value *big.Int
	Loc   *Location
}

func NewIntegerNode(flags IntegerBaseFlags, value *big.Int, loc *Location) *IntegerNode {
	return &IntegerNode{
		Flags: flags,
		Value: value,
		Loc:   loc,
	}
}

func (node *IntegerNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *IntegerNode) IsBinary() bool {
	return (node.Flags & INTEGER_BASE_BINARY) != 0
}

func (node *IntegerNode) IsDecimal() bool {
	return (node.Flags & INTEGER_BASE_DECIMAL) != 0
}

func (node *IntegerNode) IsOctal() bool {
	return (node.Flags & INTEGER_BASE_OCTAL) != 0
}

func (node *IntegerNode) IsHexadecimal() bool {
	return (node.Flags & INTEGER_BASE_HEXADECIMAL) != 0
}

func (node *IntegerNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *IntegerNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "IntegerNode",
		"flags":    node.Flags,
		"value":    node.Value,
		"loc":      node.Loc,
	})
}

type InterpolatedMatchLastLineNode struct {
	Flags      RegularExpressionFlags
	Openingloc *Location
	Parts      []Node
	Closingloc *Location
	Loc        *Location
}

func NewInterpolatedMatchLastLineNode(flags RegularExpressionFlags, openingLoc *Location, parts []Node, closingLoc *Location, loc *Location) *InterpolatedMatchLastLineNode {
	return &InterpolatedMatchLastLineNode{
		Flags:      flags,
		Openingloc: openingLoc,
		Parts:      parts,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *InterpolatedMatchLastLineNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InterpolatedMatchLastLineNode) IsIgnoreCase() bool {
	return (node.Flags & REGULAR_EXPRESSION_IGNORE_CASE) != 0
}

func (node *InterpolatedMatchLastLineNode) IsExtended() bool {
	return (node.Flags & REGULAR_EXPRESSION_EXTENDED) != 0
}

func (node *InterpolatedMatchLastLineNode) IsMultiLine() bool {
	return (node.Flags & REGULAR_EXPRESSION_MULTI_LINE) != 0
}

func (node *InterpolatedMatchLastLineNode) IsOnce() bool {
	return (node.Flags & REGULAR_EXPRESSION_ONCE) != 0
}

func (node *InterpolatedMatchLastLineNode) IsEucJp() bool {
	return (node.Flags & REGULAR_EXPRESSION_EUC_JP) != 0
}

func (node *InterpolatedMatchLastLineNode) IsAscii8bit() bool {
	return (node.Flags & REGULAR_EXPRESSION_ASCII_8BIT) != 0
}

func (node *InterpolatedMatchLastLineNode) IsWindows31j() bool {
	return (node.Flags & REGULAR_EXPRESSION_WINDOWS_31J) != 0
}

func (node *InterpolatedMatchLastLineNode) IsUtf8() bool {
	return (node.Flags & REGULAR_EXPRESSION_UTF_8) != 0
}

func (node *InterpolatedMatchLastLineNode) IsForcedUtf8Encoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_UTF8_ENCODING) != 0
}

func (node *InterpolatedMatchLastLineNode) IsForcedBinaryEncoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_BINARY_ENCODING) != 0
}

func (node *InterpolatedMatchLastLineNode) IsForcedUsAsciiEncoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_US_ASCII_ENCODING) != 0
}

func (node *InterpolatedMatchLastLineNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Parts...)

	return children
}

func (node *InterpolatedMatchLastLineNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "InterpolatedMatchLastLineNode",
		"flags":      node.Flags,
		"openingLoc": node.Openingloc,
		"parts":      node.Parts,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type InterpolatedRegularExpressionNode struct {
	Flags      RegularExpressionFlags
	Openingloc *Location
	Parts      []Node
	Closingloc *Location
	Loc        *Location
}

func NewInterpolatedRegularExpressionNode(flags RegularExpressionFlags, openingLoc *Location, parts []Node, closingLoc *Location, loc *Location) *InterpolatedRegularExpressionNode {
	return &InterpolatedRegularExpressionNode{
		Flags:      flags,
		Openingloc: openingLoc,
		Parts:      parts,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *InterpolatedRegularExpressionNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InterpolatedRegularExpressionNode) IsIgnoreCase() bool {
	return (node.Flags & REGULAR_EXPRESSION_IGNORE_CASE) != 0
}

func (node *InterpolatedRegularExpressionNode) IsExtended() bool {
	return (node.Flags & REGULAR_EXPRESSION_EXTENDED) != 0
}

func (node *InterpolatedRegularExpressionNode) IsMultiLine() bool {
	return (node.Flags & REGULAR_EXPRESSION_MULTI_LINE) != 0
}

func (node *InterpolatedRegularExpressionNode) IsOnce() bool {
	return (node.Flags & REGULAR_EXPRESSION_ONCE) != 0
}

func (node *InterpolatedRegularExpressionNode) IsEucJp() bool {
	return (node.Flags & REGULAR_EXPRESSION_EUC_JP) != 0
}

func (node *InterpolatedRegularExpressionNode) IsAscii8bit() bool {
	return (node.Flags & REGULAR_EXPRESSION_ASCII_8BIT) != 0
}

func (node *InterpolatedRegularExpressionNode) IsWindows31j() bool {
	return (node.Flags & REGULAR_EXPRESSION_WINDOWS_31J) != 0
}

func (node *InterpolatedRegularExpressionNode) IsUtf8() bool {
	return (node.Flags & REGULAR_EXPRESSION_UTF_8) != 0
}

func (node *InterpolatedRegularExpressionNode) IsForcedUtf8Encoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_UTF8_ENCODING) != 0
}

func (node *InterpolatedRegularExpressionNode) IsForcedBinaryEncoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_BINARY_ENCODING) != 0
}

func (node *InterpolatedRegularExpressionNode) IsForcedUsAsciiEncoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_US_ASCII_ENCODING) != 0
}

func (node *InterpolatedRegularExpressionNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Parts...)

	return children
}

func (node *InterpolatedRegularExpressionNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "InterpolatedRegularExpressionNode",
		"flags":      node.Flags,
		"openingLoc": node.Openingloc,
		"parts":      node.Parts,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type InterpolatedStringNode struct {
	Openingloc *Location
	Parts      []Node
	Closingloc *Location
	Loc        *Location
}

func NewInterpolatedStringNode(openingLoc *Location, parts []Node, closingLoc *Location, loc *Location) *InterpolatedStringNode {
	return &InterpolatedStringNode{
		Openingloc: openingLoc,
		Parts:      parts,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *InterpolatedStringNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InterpolatedStringNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Parts...)

	return children
}

func (node *InterpolatedStringNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "InterpolatedStringNode",
		"openingLoc": node.Openingloc,
		"parts":      node.Parts,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type InterpolatedSymbolNode struct {
	Openingloc *Location
	Parts      []Node
	Closingloc *Location
	Loc        *Location
}

func NewInterpolatedSymbolNode(openingLoc *Location, parts []Node, closingLoc *Location, loc *Location) *InterpolatedSymbolNode {
	return &InterpolatedSymbolNode{
		Openingloc: openingLoc,
		Parts:      parts,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *InterpolatedSymbolNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InterpolatedSymbolNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Parts...)

	return children
}

func (node *InterpolatedSymbolNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "InterpolatedSymbolNode",
		"openingLoc": node.Openingloc,
		"parts":      node.Parts,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type InterpolatedXStringNode struct {
	Openingloc *Location
	Parts      []Node
	Closingloc *Location
	Loc        *Location
}

func NewInterpolatedXStringNode(openingLoc *Location, parts []Node, closingLoc *Location, loc *Location) *InterpolatedXStringNode {
	return &InterpolatedXStringNode{
		Openingloc: openingLoc,
		Parts:      parts,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *InterpolatedXStringNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *InterpolatedXStringNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Parts...)

	return children
}

func (node *InterpolatedXStringNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "InterpolatedXStringNode",
		"openingLoc": node.Openingloc,
		"parts":      node.Parts,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type ItParametersNode struct {
	Loc *Location
}

func NewItParametersNode(loc *Location) *ItParametersNode {
	return &ItParametersNode{
		Loc: loc,
	}
}

func (node *ItParametersNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ItParametersNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *ItParametersNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "ItParametersNode",
		"loc":      node.Loc,
	})
}

type KeywordHashNode struct {
	Flags    KeywordHashNodeFlags
	Elements []Node
	Loc      *Location
}

func NewKeywordHashNode(flags KeywordHashNodeFlags, elements []Node, loc *Location) *KeywordHashNode {
	return &KeywordHashNode{
		Flags:    flags,
		Elements: elements,
		Loc:      loc,
	}
}

func (node *KeywordHashNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *KeywordHashNode) IsSymbolKeys() bool {
	return (node.Flags & KEYWORD_HASH_NODE_SYMBOL_KEYS) != 0
}

func (node *KeywordHashNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Elements...)

	return children
}

func (node *KeywordHashNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "KeywordHashNode",
		"flags":    node.Flags,
		"elements": node.Elements,
		"loc":      node.Loc,
	})
}

type KeywordRestParameterNode struct {
	Flags       ParameterFlags
	Name        *string
	Nameloc     *Location
	Operatorloc *Location
	Loc         *Location
}

func NewKeywordRestParameterNode(flags ParameterFlags, name *string, nameLoc *Location, operatorLoc *Location, loc *Location) *KeywordRestParameterNode {
	return &KeywordRestParameterNode{
		Flags:       flags,
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *KeywordRestParameterNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *KeywordRestParameterNode) IsRepeatedParameter() bool {
	return (node.Flags & PARAMETER_REPEATED_PARAMETER) != 0
}

func (node *KeywordRestParameterNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *KeywordRestParameterNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "KeywordRestParameterNode",
		"flags":       node.Flags,
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type LambdaNode struct {
	Locals      []string
	Operatorloc *Location
	Openingloc  *Location
	Closingloc  *Location
	Parameters  Node
	Body        Node
	Loc         *Location
}

func NewLambdaNode(locals []string, operatorLoc *Location, openingLoc *Location, closingLoc *Location, parameters Node, body Node, loc *Location) *LambdaNode {
	return &LambdaNode{
		Locals:      locals,
		Operatorloc: operatorLoc,
		Openingloc:  openingLoc,
		Closingloc:  closingLoc,
		Parameters:  parameters,
		Body:        body,
		Loc:         loc,
	}
}

func (node *LambdaNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *LambdaNode) Children() []Node {
	children := make([]Node, 0)

	if node.Parameters != nil {
		children = append(children, node.Parameters)
	}

	if node.Body != nil {
		children = append(children, node.Body)
	}

	return children
}

func (node *LambdaNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "LambdaNode",
		"locals":      node.Locals,
		"operatorLoc": node.Operatorloc,
		"openingLoc":  node.Openingloc,
		"closingLoc":  node.Closingloc,
		"parameters":  node.Parameters,
		"body":        node.Body,
		"loc":         node.Loc,
	})
}

type LocalVariableAndWriteNode struct {
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Name        string
	Depth       uint32
	Loc         *Location
}

func NewLocalVariableAndWriteNode(nameLoc *Location, operatorLoc *Location, value Node, name string, depth uint32, loc *Location) *LocalVariableAndWriteNode {
	return &LocalVariableAndWriteNode{
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Name:        name,
		Depth:       depth,
		Loc:         loc,
	}
}

func (node *LocalVariableAndWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *LocalVariableAndWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *LocalVariableAndWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "LocalVariableAndWriteNode",
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"name":        node.Name,
		"depth":       node.Depth,
		"loc":         node.Loc,
	})
}

type LocalVariableOperatorWriteNode struct {
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Name        string
	Operator    string
	Depth       uint32
	Loc         *Location
}

func NewLocalVariableOperatorWriteNode(nameLoc *Location, operatorLoc *Location, value Node, name string, operator string, depth uint32, loc *Location) *LocalVariableOperatorWriteNode {
	return &LocalVariableOperatorWriteNode{
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Name:        name,
		Operator:    operator,
		Depth:       depth,
		Loc:         loc,
	}
}

func (node *LocalVariableOperatorWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *LocalVariableOperatorWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *LocalVariableOperatorWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "LocalVariableOperatorWriteNode",
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"name":        node.Name,
		"operator":    node.Operator,
		"depth":       node.Depth,
		"loc":         node.Loc,
	})
}

type LocalVariableOrWriteNode struct {
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Name        string
	Depth       uint32
	Loc         *Location
}

func NewLocalVariableOrWriteNode(nameLoc *Location, operatorLoc *Location, value Node, name string, depth uint32, loc *Location) *LocalVariableOrWriteNode {
	return &LocalVariableOrWriteNode{
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Name:        name,
		Depth:       depth,
		Loc:         loc,
	}
}

func (node *LocalVariableOrWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *LocalVariableOrWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *LocalVariableOrWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "LocalVariableOrWriteNode",
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"name":        node.Name,
		"depth":       node.Depth,
		"loc":         node.Loc,
	})
}

type LocalVariableReadNode struct {
	Name  string
	Depth uint32
	Loc   *Location
}

func NewLocalVariableReadNode(name string, depth uint32, loc *Location) *LocalVariableReadNode {
	return &LocalVariableReadNode{
		Name:  name,
		Depth: depth,
		Loc:   loc,
	}
}

func (node *LocalVariableReadNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *LocalVariableReadNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *LocalVariableReadNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "LocalVariableReadNode",
		"name":     node.Name,
		"depth":    node.Depth,
		"loc":      node.Loc,
	})
}

type LocalVariableTargetNode struct {
	Name  string
	Depth uint32
	Loc   *Location
}

func NewLocalVariableTargetNode(name string, depth uint32, loc *Location) *LocalVariableTargetNode {
	return &LocalVariableTargetNode{
		Name:  name,
		Depth: depth,
		Loc:   loc,
	}
}

func (node *LocalVariableTargetNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *LocalVariableTargetNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *LocalVariableTargetNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "LocalVariableTargetNode",
		"name":     node.Name,
		"depth":    node.Depth,
		"loc":      node.Loc,
	})
}

type LocalVariableWriteNode struct {
	Name        string
	Depth       uint32
	Nameloc     *Location
	Value       Node
	Operatorloc *Location
	Loc         *Location
}

func NewLocalVariableWriteNode(name string, depth uint32, nameLoc *Location, value Node, operatorLoc *Location, loc *Location) *LocalVariableWriteNode {
	return &LocalVariableWriteNode{
		Name:        name,
		Depth:       depth,
		Nameloc:     nameLoc,
		Value:       value,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *LocalVariableWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *LocalVariableWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *LocalVariableWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "LocalVariableWriteNode",
		"name":        node.Name,
		"depth":       node.Depth,
		"nameLoc":     node.Nameloc,
		"value":       node.Value,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type MatchLastLineNode struct {
	Flags      RegularExpressionFlags
	Openingloc *Location
	Contentloc *Location
	Closingloc *Location
	Unescaped  string
	Loc        *Location
}

func NewMatchLastLineNode(flags RegularExpressionFlags, openingLoc *Location, contentLoc *Location, closingLoc *Location, unescaped string, loc *Location) *MatchLastLineNode {
	return &MatchLastLineNode{
		Flags:      flags,
		Openingloc: openingLoc,
		Contentloc: contentLoc,
		Closingloc: closingLoc,
		Unescaped:  unescaped,
		Loc:        loc,
	}
}

func (node *MatchLastLineNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *MatchLastLineNode) IsIgnoreCase() bool {
	return (node.Flags & REGULAR_EXPRESSION_IGNORE_CASE) != 0
}

func (node *MatchLastLineNode) IsExtended() bool {
	return (node.Flags & REGULAR_EXPRESSION_EXTENDED) != 0
}

func (node *MatchLastLineNode) IsMultiLine() bool {
	return (node.Flags & REGULAR_EXPRESSION_MULTI_LINE) != 0
}

func (node *MatchLastLineNode) IsOnce() bool {
	return (node.Flags & REGULAR_EXPRESSION_ONCE) != 0
}

func (node *MatchLastLineNode) IsEucJp() bool {
	return (node.Flags & REGULAR_EXPRESSION_EUC_JP) != 0
}

func (node *MatchLastLineNode) IsAscii8bit() bool {
	return (node.Flags & REGULAR_EXPRESSION_ASCII_8BIT) != 0
}

func (node *MatchLastLineNode) IsWindows31j() bool {
	return (node.Flags & REGULAR_EXPRESSION_WINDOWS_31J) != 0
}

func (node *MatchLastLineNode) IsUtf8() bool {
	return (node.Flags & REGULAR_EXPRESSION_UTF_8) != 0
}

func (node *MatchLastLineNode) IsForcedUtf8Encoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_UTF8_ENCODING) != 0
}

func (node *MatchLastLineNode) IsForcedBinaryEncoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_BINARY_ENCODING) != 0
}

func (node *MatchLastLineNode) IsForcedUsAsciiEncoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_US_ASCII_ENCODING) != 0
}

func (node *MatchLastLineNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *MatchLastLineNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "MatchLastLineNode",
		"flags":      node.Flags,
		"openingLoc": node.Openingloc,
		"contentLoc": node.Contentloc,
		"closingLoc": node.Closingloc,
		"unescaped":  node.Unescaped,
		"loc":        node.Loc,
	})
}

type MatchPredicateNode struct {
	Value       Node
	Pattern     Node
	Operatorloc *Location
	Loc         *Location
}

func NewMatchPredicateNode(value Node, pattern Node, operatorLoc *Location, loc *Location) *MatchPredicateNode {
	return &MatchPredicateNode{
		Value:       value,
		Pattern:     pattern,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *MatchPredicateNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *MatchPredicateNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	children = append(children, node.Pattern)

	return children
}

func (node *MatchPredicateNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "MatchPredicateNode",
		"value":       node.Value,
		"pattern":     node.Pattern,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type MatchRequiredNode struct {
	Value       Node
	Pattern     Node
	Operatorloc *Location
	Loc         *Location
}

func NewMatchRequiredNode(value Node, pattern Node, operatorLoc *Location, loc *Location) *MatchRequiredNode {
	return &MatchRequiredNode{
		Value:       value,
		Pattern:     pattern,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *MatchRequiredNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *MatchRequiredNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	children = append(children, node.Pattern)

	return children
}

func (node *MatchRequiredNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "MatchRequiredNode",
		"value":       node.Value,
		"pattern":     node.Pattern,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type MatchWriteNode struct {
	Call    *CallNode
	Targets []Node
	Loc     *Location
}

func NewMatchWriteNode(call *CallNode, targets []Node, loc *Location) *MatchWriteNode {
	return &MatchWriteNode{
		Call:    call,
		Targets: targets,
		Loc:     loc,
	}
}

func (node *MatchWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *MatchWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Call)

	children = append(children, node.Targets...)

	return children
}

func (node *MatchWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "MatchWriteNode",
		"call":     node.Call,
		"targets":  node.Targets,
		"loc":      node.Loc,
	})
}

type MissingNode struct {
	Loc *Location
}

func NewMissingNode(loc *Location) *MissingNode {
	return &MissingNode{
		Loc: loc,
	}
}

func (node *MissingNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *MissingNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *MissingNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "MissingNode",
		"loc":      node.Loc,
	})
}

type ModuleNode struct {
	Locals           []string
	Modulekeywordloc *Location
	Constantpath     Node
	Body             Node
	Endkeywordloc    *Location
	Name             string
	Loc              *Location
}

func NewModuleNode(locals []string, moduleKeywordLoc *Location, constantPath Node, body Node, endKeywordLoc *Location, name string, loc *Location) *ModuleNode {
	return &ModuleNode{
		Locals:           locals,
		Modulekeywordloc: moduleKeywordLoc,
		Constantpath:     constantPath,
		Body:             body,
		Endkeywordloc:    endKeywordLoc,
		Name:             name,
		Loc:              loc,
	}
}

func (node *ModuleNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ModuleNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Constantpath)

	if node.Body != nil {
		children = append(children, node.Body)
	}

	return children
}

func (node *ModuleNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":         "ModuleNode",
		"locals":           node.Locals,
		"moduleKeywordLoc": node.Modulekeywordloc,
		"constantPath":     node.Constantpath,
		"body":             node.Body,
		"endKeywordLoc":    node.Endkeywordloc,
		"name":             node.Name,
		"loc":              node.Loc,
	})
}

type MultiTargetNode struct {
	Lefts     []Node
	Rest      Node
	Rights    []Node
	Lparenloc *Location
	Rparenloc *Location
	Loc       *Location
}

func NewMultiTargetNode(lefts []Node, rest Node, rights []Node, lparenLoc *Location, rparenLoc *Location, loc *Location) *MultiTargetNode {
	return &MultiTargetNode{
		Lefts:     lefts,
		Rest:      rest,
		Rights:    rights,
		Lparenloc: lparenLoc,
		Rparenloc: rparenLoc,
		Loc:       loc,
	}
}

func (node *MultiTargetNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *MultiTargetNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Lefts...)

	if node.Rest != nil {
		children = append(children, node.Rest)
	}

	children = append(children, node.Rights...)

	return children
}

func (node *MultiTargetNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":  "MultiTargetNode",
		"lefts":     node.Lefts,
		"rest":      node.Rest,
		"rights":    node.Rights,
		"lparenLoc": node.Lparenloc,
		"rparenLoc": node.Rparenloc,
		"loc":       node.Loc,
	})
}

type MultiWriteNode struct {
	Lefts       []Node
	Rest        Node
	Rights      []Node
	Lparenloc   *Location
	Rparenloc   *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewMultiWriteNode(lefts []Node, rest Node, rights []Node, lparenLoc *Location, rparenLoc *Location, operatorLoc *Location, value Node, loc *Location) *MultiWriteNode {
	return &MultiWriteNode{
		Lefts:       lefts,
		Rest:        rest,
		Rights:      rights,
		Lparenloc:   lparenLoc,
		Rparenloc:   rparenLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *MultiWriteNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *MultiWriteNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Lefts...)

	if node.Rest != nil {
		children = append(children, node.Rest)
	}

	children = append(children, node.Rights...)

	children = append(children, node.Value)

	return children
}

func (node *MultiWriteNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "MultiWriteNode",
		"lefts":       node.Lefts,
		"rest":        node.Rest,
		"rights":      node.Rights,
		"lparenLoc":   node.Lparenloc,
		"rparenLoc":   node.Rparenloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type NextNode struct {
	Arguments  *ArgumentsNode
	Keywordloc *Location
	Loc        *Location
}

func NewNextNode(arguments *ArgumentsNode, keywordLoc *Location, loc *Location) *NextNode {
	return &NextNode{
		Arguments:  arguments,
		Keywordloc: keywordLoc,
		Loc:        loc,
	}
}

func (node *NextNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *NextNode) Children() []Node {
	children := make([]Node, 0)

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	return children
}

func (node *NextNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "NextNode",
		"arguments":  node.Arguments,
		"keywordLoc": node.Keywordloc,
		"loc":        node.Loc,
	})
}

type NilNode struct {
	Loc *Location
}

func NewNilNode(loc *Location) *NilNode {
	return &NilNode{
		Loc: loc,
	}
}

func (node *NilNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *NilNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *NilNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "NilNode",
		"loc":      node.Loc,
	})
}

type NoKeywordsParameterNode struct {
	Operatorloc *Location
	Keywordloc  *Location
	Loc         *Location
}

func NewNoKeywordsParameterNode(operatorLoc *Location, keywordLoc *Location, loc *Location) *NoKeywordsParameterNode {
	return &NoKeywordsParameterNode{
		Operatorloc: operatorLoc,
		Keywordloc:  keywordLoc,
		Loc:         loc,
	}
}

func (node *NoKeywordsParameterNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *NoKeywordsParameterNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *NoKeywordsParameterNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "NoKeywordsParameterNode",
		"operatorLoc": node.Operatorloc,
		"keywordLoc":  node.Keywordloc,
		"loc":         node.Loc,
	})
}

type NumberedParametersNode struct {
	Maximum uint8
	Loc     *Location
}

func NewNumberedParametersNode(maximum uint8, loc *Location) *NumberedParametersNode {
	return &NumberedParametersNode{
		Maximum: maximum,
		Loc:     loc,
	}
}

func (node *NumberedParametersNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *NumberedParametersNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *NumberedParametersNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "NumberedParametersNode",
		"maximum":  node.Maximum,
		"loc":      node.Loc,
	})
}

type NumberedReferenceReadNode struct {
	Number uint32
	Loc    *Location
}

func NewNumberedReferenceReadNode(number uint32, loc *Location) *NumberedReferenceReadNode {
	return &NumberedReferenceReadNode{
		Number: number,
		Loc:    loc,
	}
}

func (node *NumberedReferenceReadNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *NumberedReferenceReadNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *NumberedReferenceReadNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "NumberedReferenceReadNode",
		"number":   node.Number,
		"loc":      node.Loc,
	})
}

type OptionalKeywordParameterNode struct {
	Flags   ParameterFlags
	Name    string
	Nameloc *Location
	Value   Node
	Loc     *Location
}

func NewOptionalKeywordParameterNode(flags ParameterFlags, name string, nameLoc *Location, value Node, loc *Location) *OptionalKeywordParameterNode {
	return &OptionalKeywordParameterNode{
		Flags:   flags,
		Name:    name,
		Nameloc: nameLoc,
		Value:   value,
		Loc:     loc,
	}
}

func (node *OptionalKeywordParameterNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *OptionalKeywordParameterNode) IsRepeatedParameter() bool {
	return (node.Flags & PARAMETER_REPEATED_PARAMETER) != 0
}

func (node *OptionalKeywordParameterNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *OptionalKeywordParameterNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "OptionalKeywordParameterNode",
		"flags":    node.Flags,
		"name":     node.Name,
		"nameLoc":  node.Nameloc,
		"value":    node.Value,
		"loc":      node.Loc,
	})
}

type OptionalParameterNode struct {
	Flags       ParameterFlags
	Name        string
	Nameloc     *Location
	Operatorloc *Location
	Value       Node
	Loc         *Location
}

func NewOptionalParameterNode(flags ParameterFlags, name string, nameLoc *Location, operatorLoc *Location, value Node, loc *Location) *OptionalParameterNode {
	return &OptionalParameterNode{
		Flags:       flags,
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Value:       value,
		Loc:         loc,
	}
}

func (node *OptionalParameterNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *OptionalParameterNode) IsRepeatedParameter() bool {
	return (node.Flags & PARAMETER_REPEATED_PARAMETER) != 0
}

func (node *OptionalParameterNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Value)

	return children
}

func (node *OptionalParameterNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "OptionalParameterNode",
		"flags":       node.Flags,
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"value":       node.Value,
		"loc":         node.Loc,
	})
}

type OrNode struct {
	Left        Node
	Right       Node
	Operatorloc *Location
	Loc         *Location
}

func NewOrNode(left Node, right Node, operatorLoc *Location, loc *Location) *OrNode {
	return &OrNode{
		Left:        left,
		Right:       right,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *OrNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *OrNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Left)

	children = append(children, node.Right)

	return children
}

func (node *OrNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "OrNode",
		"left":        node.Left,
		"right":       node.Right,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type ParametersNode struct {
	Requireds   []Node
	Optionals   []Node
	Rest        Node
	Posts       []Node
	Keywords    []Node
	Keywordrest Node
	Block       *BlockParameterNode
	Loc         *Location
}

func NewParametersNode(requireds []Node, optionals []Node, rest Node, posts []Node, keywords []Node, keywordRest Node, block *BlockParameterNode, loc *Location) *ParametersNode {
	return &ParametersNode{
		Requireds:   requireds,
		Optionals:   optionals,
		Rest:        rest,
		Posts:       posts,
		Keywords:    keywords,
		Keywordrest: keywordRest,
		Block:       block,
		Loc:         loc,
	}
}

func (node *ParametersNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ParametersNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Requireds...)

	children = append(children, node.Optionals...)

	if node.Rest != nil {
		children = append(children, node.Rest)
	}

	children = append(children, node.Posts...)

	children = append(children, node.Keywords...)

	if node.Keywordrest != nil {
		children = append(children, node.Keywordrest)
	}

	if node.Block != nil {
		children = append(children, node.Block)
	}

	return children
}

func (node *ParametersNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "ParametersNode",
		"requireds":   node.Requireds,
		"optionals":   node.Optionals,
		"rest":        node.Rest,
		"posts":       node.Posts,
		"keywords":    node.Keywords,
		"keywordRest": node.Keywordrest,
		"block":       node.Block,
		"loc":         node.Loc,
	})
}

type ParenthesesNode struct {
	Body       Node
	Openingloc *Location
	Closingloc *Location
	Loc        *Location
}

func NewParenthesesNode(body Node, openingLoc *Location, closingLoc *Location, loc *Location) *ParenthesesNode {
	return &ParenthesesNode{
		Body:       body,
		Openingloc: openingLoc,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *ParenthesesNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ParenthesesNode) Children() []Node {
	children := make([]Node, 0)

	if node.Body != nil {
		children = append(children, node.Body)
	}

	return children
}

func (node *ParenthesesNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "ParenthesesNode",
		"body":       node.Body,
		"openingLoc": node.Openingloc,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type PinnedExpressionNode struct {
	Expression  Node
	Operatorloc *Location
	Lparenloc   *Location
	Rparenloc   *Location
	Loc         *Location
}

func NewPinnedExpressionNode(expression Node, operatorLoc *Location, lparenLoc *Location, rparenLoc *Location, loc *Location) *PinnedExpressionNode {
	return &PinnedExpressionNode{
		Expression:  expression,
		Operatorloc: operatorLoc,
		Lparenloc:   lparenLoc,
		Rparenloc:   rparenLoc,
		Loc:         loc,
	}
}

func (node *PinnedExpressionNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *PinnedExpressionNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Expression)

	return children
}

func (node *PinnedExpressionNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "PinnedExpressionNode",
		"expression":  node.Expression,
		"operatorLoc": node.Operatorloc,
		"lparenLoc":   node.Lparenloc,
		"rparenLoc":   node.Rparenloc,
		"loc":         node.Loc,
	})
}

type PinnedVariableNode struct {
	Variable    Node
	Operatorloc *Location
	Loc         *Location
}

func NewPinnedVariableNode(variable Node, operatorLoc *Location, loc *Location) *PinnedVariableNode {
	return &PinnedVariableNode{
		Variable:    variable,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *PinnedVariableNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *PinnedVariableNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Variable)

	return children
}

func (node *PinnedVariableNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "PinnedVariableNode",
		"variable":    node.Variable,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type PostExecutionNode struct {
	Statements *StatementsNode
	Keywordloc *Location
	Openingloc *Location
	Closingloc *Location
	Loc        *Location
}

func NewPostExecutionNode(statements *StatementsNode, keywordLoc *Location, openingLoc *Location, closingLoc *Location, loc *Location) *PostExecutionNode {
	return &PostExecutionNode{
		Statements: statements,
		Keywordloc: keywordLoc,
		Openingloc: openingLoc,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *PostExecutionNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *PostExecutionNode) Children() []Node {
	children := make([]Node, 0)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *PostExecutionNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "PostExecutionNode",
		"statements": node.Statements,
		"keywordLoc": node.Keywordloc,
		"openingLoc": node.Openingloc,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type PreExecutionNode struct {
	Statements *StatementsNode
	Keywordloc *Location
	Openingloc *Location
	Closingloc *Location
	Loc        *Location
}

func NewPreExecutionNode(statements *StatementsNode, keywordLoc *Location, openingLoc *Location, closingLoc *Location, loc *Location) *PreExecutionNode {
	return &PreExecutionNode{
		Statements: statements,
		Keywordloc: keywordLoc,
		Openingloc: openingLoc,
		Closingloc: closingLoc,
		Loc:        loc,
	}
}

func (node *PreExecutionNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *PreExecutionNode) Children() []Node {
	children := make([]Node, 0)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *PreExecutionNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "PreExecutionNode",
		"statements": node.Statements,
		"keywordLoc": node.Keywordloc,
		"openingLoc": node.Openingloc,
		"closingLoc": node.Closingloc,
		"loc":        node.Loc,
	})
}

type ProgramNode struct {
	Locals     []string
	Statements *StatementsNode
	Loc        *Location
}

func NewProgramNode(locals []string, statements *StatementsNode, loc *Location) *ProgramNode {
	return &ProgramNode{
		Locals:     locals,
		Statements: statements,
		Loc:        loc,
	}
}

func (node *ProgramNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ProgramNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Statements)

	return children
}

func (node *ProgramNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "ProgramNode",
		"locals":     node.Locals,
		"statements": node.Statements,
		"loc":        node.Loc,
	})
}

type RangeNode struct {
	Flags       RangeFlags
	Left        Node
	Right       Node
	Operatorloc *Location
	Loc         *Location
}

func NewRangeNode(flags RangeFlags, left Node, right Node, operatorLoc *Location, loc *Location) *RangeNode {
	return &RangeNode{
		Flags:       flags,
		Left:        left,
		Right:       right,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *RangeNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RangeNode) IsExcludeEnd() bool {
	return (node.Flags & RANGE_EXCLUDE_END) != 0
}

func (node *RangeNode) Children() []Node {
	children := make([]Node, 0)

	if node.Left != nil {
		children = append(children, node.Left)
	}

	if node.Right != nil {
		children = append(children, node.Right)
	}

	return children
}

func (node *RangeNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "RangeNode",
		"flags":       node.Flags,
		"left":        node.Left,
		"right":       node.Right,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type RationalNode struct {
	Numeric Node
	Loc     *Location
}

func NewRationalNode(numeric Node, loc *Location) *RationalNode {
	return &RationalNode{
		Numeric: numeric,
		Loc:     loc,
	}
}

func (node *RationalNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RationalNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Numeric)

	return children
}

func (node *RationalNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "RationalNode",
		"numeric":  node.Numeric,
		"loc":      node.Loc,
	})
}

type RedoNode struct {
	Loc *Location
}

func NewRedoNode(loc *Location) *RedoNode {
	return &RedoNode{
		Loc: loc,
	}
}

func (node *RedoNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RedoNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *RedoNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "RedoNode",
		"loc":      node.Loc,
	})
}

type RegularExpressionNode struct {
	Flags      RegularExpressionFlags
	Openingloc *Location
	Contentloc *Location
	Closingloc *Location
	Unescaped  string
	Loc        *Location
}

func NewRegularExpressionNode(flags RegularExpressionFlags, openingLoc *Location, contentLoc *Location, closingLoc *Location, unescaped string, loc *Location) *RegularExpressionNode {
	return &RegularExpressionNode{
		Flags:      flags,
		Openingloc: openingLoc,
		Contentloc: contentLoc,
		Closingloc: closingLoc,
		Unescaped:  unescaped,
		Loc:        loc,
	}
}

func (node *RegularExpressionNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RegularExpressionNode) IsIgnoreCase() bool {
	return (node.Flags & REGULAR_EXPRESSION_IGNORE_CASE) != 0
}

func (node *RegularExpressionNode) IsExtended() bool {
	return (node.Flags & REGULAR_EXPRESSION_EXTENDED) != 0
}

func (node *RegularExpressionNode) IsMultiLine() bool {
	return (node.Flags & REGULAR_EXPRESSION_MULTI_LINE) != 0
}

func (node *RegularExpressionNode) IsOnce() bool {
	return (node.Flags & REGULAR_EXPRESSION_ONCE) != 0
}

func (node *RegularExpressionNode) IsEucJp() bool {
	return (node.Flags & REGULAR_EXPRESSION_EUC_JP) != 0
}

func (node *RegularExpressionNode) IsAscii8bit() bool {
	return (node.Flags & REGULAR_EXPRESSION_ASCII_8BIT) != 0
}

func (node *RegularExpressionNode) IsWindows31j() bool {
	return (node.Flags & REGULAR_EXPRESSION_WINDOWS_31J) != 0
}

func (node *RegularExpressionNode) IsUtf8() bool {
	return (node.Flags & REGULAR_EXPRESSION_UTF_8) != 0
}

func (node *RegularExpressionNode) IsForcedUtf8Encoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_UTF8_ENCODING) != 0
}

func (node *RegularExpressionNode) IsForcedBinaryEncoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_BINARY_ENCODING) != 0
}

func (node *RegularExpressionNode) IsForcedUsAsciiEncoding() bool {
	return (node.Flags & REGULAR_EXPRESSION_FORCED_US_ASCII_ENCODING) != 0
}

func (node *RegularExpressionNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *RegularExpressionNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "RegularExpressionNode",
		"flags":      node.Flags,
		"openingLoc": node.Openingloc,
		"contentLoc": node.Contentloc,
		"closingLoc": node.Closingloc,
		"unescaped":  node.Unescaped,
		"loc":        node.Loc,
	})
}

type RequiredKeywordParameterNode struct {
	Flags   ParameterFlags
	Name    string
	Nameloc *Location
	Loc     *Location
}

func NewRequiredKeywordParameterNode(flags ParameterFlags, name string, nameLoc *Location, loc *Location) *RequiredKeywordParameterNode {
	return &RequiredKeywordParameterNode{
		Flags:   flags,
		Name:    name,
		Nameloc: nameLoc,
		Loc:     loc,
	}
}

func (node *RequiredKeywordParameterNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RequiredKeywordParameterNode) IsRepeatedParameter() bool {
	return (node.Flags & PARAMETER_REPEATED_PARAMETER) != 0
}

func (node *RequiredKeywordParameterNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *RequiredKeywordParameterNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "RequiredKeywordParameterNode",
		"flags":    node.Flags,
		"name":     node.Name,
		"nameLoc":  node.Nameloc,
		"loc":      node.Loc,
	})
}

type RequiredParameterNode struct {
	Flags ParameterFlags
	Name  string
	Loc   *Location
}

func NewRequiredParameterNode(flags ParameterFlags, name string, loc *Location) *RequiredParameterNode {
	return &RequiredParameterNode{
		Flags: flags,
		Name:  name,
		Loc:   loc,
	}
}

func (node *RequiredParameterNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RequiredParameterNode) IsRepeatedParameter() bool {
	return (node.Flags & PARAMETER_REPEATED_PARAMETER) != 0
}

func (node *RequiredParameterNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *RequiredParameterNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "RequiredParameterNode",
		"flags":    node.Flags,
		"name":     node.Name,
		"loc":      node.Loc,
	})
}

type RescueModifierNode struct {
	Expression       Node
	Keywordloc       *Location
	Rescueexpression Node
	Loc              *Location
}

func NewRescueModifierNode(expression Node, keywordLoc *Location, rescueExpression Node, loc *Location) *RescueModifierNode {
	return &RescueModifierNode{
		Expression:       expression,
		Keywordloc:       keywordLoc,
		Rescueexpression: rescueExpression,
		Loc:              loc,
	}
}

func (node *RescueModifierNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RescueModifierNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Expression)

	children = append(children, node.Rescueexpression)

	return children
}

func (node *RescueModifierNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":         "RescueModifierNode",
		"expression":       node.Expression,
		"keywordLoc":       node.Keywordloc,
		"rescueExpression": node.Rescueexpression,
		"loc":              node.Loc,
	})
}

type RescueNode struct {
	Keywordloc  *Location
	Exceptions  []Node
	Operatorloc *Location
	Reference   Node
	Statements  *StatementsNode
	Consequent  *RescueNode
	Loc         *Location
}

func NewRescueNode(keywordLoc *Location, exceptions []Node, operatorLoc *Location, reference Node, statements *StatementsNode, consequent *RescueNode, loc *Location) *RescueNode {
	return &RescueNode{
		Keywordloc:  keywordLoc,
		Exceptions:  exceptions,
		Operatorloc: operatorLoc,
		Reference:   reference,
		Statements:  statements,
		Consequent:  consequent,
		Loc:         loc,
	}
}

func (node *RescueNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RescueNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Exceptions...)

	if node.Reference != nil {
		children = append(children, node.Reference)
	}

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	if node.Consequent != nil {
		children = append(children, node.Consequent)
	}

	return children
}

func (node *RescueNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "RescueNode",
		"keywordLoc":  node.Keywordloc,
		"exceptions":  node.Exceptions,
		"operatorLoc": node.Operatorloc,
		"reference":   node.Reference,
		"statements":  node.Statements,
		"consequent":  node.Consequent,
		"loc":         node.Loc,
	})
}

type RestParameterNode struct {
	Flags       ParameterFlags
	Name        *string
	Nameloc     *Location
	Operatorloc *Location
	Loc         *Location
}

func NewRestParameterNode(flags ParameterFlags, name *string, nameLoc *Location, operatorLoc *Location, loc *Location) *RestParameterNode {
	return &RestParameterNode{
		Flags:       flags,
		Name:        name,
		Nameloc:     nameLoc,
		Operatorloc: operatorLoc,
		Loc:         loc,
	}
}

func (node *RestParameterNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RestParameterNode) IsRepeatedParameter() bool {
	return (node.Flags & PARAMETER_REPEATED_PARAMETER) != 0
}

func (node *RestParameterNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *RestParameterNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "RestParameterNode",
		"flags":       node.Flags,
		"name":        node.Name,
		"nameLoc":     node.Nameloc,
		"operatorLoc": node.Operatorloc,
		"loc":         node.Loc,
	})
}

type RetryNode struct {
	Loc *Location
}

func NewRetryNode(loc *Location) *RetryNode {
	return &RetryNode{
		Loc: loc,
	}
}

func (node *RetryNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *RetryNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *RetryNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "RetryNode",
		"loc":      node.Loc,
	})
}

type ReturnNode struct {
	Keywordloc *Location
	Arguments  *ArgumentsNode
	Loc        *Location
}

func NewReturnNode(keywordLoc *Location, arguments *ArgumentsNode, loc *Location) *ReturnNode {
	return &ReturnNode{
		Keywordloc: keywordLoc,
		Arguments:  arguments,
		Loc:        loc,
	}
}

func (node *ReturnNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *ReturnNode) Children() []Node {
	children := make([]Node, 0)

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	return children
}

func (node *ReturnNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "ReturnNode",
		"keywordLoc": node.Keywordloc,
		"arguments":  node.Arguments,
		"loc":        node.Loc,
	})
}

type SelfNode struct {
	Loc *Location
}

func NewSelfNode(loc *Location) *SelfNode {
	return &SelfNode{
		Loc: loc,
	}
}

func (node *SelfNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *SelfNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *SelfNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "SelfNode",
		"loc":      node.Loc,
	})
}

type SingletonClassNode struct {
	Locals          []string
	Classkeywordloc *Location
	Operatorloc     *Location
	Expression      Node
	Body            Node
	Endkeywordloc   *Location
	Loc             *Location
}

func NewSingletonClassNode(locals []string, classKeywordLoc *Location, operatorLoc *Location, expression Node, body Node, endKeywordLoc *Location, loc *Location) *SingletonClassNode {
	return &SingletonClassNode{
		Locals:          locals,
		Classkeywordloc: classKeywordLoc,
		Operatorloc:     operatorLoc,
		Expression:      expression,
		Body:            body,
		Endkeywordloc:   endKeywordLoc,
		Loc:             loc,
	}
}

func (node *SingletonClassNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *SingletonClassNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Expression)

	if node.Body != nil {
		children = append(children, node.Body)
	}

	return children
}

func (node *SingletonClassNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":        "SingletonClassNode",
		"locals":          node.Locals,
		"classKeywordLoc": node.Classkeywordloc,
		"operatorLoc":     node.Operatorloc,
		"expression":      node.Expression,
		"body":            node.Body,
		"endKeywordLoc":   node.Endkeywordloc,
		"loc":             node.Loc,
	})
}

type SourceEncodingNode struct {
	Loc *Location
}

func NewSourceEncodingNode(loc *Location) *SourceEncodingNode {
	return &SourceEncodingNode{
		Loc: loc,
	}
}

func (node *SourceEncodingNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *SourceEncodingNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *SourceEncodingNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "SourceEncodingNode",
		"loc":      node.Loc,
	})
}

type SourceFileNode struct {
	Filepath string
	Loc      *Location
}

func NewSourceFileNode(filepath string, loc *Location) *SourceFileNode {
	return &SourceFileNode{
		Filepath: filepath,
		Loc:      loc,
	}
}

func (node *SourceFileNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *SourceFileNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *SourceFileNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "SourceFileNode",
		"filepath": node.Filepath,
		"loc":      node.Loc,
	})
}

type SourceLineNode struct {
	Loc *Location
}

func NewSourceLineNode(loc *Location) *SourceLineNode {
	return &SourceLineNode{
		Loc: loc,
	}
}

func (node *SourceLineNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *SourceLineNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *SourceLineNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "SourceLineNode",
		"loc":      node.Loc,
	})
}

type SplatNode struct {
	Operatorloc *Location
	Expression  Node
	Loc         *Location
}

func NewSplatNode(operatorLoc *Location, expression Node, loc *Location) *SplatNode {
	return &SplatNode{
		Operatorloc: operatorLoc,
		Expression:  expression,
		Loc:         loc,
	}
}

func (node *SplatNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *SplatNode) Children() []Node {
	children := make([]Node, 0)

	if node.Expression != nil {
		children = append(children, node.Expression)
	}

	return children
}

func (node *SplatNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":    "SplatNode",
		"operatorLoc": node.Operatorloc,
		"expression":  node.Expression,
		"loc":         node.Loc,
	})
}

type StatementsNode struct {
	Body []Node
	Loc  *Location
}

func NewStatementsNode(body []Node, loc *Location) *StatementsNode {
	return &StatementsNode{
		Body: body,
		Loc:  loc,
	}
}

func (node *StatementsNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *StatementsNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Body...)

	return children
}

func (node *StatementsNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "StatementsNode",
		"body":     node.Body,
		"loc":      node.Loc,
	})
}

type StringNode struct {
	Flags      StringFlags
	Openingloc *Location
	Contentloc *Location
	Closingloc *Location
	Unescaped  string
	Loc        *Location
}

func NewStringNode(flags StringFlags, openingLoc *Location, contentLoc *Location, closingLoc *Location, unescaped string, loc *Location) *StringNode {
	return &StringNode{
		Flags:      flags,
		Openingloc: openingLoc,
		Contentloc: contentLoc,
		Closingloc: closingLoc,
		Unescaped:  unescaped,
		Loc:        loc,
	}
}

func (node *StringNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *StringNode) IsForcedUtf8Encoding() bool {
	return (node.Flags & STRING_FORCED_UTF8_ENCODING) != 0
}

func (node *StringNode) IsForcedBinaryEncoding() bool {
	return (node.Flags & STRING_FORCED_BINARY_ENCODING) != 0
}

func (node *StringNode) IsFrozen() bool {
	return (node.Flags & STRING_FROZEN) != 0
}

func (node *StringNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *StringNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "StringNode",
		"flags":      node.Flags,
		"openingLoc": node.Openingloc,
		"contentLoc": node.Contentloc,
		"closingLoc": node.Closingloc,
		"unescaped":  node.Unescaped,
		"loc":        node.Loc,
	})
}

type SuperNode struct {
	Keywordloc *Location
	Lparenloc  *Location
	Arguments  *ArgumentsNode
	Rparenloc  *Location
	Block      Node
	Loc        *Location
}

func NewSuperNode(keywordLoc *Location, lparenLoc *Location, arguments *ArgumentsNode, rparenLoc *Location, block Node, loc *Location) *SuperNode {
	return &SuperNode{
		Keywordloc: keywordLoc,
		Lparenloc:  lparenLoc,
		Arguments:  arguments,
		Rparenloc:  rparenLoc,
		Block:      block,
		Loc:        loc,
	}
}

func (node *SuperNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *SuperNode) Children() []Node {
	children := make([]Node, 0)

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	if node.Block != nil {
		children = append(children, node.Block)
	}

	return children
}

func (node *SuperNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "SuperNode",
		"keywordLoc": node.Keywordloc,
		"lparenLoc":  node.Lparenloc,
		"arguments":  node.Arguments,
		"rparenLoc":  node.Rparenloc,
		"block":      node.Block,
		"loc":        node.Loc,
	})
}

type SymbolNode struct {
	Flags      SymbolFlags
	Openingloc *Location
	Valueloc   *Location
	Closingloc *Location
	Unescaped  string
	Loc        *Location
}

func NewSymbolNode(flags SymbolFlags, openingLoc *Location, valueLoc *Location, closingLoc *Location, unescaped string, loc *Location) *SymbolNode {
	return &SymbolNode{
		Flags:      flags,
		Openingloc: openingLoc,
		Valueloc:   valueLoc,
		Closingloc: closingLoc,
		Unescaped:  unescaped,
		Loc:        loc,
	}
}

func (node *SymbolNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *SymbolNode) IsForcedUtf8Encoding() bool {
	return (node.Flags & SYMBOL_FORCED_UTF8_ENCODING) != 0
}

func (node *SymbolNode) IsForcedBinaryEncoding() bool {
	return (node.Flags & SYMBOL_FORCED_BINARY_ENCODING) != 0
}

func (node *SymbolNode) IsForcedUsAsciiEncoding() bool {
	return (node.Flags & SYMBOL_FORCED_US_ASCII_ENCODING) != 0
}

func (node *SymbolNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *SymbolNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "SymbolNode",
		"flags":      node.Flags,
		"openingLoc": node.Openingloc,
		"valueLoc":   node.Valueloc,
		"closingLoc": node.Closingloc,
		"unescaped":  node.Unescaped,
		"loc":        node.Loc,
	})
}

type TrueNode struct {
	Loc *Location
}

func NewTrueNode(loc *Location) *TrueNode {
	return &TrueNode{
		Loc: loc,
	}
}

func (node *TrueNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *TrueNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *TrueNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName": "TrueNode",
		"loc":      node.Loc,
	})
}

type UndefNode struct {
	Names      []Node
	Keywordloc *Location
	Loc        *Location
}

func NewUndefNode(names []Node, keywordLoc *Location, loc *Location) *UndefNode {
	return &UndefNode{
		Names:      names,
		Keywordloc: keywordLoc,
		Loc:        loc,
	}
}

func (node *UndefNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *UndefNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Names...)

	return children
}

func (node *UndefNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "UndefNode",
		"names":      node.Names,
		"keywordLoc": node.Keywordloc,
		"loc":        node.Loc,
	})
}

type UnlessNode struct {
	Keywordloc     *Location
	Predicate      Node
	Thenkeywordloc *Location
	Statements     *StatementsNode
	Consequent     *ElseNode
	Endkeywordloc  *Location
	Loc            *Location
}

func NewUnlessNode(keywordLoc *Location, predicate Node, thenKeywordLoc *Location, statements *StatementsNode, consequent *ElseNode, endKeywordLoc *Location, loc *Location) *UnlessNode {
	return &UnlessNode{
		Keywordloc:     keywordLoc,
		Predicate:      predicate,
		Thenkeywordloc: thenKeywordLoc,
		Statements:     statements,
		Consequent:     consequent,
		Endkeywordloc:  endKeywordLoc,
		Loc:            loc,
	}
}

func (node *UnlessNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *UnlessNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Predicate)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	if node.Consequent != nil {
		children = append(children, node.Consequent)
	}

	return children
}

func (node *UnlessNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":       "UnlessNode",
		"keywordLoc":     node.Keywordloc,
		"predicate":      node.Predicate,
		"thenKeywordLoc": node.Thenkeywordloc,
		"statements":     node.Statements,
		"consequent":     node.Consequent,
		"endKeywordLoc":  node.Endkeywordloc,
		"loc":            node.Loc,
	})
}

type UntilNode struct {
	Flags      LoopFlags
	Keywordloc *Location
	Closingloc *Location
	Predicate  Node
	Statements *StatementsNode
	Loc        *Location
}

func NewUntilNode(flags LoopFlags, keywordLoc *Location, closingLoc *Location, predicate Node, statements *StatementsNode, loc *Location) *UntilNode {
	return &UntilNode{
		Flags:      flags,
		Keywordloc: keywordLoc,
		Closingloc: closingLoc,
		Predicate:  predicate,
		Statements: statements,
		Loc:        loc,
	}
}

func (node *UntilNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *UntilNode) IsBeginModifier() bool {
	return (node.Flags & LOOP_BEGIN_MODIFIER) != 0
}

func (node *UntilNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Predicate)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *UntilNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "UntilNode",
		"flags":      node.Flags,
		"keywordLoc": node.Keywordloc,
		"closingLoc": node.Closingloc,
		"predicate":  node.Predicate,
		"statements": node.Statements,
		"loc":        node.Loc,
	})
}

type WhenNode struct {
	Keywordloc     *Location
	Conditions     []Node
	Thenkeywordloc *Location
	Statements     *StatementsNode
	Loc            *Location
}

func NewWhenNode(keywordLoc *Location, conditions []Node, thenKeywordLoc *Location, statements *StatementsNode, loc *Location) *WhenNode {
	return &WhenNode{
		Keywordloc:     keywordLoc,
		Conditions:     conditions,
		Thenkeywordloc: thenKeywordLoc,
		Statements:     statements,
		Loc:            loc,
	}
}

func (node *WhenNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *WhenNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Conditions...)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *WhenNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":       "WhenNode",
		"keywordLoc":     node.Keywordloc,
		"conditions":     node.Conditions,
		"thenKeywordLoc": node.Thenkeywordloc,
		"statements":     node.Statements,
		"loc":            node.Loc,
	})
}

type WhileNode struct {
	Flags      LoopFlags
	Keywordloc *Location
	Closingloc *Location
	Predicate  Node
	Statements *StatementsNode
	Loc        *Location
}

func NewWhileNode(flags LoopFlags, keywordLoc *Location, closingLoc *Location, predicate Node, statements *StatementsNode, loc *Location) *WhileNode {
	return &WhileNode{
		Flags:      flags,
		Keywordloc: keywordLoc,
		Closingloc: closingLoc,
		Predicate:  predicate,
		Statements: statements,
		Loc:        loc,
	}
}

func (node *WhileNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *WhileNode) IsBeginModifier() bool {
	return (node.Flags & LOOP_BEGIN_MODIFIER) != 0
}

func (node *WhileNode) Children() []Node {
	children := make([]Node, 0)

	children = append(children, node.Predicate)

	if node.Statements != nil {
		children = append(children, node.Statements)
	}

	return children
}

func (node *WhileNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "WhileNode",
		"flags":      node.Flags,
		"keywordLoc": node.Keywordloc,
		"closingLoc": node.Closingloc,
		"predicate":  node.Predicate,
		"statements": node.Statements,
		"loc":        node.Loc,
	})
}

type XStringNode struct {
	Flags      EncodingFlags
	Openingloc *Location
	Contentloc *Location
	Closingloc *Location
	Unescaped  string
	Loc        *Location
}

func NewXStringNode(flags EncodingFlags, openingLoc *Location, contentLoc *Location, closingLoc *Location, unescaped string, loc *Location) *XStringNode {
	return &XStringNode{
		Flags:      flags,
		Openingloc: openingLoc,
		Contentloc: contentLoc,
		Closingloc: closingLoc,
		Unescaped:  unescaped,
		Loc:        loc,
	}
}

func (node *XStringNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *XStringNode) IsForcedUtf8Encoding() bool {
	return (node.Flags & ENCODING_FORCED_UTF8_ENCODING) != 0
}

func (node *XStringNode) IsForcedBinaryEncoding() bool {
	return (node.Flags & ENCODING_FORCED_BINARY_ENCODING) != 0
}

func (node *XStringNode) Children() []Node {
	children := make([]Node, 0)

	return children
}

func (node *XStringNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "XStringNode",
		"flags":      node.Flags,
		"openingLoc": node.Openingloc,
		"contentLoc": node.Contentloc,
		"closingLoc": node.Closingloc,
		"unescaped":  node.Unescaped,
		"loc":        node.Loc,
	})
}

type YieldNode struct {
	Keywordloc *Location
	Lparenloc  *Location
	Arguments  *ArgumentsNode
	Rparenloc  *Location
	Loc        *Location
}

func NewYieldNode(keywordLoc *Location, lparenLoc *Location, arguments *ArgumentsNode, rparenLoc *Location, loc *Location) *YieldNode {
	return &YieldNode{
		Keywordloc: keywordLoc,
		Lparenloc:  lparenLoc,
		Arguments:  arguments,
		Rparenloc:  rparenLoc,
		Loc:        loc,
	}
}

func (node *YieldNode) Accept(visitor NodeVisitor) {
	visitor.Visit(node)
}

func (node *YieldNode) Children() []Node {
	children := make([]Node, 0)

	if node.Arguments != nil {
		children = append(children, node.Arguments)
	}

	return children
}

func (node *YieldNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(map[string]interface{}{
		"nodeName":   "YieldNode",
		"keywordLoc": node.Keywordloc,
		"lparenLoc":  node.Lparenloc,
		"arguments":  node.Arguments,
		"rparenLoc":  node.Rparenloc,
		"loc":        node.Loc,
	})
}
