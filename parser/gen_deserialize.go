/*----------------------------------------------------------------------------*/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/../../templates/gen_deserialize.go.erb                           */
/* if you are looking to modify the                                           */
/* template                                                                   */
/*----------------------------------------------------------------------------*/

package parser

import (
	"encoding/binary"
	"errors"
	"fmt"
	"math/big"
	"unicode/utf8"
	"unsafe"
)

const (
	majorVersion = 1
	minorVersion = 4
	patchVersion = 0
)

// Comment represents a comment in the source code.
type Comment struct {
	Type     int      `json:"type"`
	Location Location `json:"location"`
}

// MagicComment represents a magic comment in the source code.
type MagicComment struct {
	StartLocation Location `json:"startLocation"`
	EndLocation   Location `json:"endLocation"`
}

// ParseError represents an error in the source code.
type ParseError struct {
	Type     string   `json:"type"`
	Message  string   `json:"message"`
	Location Location `json:"location"`
	Level    string   `json:"level"`
}

// ParseWarning represents a warning in the source code.
type ParseWarning struct {
	Type     string   `json:"type"`
	Message  string   `json:"message"`
	Location Location `json:"location"`
	Level    string   `json:"level"`
}

// ParseResult represents the result of parsing the source code.
type ParseResult struct {
	Value         *ProgramNode   `json:"value"`
	Comments      []Comment      `json:"comments"`
	MagicComments []MagicComment `json:"magicComments"`
	DataLoc       *Location      `json:"dataLoc"`
	Errors        []ParseError   `json:"errors"`
	Warnings      []ParseWarning `json:"warnings"`
}

// SerializationBuffer handles reading from the serialized binary format.
type SerializationBuffer struct {
	source       []byte
	array        []byte
	index        int
	fileEncoding string
}

// Constants for string encoding flags
const (
	forcedUTF8EncodingFlag   = 1 << 2
	forcedBinaryEncodingFlag = 1 << 3
)

// NewSerializationBuffer creates a new SerializationBuffer.
func NewSerializationBuffer(source, array []byte) *SerializationBuffer {
	return &SerializationBuffer{
		source:       source,
		array:        array,
		index:        0,
		fileEncoding: "utf-8",
	}
}

// ReadRawByte reads a single byte from the buffer.
func (b *SerializationBuffer) ReadRawByte() byte {
	result := b.array[b.index]
	b.index++
	return result
}

// ReadRawBytes reads the specified number of bytes from the buffer.
func (b *SerializationBuffer) ReadRawBytes(length int) []byte {
	result := b.array[b.index : b.index+length]
	b.index += length
	return result
}

// ReadString reads a string of the specified length with encoding flags.
func (b *SerializationBuffer) ReadString(length int, flags uint32) string {
	return b.decodeString(b.ReadRawBytes(length), flags).Value
}

// ReadUint32 reads a 32-bit unsigned integer in little-endian format.
func (b *SerializationBuffer) ReadUint32() uint32 {
	result := b.scanUint32(b.index)
	b.index += 4
	return result
}

// ScanUint32 scans a 32-bit unsigned integer at the specified offset.
func (b *SerializationBuffer) scanUint32(offset int) uint32 {
	bytes := b.array[offset : offset+4]
	return binary.LittleEndian.Uint32(bytes)
}

// ReadVarInt reads a variable-length integer.
func (b *SerializationBuffer) ReadVarInt() int {
	var result int
	var shift uint

	for {
		byteVal := b.ReadRawByte()
		result += int(byteVal&0x7f) << shift
		shift += 7

		if (byteVal & 0x80) == 0 {
			break
		}
	}

	return result
}

// ReadLocation reads a location from the buffer.
func (b *SerializationBuffer) ReadLocation() Location {
	return Location{
		StartOffset: b.ReadVarInt(),
		Length:      b.ReadVarInt(),
	}
}

// ReadOptionalLocation reads an optional location from the buffer.
func (b *SerializationBuffer) ReadOptionalLocation() *Location {
	if b.ReadRawByte() != 0 {
		loc := b.ReadLocation()
		return &loc
	}
	return nil
}

// ReadStringField reads a string field with encoding flags.
func (b *SerializationBuffer) ReadStringField(flags uint32) RubyString {
	stringType := b.ReadRawByte()

	switch stringType {
	case 1:
		startOffset := b.ReadVarInt()
		length := b.ReadVarInt()
		return b.decodeString(b.source[startOffset:startOffset+length], flags)
	case 2:
		length := b.ReadVarInt()
		return b.decodeString(b.ReadRawBytes(length), flags)
	default:
		panic(fmt.Sprintf("Unknown serialized string type: %d", stringType))
	}
}

// ScanConstant scans a constant from the constant pool.
func (b *SerializationBuffer) ScanConstant(constantPoolOffset int, constantIndex int) string {
	offset := constantPoolOffset + constantIndex*8
	startOffset := int(b.scanUint32(offset))
	length := int(b.scanUint32(offset + 4))

	if startOffset&(1<<31) != 0 {
		startOffset &= (1 << 31) - 1
		return string(b.array[startOffset : startOffset+length])
	} else {
		return string(b.source[startOffset : startOffset+length])
	}
}

// ReadDouble reads a double-precision floating point number.
func (b *SerializationBuffer) ReadDouble() float64 {
	bytes := b.ReadRawBytes(8)
	bits := binary.LittleEndian.Uint64(bytes)
	return *(*float64)(unsafe.Pointer(&bits))
}

// decodeString decodes a byte slice into a RubyString based on encoding flags.
func (b *SerializationBuffer) decodeString(bytes []byte, flags uint32) RubyString {
	forcedBin := (flags & forcedBinaryEncodingFlag) != 0
	forcedUtf8 := (flags & forcedUTF8EncodingFlag) != 0

	if forcedBin {
		return RubyString{
			Encoding:      "ascii",
			ValidEncoding: true,
			Value:         string(bytes),
		}
	}

	encoding := b.fileEncoding
	if forcedUtf8 {
		encoding = "utf-8"
	}

	if encoding == "utf-8" {
		if utf8.Valid(bytes) {
			return RubyString{
				Encoding:      encoding,
				ValidEncoding: true,
				Value:         string(bytes),
			}
		} else {
			return RubyString{
				Encoding:      encoding,
				ValidEncoding: false,
				Value:         string(bytes),
			}
		}
	}

	// For other encodings, assume they're valid for now
	return RubyString{
		Encoding:      encoding,
		ValidEncoding: true,
		Value:         string(bytes),
	}
}

var errorLevels = []string{"syntax", "argument", "load"}
var errorTypes = []string{
	"alias_argument",
	"alias_argument_numbered_reference",
	"ampampeq_multi_assign",
	"argument_after_block",
	"argument_after_forwarding_ellipses",
	"argument_bare_hash",
	"argument_block_forwarding",
	"argument_block_multi",
	"argument_conflict_ampersand",
	"argument_conflict_star",
	"argument_conflict_star_star",
	"argument_formal_class",
	"argument_formal_constant",
	"argument_formal_global",
	"argument_formal_ivar",
	"argument_forwarding_unbound",
	"argument_no_forwarding_ampersand",
	"argument_no_forwarding_ellipses",
	"argument_no_forwarding_star",
	"argument_no_forwarding_star_star",
	"argument_splat_after_assoc_splat",
	"argument_splat_after_splat",
	"argument_term_paren",
	"argument_unexpected_block",
	"array_element",
	"array_expression",
	"array_expression_after_star",
	"array_separator",
	"array_term",
	"begin_lonely_else",
	"begin_term",
	"begin_upcase_brace",
	"begin_upcase_term",
	"begin_upcase_toplevel",
	"block_param_local_variable",
	"block_param_pipe_term",
	"block_term_brace",
	"block_term_end",
	"cannot_parse_expression",
	"cannot_parse_string_part",
	"case_expression_after_case",
	"case_expression_after_when",
	"case_match_missing_predicate",
	"case_missing_conditions",
	"case_term",
	"class_in_method",
	"class_name",
	"class_superclass",
	"class_term",
	"class_unexpected_end",
	"class_variable_bare",
	"conditional_elsif_predicate",
	"conditional_if_predicate",
	"conditional_predicate_term",
	"conditional_term",
	"conditional_term_else",
	"conditional_unless_predicate",
	"conditional_until_predicate",
	"conditional_while_predicate",
	"constant_path_colon_colon_constant",
	"def_endless",
	"def_endless_setter",
	"def_name",
	"def_params_term",
	"def_params_term_paren",
	"def_receiver",
	"def_receiver_term",
	"def_term",
	"defined_expression",
	"embdoc_term",
	"embexpr_end",
	"embvar_invalid",
	"end_upcase_brace",
	"end_upcase_term",
	"escape_invalid_control",
	"escape_invalid_control_repeat",
	"escape_invalid_hexadecimal",
	"escape_invalid_meta",
	"escape_invalid_meta_repeat",
	"escape_invalid_unicode",
	"escape_invalid_unicode_cm_flags",
	"escape_invalid_unicode_list",
	"escape_invalid_unicode_literal",
	"escape_invalid_unicode_long",
	"escape_invalid_unicode_short",
	"escape_invalid_unicode_term",
	"expect_argument",
	"expect_eol_after_statement",
	"expect_expression_after_ampampeq",
	"expect_expression_after_comma",
	"expect_expression_after_equal",
	"expect_expression_after_less_less",
	"expect_expression_after_lparen",
	"expect_expression_after_operator",
	"expect_expression_after_pipepipeeq",
	"expect_expression_after_question",
	"expect_expression_after_splat",
	"expect_expression_after_splat_hash",
	"expect_expression_after_star",
	"expect_for_delimiter",
	"expect_ident_req_parameter",
	"expect_in_delimiter",
	"expect_lparen_req_parameter",
	"expect_message",
	"expect_rbracket",
	"expect_rparen",
	"expect_rparen_after_multi",
	"expect_rparen_req_parameter",
	"expect_singleton_class_delimiter",
	"expect_string_content",
	"expect_when_delimiter",
	"expression_bare_hash",
	"expression_not_writable",
	"expression_not_writable_encoding",
	"expression_not_writable_false",
	"expression_not_writable_file",
	"expression_not_writable_line",
	"expression_not_writable_nil",
	"expression_not_writable_numbered",
	"expression_not_writable_self",
	"expression_not_writable_true",
	"float_parse",
	"for_collection",
	"for_in",
	"for_index",
	"for_term",
	"global_variable_bare",
	"hash_expression_after_label",
	"hash_key",
	"hash_rocket",
	"hash_term",
	"hash_value",
	"heredoc_identifier",
	"heredoc_term",
	"incomplete_question_mark",
	"incomplete_variable_class",
	"incomplete_variable_class_3_3",
	"incomplete_variable_instance",
	"incomplete_variable_instance_3_3",
	"instance_variable_bare",
	"invalid_block_exit",
	"invalid_character",
	"invalid_comma",
	"invalid_encoding_magic_comment",
	"invalid_escape_character",
	"invalid_float_exponent",
	"invalid_local_variable_read",
	"invalid_local_variable_write",
	"invalid_multibyte_char",
	"invalid_multibyte_character",
	"invalid_multibyte_escape",
	"invalid_number_binary",
	"invalid_number_decimal",
	"invalid_number_fraction",
	"invalid_number_hexadecimal",
	"invalid_number_octal",
	"invalid_number_underscore_inner",
	"invalid_number_underscore_trailing",
	"invalid_percent",
	"invalid_percent_eof",
	"invalid_printable_character",
	"invalid_retry_after_else",
	"invalid_retry_after_ensure",
	"invalid_retry_without_rescue",
	"invalid_symbol",
	"invalid_variable_global",
	"invalid_variable_global_3_3",
	"invalid_yield",
	"it_not_allowed_numbered",
	"it_not_allowed_ordinary",
	"lambda_open",
	"lambda_term_brace",
	"lambda_term_end",
	"list_i_lower_element",
	"list_i_lower_term",
	"list_i_upper_element",
	"list_i_upper_term",
	"list_w_lower_element",
	"list_w_lower_term",
	"list_w_upper_element",
	"list_w_upper_term",
	"malloc_failed",
	"mixed_encoding",
	"module_in_method",
	"module_name",
	"module_term",
	"multi_assign_multi_splats",
	"multi_assign_unexpected_rest",
	"nesting_too_deep",
	"no_local_variable",
	"non_associative_operator",
	"not_expression",
	"number_literal_underscore",
	"numbered_parameter_inner_block",
	"numbered_parameter_it",
	"numbered_parameter_ordinary",
	"numbered_parameter_outer_block",
	"operator_multi_assign",
	"operator_write_arguments",
	"operator_write_block",
	"parameter_assoc_splat_multi",
	"parameter_block_multi",
	"parameter_circular",
	"parameter_forwarding_after_rest",
	"parameter_method_name",
	"parameter_name_duplicated",
	"parameter_no_default",
	"parameter_no_default_kw",
	"parameter_numbered_reserved",
	"parameter_order",
	"parameter_splat_multi",
	"parameter_star",
	"parameter_unexpected_fwd",
	"parameter_unexpected_no_kw",
	"parameter_wild_loose_comma",
	"pattern_array_multiple_rests",
	"pattern_capture_duplicate",
	"pattern_expression_after_bracket",
	"pattern_expression_after_comma",
	"pattern_expression_after_hrocket",
	"pattern_expression_after_in",
	"pattern_expression_after_key",
	"pattern_expression_after_paren",
	"pattern_expression_after_pin",
	"pattern_expression_after_pipe",
	"pattern_expression_after_range",
	"pattern_expression_after_rest",
	"pattern_find_missing_inner",
	"pattern_hash_implicit",
	"pattern_hash_key",
	"pattern_hash_key_duplicate",
	"pattern_hash_key_interpolated",
	"pattern_hash_key_label",
	"pattern_hash_key_locals",
	"pattern_ident_after_hrocket",
	"pattern_label_after_comma",
	"pattern_rest",
	"pattern_term_brace",
	"pattern_term_bracket",
	"pattern_term_paren",
	"pipepipeeq_multi_assign",
	"regexp_encoding_option_mismatch",
	"regexp_incompat_char_encoding",
	"regexp_invalid_unicode_range",
	"regexp_non_escaped_mbc",
	"regexp_parse_error",
	"regexp_term",
	"regexp_unknown_options",
	"regexp_utf8_char_non_utf8_regexp",
	"rescue_expression",
	"rescue_modifier_value",
	"rescue_term",
	"rescue_variable",
	"return_invalid",
	"script_not_found",
	"singleton_for_literals",
	"statement_alias",
	"statement_postexe_end",
	"statement_preexe_begin",
	"statement_undef",
	"string_concatenation",
	"string_interpolated_term",
	"string_literal_eof",
	"string_literal_term",
	"symbol_invalid",
	"symbol_term_dynamic",
	"symbol_term_interpolated",
	"ternary_colon",
	"ternary_expression_false",
	"ternary_expression_true",
	"unary_disallowed",
	"unary_receiver",
	"undef_argument",
	"unexpected_block_argument",
	"unexpected_index_block",
	"unexpected_index_keywords",
	"unexpected_label",
	"unexpected_multi_write",
	"unexpected_range_operator",
	"unexpected_safe_navigation",
	"unexpected_token_close_context",
	"unexpected_token_ignore",
	"until_term",
	"void_expression",
	"while_term",
	"write_target_in_method",
	"write_target_readonly",
	"write_target_unexpected",
	"xstring_term",
}

var warningLevels = []string{"default", "verbose"}
var warningTypes = []string{
	"ambiguous_binary_operator",
	"ambiguous_first_argument_minus",
	"ambiguous_first_argument_plus",
	"ambiguous_prefix_ampersand",
	"ambiguous_prefix_star",
	"ambiguous_prefix_star_star",
	"ambiguous_slash",
	"comparison_after_comparison",
	"dot_dot_dot_eol",
	"equal_in_conditional",
	"equal_in_conditional_3_3",
	"end_in_method",
	"duplicated_hash_key",
	"duplicated_when_clause",
	"float_out_of_range",
	"ignored_frozen_string_literal",
	"indentation_mismatch",
	"integer_in_flip_flop",
	"invalid_character",
	"invalid_magic_comment_value",
	"invalid_numbered_reference",
	"keyword_eol",
	"literal_in_condition_default",
	"literal_in_condition_verbose",
	"shareable_constant_value_line",
	"shebang_carriage_return",
	"unexpected_carriage_return",
	"unreachable_statement",
	"unused_local_variable",
	"void_statement",
}

// Deserialize accepts two byte slices, one for the source and one for the serialized format.
// Returns the AST corresponding to the serialized form.
func Deserialize(source, array []byte) (*ParseResult, error) {
	buffer := NewSerializationBuffer(source, array)

	// Check magic header
	if buffer.ReadString(5, 0) != "PRISM" {
		return nil, errors.New("invalid serialization")
	}

	// Check version
	if buffer.ReadRawByte() != majorVersion || buffer.ReadRawByte() != minorVersion || buffer.ReadRawByte() != patchVersion {
		return nil, errors.New("invalid serialization")
	}

	// Check location fields flag
	if buffer.ReadRawByte() != 0 {
		return nil, errors.New("invalid serialization (location fields must be included but are not)")
	}

	// Read file encoding
	encodingLength := buffer.ReadVarInt()
	buffer.fileEncoding = buffer.ReadString(encodingLength, 0)

	// Skip start line
	buffer.ReadVarInt()

	// Skip line offsets
	lineOffsetsCount := buffer.ReadVarInt()
	for i := 0; i < lineOffsetsCount; i++ {
		buffer.ReadVarInt()
	}

	// Read comments
	commentsCount := buffer.ReadVarInt()
	comments := make([]Comment, commentsCount)
	for i := 0; i < commentsCount; i++ {
		comments[i] = Comment{
			Type:     buffer.ReadVarInt(),
			Location: buffer.ReadLocation(),
		}
	}

	// Read magic comments
	magicCommentsCount := buffer.ReadVarInt()
	magicComments := make([]MagicComment, magicCommentsCount)
	for i := 0; i < magicCommentsCount; i++ {
		magicComments[i] = MagicComment{
			StartLocation: buffer.ReadLocation(),
			EndLocation:   buffer.ReadLocation(),
		}
	}

	// Read data location
	dataLoc := buffer.ReadOptionalLocation()

	// Read errors
	errorsCount := buffer.ReadVarInt()
	errors := make([]ParseError, errorsCount)
	for i := 0; i < errorsCount; i++ {
		eType := buffer.ReadVarInt()
		messageLength := buffer.ReadVarInt()
		message := buffer.ReadString(messageLength, 0)
		location := buffer.ReadLocation()
		level := buffer.ReadRawByte()

		var errorType string
		if eType >= 0 && eType < len(errorTypes) {
			errorType = errorTypes[eType]
		} else {
			errorType = "unknown"
		}

		errors[i] = ParseError{
			Type:     errorType,
			Message:  message,
			Location: location,
			Level:    errorLevels[level],
		}
	}

	// Read warnings
	warningsCount := buffer.ReadVarInt()
	warnings := make([]ParseWarning, warningsCount)
	for i := 0; i < warningsCount; i++ {
		wType := buffer.ReadVarInt()
		messageLength := buffer.ReadVarInt()
		message := buffer.ReadString(messageLength, 0)
		location := buffer.ReadLocation()
		level := buffer.ReadRawByte()

		var warningType string
		if wType >= 0 && wType < len(warningTypes) {
			warningType = warningTypes[wType]
		} else {
			warningType = "unknown"
		}

		warnings[i] = ParseWarning{
			Type:     warningType,
			Message:  message,
			Location: location,
			Level:    warningLevels[level],
		}
	}

	constantPoolOffset := int(buffer.ReadUint32())
	constantsCount := buffer.ReadVarInt()
	constants := make([]*string, constantsCount)

	readRequiredNode := func() Node {
		return readRequiredNodeImpl(buffer, constants, constantPoolOffset)
	}

	value := readRequiredNode().(*ProgramNode)

	return &ParseResult{
		Value:         value,
		Comments:      comments,
		MagicComments: magicComments,
		DataLoc:       dataLoc,
		Errors:        errors,
		Warnings:      warnings,
	}, nil
}

func readRequiredNodeImpl(buffer *SerializationBuffer, constants []*string, constantPoolOffset int) Node {
	nodeType := buffer.ReadRawByte()
	nodeID := buffer.ReadVarInt()
	location := buffer.ReadLocation()

	readRequiredNode := func() Node {
		return readRequiredNodeImpl(buffer, constants, constantPoolOffset)
	}

	readOptionalNode := func() Node {
		if buffer.ReadRawByte() != 0 {
			buffer.index--
			return readRequiredNode()
		}
		return nil
	}

	scanConstant := func(constantIndex int) string {
		if constants[constantIndex] == nil {
			value := buffer.ScanConstant(constantPoolOffset, constantIndex)
			constants[constantIndex] = &value
		}
		return *constants[constantIndex]
	}

	readRequiredConstant := func() string {
		return scanConstant(buffer.ReadVarInt() - 1)
	}

	readOptionalConstant := func() *string {
		index := buffer.ReadVarInt()
		if index == 0 {
			return nil
		}
		result := scanConstant(index - 1)
		return &result
	}

	readInteger := func() int64 {
		negative := buffer.ReadRawByte() != 0
		length := buffer.ReadVarInt()

		firstWord := uint64(buffer.ReadVarInt())
		if length == 1 {
			if negative && firstWord >= 0x80000000 {
				return -int64(firstWord)
			} else if negative {
				return -int64(firstWord)
			} else {
				return int64(firstWord)
			}
		}

		result := big.NewInt(0).SetUint64(firstWord)
		for i := 1; i < length; i++ {
			word := big.NewInt(0).SetUint64(uint64(buffer.ReadVarInt()))
			word.Lsh(word, uint(i*32))
			result.Or(result, word)
		}

		if negative {
			result.Neg(result)
		}
		return result.Int64()
	}

	var flags uint32

	switch nodeType {
	case 1:
		flags = uint32(buffer.ReadVarInt())
		return NewAliasGlobalVariableNode(nodeID, location, flags, readRequiredNode(), readRequiredNode(), buffer.ReadLocation())
	case 2:
		flags = uint32(buffer.ReadVarInt())
		return NewAliasMethodNode(nodeID, location, flags, readRequiredNode(), readRequiredNode(), buffer.ReadLocation())
	case 3:
		flags = uint32(buffer.ReadVarInt())
		return NewAlternationPatternNode(nodeID, location, flags, readRequiredNode(), readRequiredNode(), buffer.ReadLocation())
	case 4:
		flags = uint32(buffer.ReadVarInt())
		return NewAndNode(nodeID, location, flags, readRequiredNode(), readRequiredNode(), buffer.ReadLocation())
	case 5:
		flags = uint32(buffer.ReadVarInt())
		return NewArgumentsNode(nodeID, location, flags, func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}())
	case 6:
		flags = uint32(buffer.ReadVarInt())
		return NewArrayNode(nodeID, location, flags, func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation())
	case 7:
		flags = uint32(buffer.ReadVarInt())
		return NewArrayPatternNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation())
	case 8:
		flags = uint32(buffer.ReadVarInt())
		return NewAssocNode(nodeID, location, flags, readRequiredNode(), readRequiredNode(), buffer.ReadOptionalLocation())
	case 9:
		flags = uint32(buffer.ReadVarInt())
		return NewAssocSplatNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadLocation())
	case 10:
		flags = uint32(buffer.ReadVarInt())
		return NewBackReferenceReadNode(nodeID, location, flags, readRequiredConstant())
	case 11:
		flags = uint32(buffer.ReadVarInt())
		return NewBeginNode(nodeID, location, flags, buffer.ReadOptionalLocation(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), func() *RescueNode {
			if n := readOptionalNode(); n != nil {
				return n.(*RescueNode)
			}
			return nil
		}(), func() *ElseNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ElseNode)
			}
			return nil
		}(), func() *EnsureNode {
			if n := readOptionalNode(); n != nil {
				return n.(*EnsureNode)
			}
			return nil
		}(), buffer.ReadOptionalLocation())
	case 12:
		flags = uint32(buffer.ReadVarInt())
		return NewBlockArgumentNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadLocation())
	case 13:
		flags = uint32(buffer.ReadVarInt())
		return NewBlockLocalVariableNode(nodeID, location, flags, readRequiredConstant())
	case 14:
		flags = uint32(buffer.ReadVarInt())
		return NewBlockNode(nodeID, location, flags, func() []string {
			count := buffer.ReadVarInt()
			result := make([]string, count)
			for i := 0; i < count; i++ {
				result[i] = readRequiredConstant()
			}
			return result
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadLocation(), buffer.ReadLocation())
	case 15:
		flags = uint32(buffer.ReadVarInt())
		return NewBlockParameterNode(nodeID, location, flags, readOptionalConstant(), buffer.ReadOptionalLocation(), buffer.ReadLocation())
	case 16:
		flags = uint32(buffer.ReadVarInt())
		return NewBlockParametersNode(nodeID, location, flags, func() *ParametersNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ParametersNode)
			}
			return nil
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation())
	case 17:
		flags = uint32(buffer.ReadVarInt())
		return NewBreakNode(nodeID, location, flags, func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}(), buffer.ReadLocation())
	case 18:
		flags = uint32(buffer.ReadVarInt())
		return NewCallAndWriteNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), readRequiredConstant(), readRequiredConstant(), buffer.ReadLocation(), readRequiredNode())
	case 19:
		flags = uint32(buffer.ReadVarInt())
		return NewCallNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation(), readRequiredConstant(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}(), buffer.ReadOptionalLocation(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}())
	case 20:
		flags = uint32(buffer.ReadVarInt())
		return NewCallOperatorWriteNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), readRequiredConstant(), readRequiredConstant(), readRequiredConstant(), buffer.ReadLocation(), readRequiredNode())
	case 21:
		flags = uint32(buffer.ReadVarInt())
		return NewCallOrWriteNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), readRequiredConstant(), readRequiredConstant(), buffer.ReadLocation(), readRequiredNode())
	case 22:
		flags = uint32(buffer.ReadVarInt())
		return NewCallTargetNode(nodeID, location, flags, readRequiredNode(), buffer.ReadLocation(), readRequiredConstant(), buffer.ReadLocation())
	case 23:
		flags = uint32(buffer.ReadVarInt())
		return NewCapturePatternNode(nodeID, location, flags, readRequiredNode(), readRequiredNode().(*LocalVariableTargetNode), buffer.ReadLocation())
	case 24:
		flags = uint32(buffer.ReadVarInt())
		return NewCaseMatchNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() *ElseNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ElseNode)
			}
			return nil
		}(), buffer.ReadLocation(), buffer.ReadLocation())
	case 25:
		flags = uint32(buffer.ReadVarInt())
		return NewCaseNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() *ElseNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ElseNode)
			}
			return nil
		}(), buffer.ReadLocation(), buffer.ReadLocation())
	case 26:
		flags = uint32(buffer.ReadVarInt())
		return NewClassNode(nodeID, location, flags, func() []string {
			count := buffer.ReadVarInt()
			result := make([]string, count)
			for i := 0; i < count; i++ {
				result[i] = readRequiredConstant()
			}
			return result
		}(), buffer.ReadLocation(), readRequiredNode(), buffer.ReadOptionalLocation(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadLocation(), readRequiredConstant())
	case 27:
		flags = uint32(buffer.ReadVarInt())
		return NewClassVariableAndWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode())
	case 28:
		flags = uint32(buffer.ReadVarInt())
		return NewClassVariableOperatorWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode(), readRequiredConstant())
	case 29:
		flags = uint32(buffer.ReadVarInt())
		return NewClassVariableOrWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode())
	case 30:
		flags = uint32(buffer.ReadVarInt())
		return NewClassVariableReadNode(nodeID, location, flags, readRequiredConstant())
	case 31:
		flags = uint32(buffer.ReadVarInt())
		return NewClassVariableTargetNode(nodeID, location, flags, readRequiredConstant())
	case 32:
		flags = uint32(buffer.ReadVarInt())
		return NewClassVariableWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), readRequiredNode(), buffer.ReadLocation())
	case 33:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantAndWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode())
	case 34:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantOperatorWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode(), readRequiredConstant())
	case 35:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantOrWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode())
	case 36:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantPathAndWriteNode(nodeID, location, flags, readRequiredNode().(*ConstantPathNode), buffer.ReadLocation(), readRequiredNode())
	case 37:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantPathNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), readOptionalConstant(), buffer.ReadLocation(), buffer.ReadLocation())
	case 38:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantPathOperatorWriteNode(nodeID, location, flags, readRequiredNode().(*ConstantPathNode), buffer.ReadLocation(), readRequiredNode(), readRequiredConstant())
	case 39:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantPathOrWriteNode(nodeID, location, flags, readRequiredNode().(*ConstantPathNode), buffer.ReadLocation(), readRequiredNode())
	case 40:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantPathTargetNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), readOptionalConstant(), buffer.ReadLocation(), buffer.ReadLocation())
	case 41:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantPathWriteNode(nodeID, location, flags, readRequiredNode().(*ConstantPathNode), buffer.ReadLocation(), readRequiredNode())
	case 42:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantReadNode(nodeID, location, flags, readRequiredConstant())
	case 43:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantTargetNode(nodeID, location, flags, readRequiredConstant())
	case 44:
		flags = uint32(buffer.ReadVarInt())
		return NewConstantWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), readRequiredNode(), buffer.ReadLocation())
	case 45:
		buffer.ReadUint32() // skip serialized length
		flags = uint32(buffer.ReadVarInt())
		return NewDefNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() *ParametersNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ParametersNode)
			}
			return nil
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() []string {
			count := buffer.ReadVarInt()
			result := make([]string, count)
			for i := 0; i < count; i++ {
				result[i] = readRequiredConstant()
			}
			return result
		}(), buffer.ReadLocation(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation())
	case 46:
		flags = uint32(buffer.ReadVarInt())
		return NewDefinedNode(nodeID, location, flags, buffer.ReadOptionalLocation(), readRequiredNode(), buffer.ReadOptionalLocation(), buffer.ReadLocation())
	case 47:
		flags = uint32(buffer.ReadVarInt())
		return NewElseNode(nodeID, location, flags, buffer.ReadLocation(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), buffer.ReadOptionalLocation())
	case 48:
		flags = uint32(buffer.ReadVarInt())
		return NewEmbeddedStatementsNode(nodeID, location, flags, buffer.ReadLocation(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), buffer.ReadLocation())
	case 49:
		flags = uint32(buffer.ReadVarInt())
		return NewEmbeddedVariableNode(nodeID, location, flags, buffer.ReadLocation(), readRequiredNode())
	case 50:
		flags = uint32(buffer.ReadVarInt())
		return NewEnsureNode(nodeID, location, flags, buffer.ReadLocation(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), buffer.ReadLocation())
	case 51:
		flags = uint32(buffer.ReadVarInt())
		return NewFalseNode(nodeID, location, flags)
	case 52:
		flags = uint32(buffer.ReadVarInt())
		return NewFindPatternNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), readRequiredNode().(*SplatNode), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), readRequiredNode(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation())
	case 53:
		flags = uint32(buffer.ReadVarInt())
		return NewFlipFlopNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadLocation())
	case 54:
		flags = uint32(buffer.ReadVarInt())
		return NewFloatNode(nodeID, location, flags, buffer.ReadDouble())
	case 55:
		flags = uint32(buffer.ReadVarInt())
		return NewForNode(nodeID, location, flags, readRequiredNode(), readRequiredNode(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadOptionalLocation(), buffer.ReadLocation())
	case 56:
		flags = uint32(buffer.ReadVarInt())
		return NewForwardingArgumentsNode(nodeID, location, flags)
	case 57:
		flags = uint32(buffer.ReadVarInt())
		return NewForwardingParameterNode(nodeID, location, flags)
	case 58:
		flags = uint32(buffer.ReadVarInt())
		return NewForwardingSuperNode(nodeID, location, flags, func() *BlockNode {
			if n := readOptionalNode(); n != nil {
				return n.(*BlockNode)
			}
			return nil
		}())
	case 59:
		flags = uint32(buffer.ReadVarInt())
		return NewGlobalVariableAndWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode())
	case 60:
		flags = uint32(buffer.ReadVarInt())
		return NewGlobalVariableOperatorWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode(), readRequiredConstant())
	case 61:
		flags = uint32(buffer.ReadVarInt())
		return NewGlobalVariableOrWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode())
	case 62:
		flags = uint32(buffer.ReadVarInt())
		return NewGlobalVariableReadNode(nodeID, location, flags, readRequiredConstant())
	case 63:
		flags = uint32(buffer.ReadVarInt())
		return NewGlobalVariableTargetNode(nodeID, location, flags, readRequiredConstant())
	case 64:
		flags = uint32(buffer.ReadVarInt())
		return NewGlobalVariableWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), readRequiredNode(), buffer.ReadLocation())
	case 65:
		flags = uint32(buffer.ReadVarInt())
		return NewHashNode(nodeID, location, flags, buffer.ReadLocation(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadLocation())
	case 66:
		flags = uint32(buffer.ReadVarInt())
		return NewHashPatternNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation())
	case 67:
		flags = uint32(buffer.ReadVarInt())
		return NewIfNode(nodeID, location, flags, buffer.ReadOptionalLocation(), readRequiredNode(), buffer.ReadOptionalLocation(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation())
	case 68:
		flags = uint32(buffer.ReadVarInt())
		return NewImaginaryNode(nodeID, location, flags, readRequiredNode())
	case 69:
		flags = uint32(buffer.ReadVarInt())
		return NewImplicitNode(nodeID, location, flags, readRequiredNode())
	case 70:
		flags = uint32(buffer.ReadVarInt())
		return NewImplicitRestNode(nodeID, location, flags)
	case 71:
		flags = uint32(buffer.ReadVarInt())
		return NewInNode(nodeID, location, flags, readRequiredNode(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), buffer.ReadLocation(), buffer.ReadOptionalLocation())
	case 72:
		flags = uint32(buffer.ReadVarInt())
		return NewIndexAndWriteNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation(), buffer.ReadLocation(), func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}(), buffer.ReadLocation(), func() *BlockArgumentNode {
			if n := readOptionalNode(); n != nil {
				return n.(*BlockArgumentNode)
			}
			return nil
		}(), buffer.ReadLocation(), readRequiredNode())
	case 73:
		flags = uint32(buffer.ReadVarInt())
		return NewIndexOperatorWriteNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation(), buffer.ReadLocation(), func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}(), buffer.ReadLocation(), func() *BlockArgumentNode {
			if n := readOptionalNode(); n != nil {
				return n.(*BlockArgumentNode)
			}
			return nil
		}(), readRequiredConstant(), buffer.ReadLocation(), readRequiredNode())
	case 74:
		flags = uint32(buffer.ReadVarInt())
		return NewIndexOrWriteNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation(), buffer.ReadLocation(), func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}(), buffer.ReadLocation(), func() *BlockArgumentNode {
			if n := readOptionalNode(); n != nil {
				return n.(*BlockArgumentNode)
			}
			return nil
		}(), buffer.ReadLocation(), readRequiredNode())
	case 75:
		flags = uint32(buffer.ReadVarInt())
		return NewIndexTargetNode(nodeID, location, flags, readRequiredNode(), buffer.ReadLocation(), func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}(), buffer.ReadLocation(), func() *BlockArgumentNode {
			if n := readOptionalNode(); n != nil {
				return n.(*BlockArgumentNode)
			}
			return nil
		}())
	case 76:
		flags = uint32(buffer.ReadVarInt())
		return NewInstanceVariableAndWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode())
	case 77:
		flags = uint32(buffer.ReadVarInt())
		return NewInstanceVariableOperatorWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode(), readRequiredConstant())
	case 78:
		flags = uint32(buffer.ReadVarInt())
		return NewInstanceVariableOrWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode())
	case 79:
		flags = uint32(buffer.ReadVarInt())
		return NewInstanceVariableReadNode(nodeID, location, flags, readRequiredConstant())
	case 80:
		flags = uint32(buffer.ReadVarInt())
		return NewInstanceVariableTargetNode(nodeID, location, flags, readRequiredConstant())
	case 81:
		flags = uint32(buffer.ReadVarInt())
		return NewInstanceVariableWriteNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), readRequiredNode(), buffer.ReadLocation())
	case 82:
		flags = uint32(buffer.ReadVarInt())
		return NewIntegerNode(nodeID, location, flags, readInteger())
	case 83:
		flags = uint32(buffer.ReadVarInt())
		return NewInterpolatedMatchLastLineNode(nodeID, location, flags, buffer.ReadLocation(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadLocation())
	case 84:
		flags = uint32(buffer.ReadVarInt())
		return NewInterpolatedRegularExpressionNode(nodeID, location, flags, buffer.ReadLocation(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadLocation())
	case 85:
		flags = uint32(buffer.ReadVarInt())
		return NewInterpolatedStringNode(nodeID, location, flags, buffer.ReadOptionalLocation(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadOptionalLocation())
	case 86:
		flags = uint32(buffer.ReadVarInt())
		return NewInterpolatedSymbolNode(nodeID, location, flags, buffer.ReadOptionalLocation(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadOptionalLocation())
	case 87:
		flags = uint32(buffer.ReadVarInt())
		return NewInterpolatedXStringNode(nodeID, location, flags, buffer.ReadLocation(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadLocation())
	case 88:
		flags = uint32(buffer.ReadVarInt())
		return NewItLocalVariableReadNode(nodeID, location, flags)
	case 89:
		flags = uint32(buffer.ReadVarInt())
		return NewItParametersNode(nodeID, location, flags)
	case 90:
		flags = uint32(buffer.ReadVarInt())
		return NewKeywordHashNode(nodeID, location, flags, func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}())
	case 91:
		flags = uint32(buffer.ReadVarInt())
		return NewKeywordRestParameterNode(nodeID, location, flags, readOptionalConstant(), buffer.ReadOptionalLocation(), buffer.ReadLocation())
	case 92:
		flags = uint32(buffer.ReadVarInt())
		return NewLambdaNode(nodeID, location, flags, func() []string {
			count := buffer.ReadVarInt()
			result := make([]string, count)
			for i := 0; i < count; i++ {
				result[i] = readRequiredConstant()
			}
			return result
		}(), buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadLocation(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}())
	case 93:
		flags = uint32(buffer.ReadVarInt())
		return NewLocalVariableAndWriteNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode(), readRequiredConstant(), uint32(buffer.ReadVarInt()))
	case 94:
		flags = uint32(buffer.ReadVarInt())
		return NewLocalVariableOperatorWriteNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode(), readRequiredConstant(), readRequiredConstant(), uint32(buffer.ReadVarInt()))
	case 95:
		flags = uint32(buffer.ReadVarInt())
		return NewLocalVariableOrWriteNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode(), readRequiredConstant(), uint32(buffer.ReadVarInt()))
	case 96:
		flags = uint32(buffer.ReadVarInt())
		return NewLocalVariableReadNode(nodeID, location, flags, readRequiredConstant(), uint32(buffer.ReadVarInt()))
	case 97:
		flags = uint32(buffer.ReadVarInt())
		return NewLocalVariableTargetNode(nodeID, location, flags, readRequiredConstant(), uint32(buffer.ReadVarInt()))
	case 98:
		flags = uint32(buffer.ReadVarInt())
		return NewLocalVariableWriteNode(nodeID, location, flags, readRequiredConstant(), uint32(buffer.ReadVarInt()), buffer.ReadLocation(), readRequiredNode(), buffer.ReadLocation())
	case 99:
		flags = uint32(buffer.ReadVarInt())
		return NewMatchLastLineNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadStringField(flags))
	case 100:
		flags = uint32(buffer.ReadVarInt())
		return NewMatchPredicateNode(nodeID, location, flags, readRequiredNode(), readRequiredNode(), buffer.ReadLocation())
	case 101:
		flags = uint32(buffer.ReadVarInt())
		return NewMatchRequiredNode(nodeID, location, flags, readRequiredNode(), readRequiredNode(), buffer.ReadLocation())
	case 102:
		flags = uint32(buffer.ReadVarInt())
		return NewMatchWriteNode(nodeID, location, flags, readRequiredNode().(*CallNode), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}())
	case 103:
		flags = uint32(buffer.ReadVarInt())
		return NewMissingNode(nodeID, location, flags)
	case 104:
		flags = uint32(buffer.ReadVarInt())
		return NewModuleNode(nodeID, location, flags, func() []string {
			count := buffer.ReadVarInt()
			result := make([]string, count)
			for i := 0; i < count; i++ {
				result[i] = readRequiredConstant()
			}
			return result
		}(), buffer.ReadLocation(), readRequiredNode(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadLocation(), readRequiredConstant())
	case 105:
		flags = uint32(buffer.ReadVarInt())
		return NewMultiTargetNode(nodeID, location, flags, func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation())
	case 106:
		flags = uint32(buffer.ReadVarInt())
		return NewMultiWriteNode(nodeID, location, flags, func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), buffer.ReadLocation(), readRequiredNode())
	case 107:
		flags = uint32(buffer.ReadVarInt())
		return NewNextNode(nodeID, location, flags, func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}(), buffer.ReadLocation())
	case 108:
		flags = uint32(buffer.ReadVarInt())
		return NewNilNode(nodeID, location, flags)
	case 109:
		flags = uint32(buffer.ReadVarInt())
		return NewNoKeywordsParameterNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadLocation())
	case 110:
		flags = uint32(buffer.ReadVarInt())
		return NewNumberedParametersNode(nodeID, location, flags, buffer.ReadRawByte())
	case 111:
		flags = uint32(buffer.ReadVarInt())
		return NewNumberedReferenceReadNode(nodeID, location, flags, uint32(buffer.ReadVarInt()))
	case 112:
		flags = uint32(buffer.ReadVarInt())
		return NewOptionalKeywordParameterNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), readRequiredNode())
	case 113:
		flags = uint32(buffer.ReadVarInt())
		return NewOptionalParameterNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode())
	case 114:
		flags = uint32(buffer.ReadVarInt())
		return NewOrNode(nodeID, location, flags, readRequiredNode(), readRequiredNode(), buffer.ReadLocation())
	case 115:
		flags = uint32(buffer.ReadVarInt())
		return NewParametersNode(nodeID, location, flags, func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() *BlockParameterNode {
			if n := readOptionalNode(); n != nil {
				return n.(*BlockParameterNode)
			}
			return nil
		}())
	case 116:
		flags = uint32(buffer.ReadVarInt())
		return NewParenthesesNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadLocation(), buffer.ReadLocation())
	case 117:
		flags = uint32(buffer.ReadVarInt())
		return NewPinnedExpressionNode(nodeID, location, flags, readRequiredNode(), buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadLocation())
	case 118:
		flags = uint32(buffer.ReadVarInt())
		return NewPinnedVariableNode(nodeID, location, flags, readRequiredNode(), buffer.ReadLocation())
	case 119:
		flags = uint32(buffer.ReadVarInt())
		return NewPostExecutionNode(nodeID, location, flags, func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadLocation())
	case 120:
		flags = uint32(buffer.ReadVarInt())
		return NewPreExecutionNode(nodeID, location, flags, func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadLocation())
	case 121:
		flags = uint32(buffer.ReadVarInt())
		return NewProgramNode(nodeID, location, flags, func() []string {
			count := buffer.ReadVarInt()
			result := make([]string, count)
			for i := 0; i < count; i++ {
				result[i] = readRequiredConstant()
			}
			return result
		}(), readRequiredNode().(*StatementsNode))
	case 122:
		flags = uint32(buffer.ReadVarInt())
		return NewRangeNode(nodeID, location, flags, func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadLocation())
	case 123:
		flags = uint32(buffer.ReadVarInt())
		return NewRationalNode(nodeID, location, flags, readInteger(), readInteger())
	case 124:
		flags = uint32(buffer.ReadVarInt())
		return NewRedoNode(nodeID, location, flags)
	case 125:
		flags = uint32(buffer.ReadVarInt())
		return NewRegularExpressionNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadStringField(flags))
	case 126:
		flags = uint32(buffer.ReadVarInt())
		return NewRequiredKeywordParameterNode(nodeID, location, flags, readRequiredConstant(), buffer.ReadLocation())
	case 127:
		flags = uint32(buffer.ReadVarInt())
		return NewRequiredParameterNode(nodeID, location, flags, readRequiredConstant())
	case 128:
		flags = uint32(buffer.ReadVarInt())
		return NewRescueModifierNode(nodeID, location, flags, readRequiredNode(), buffer.ReadLocation(), readRequiredNode())
	case 129:
		flags = uint32(buffer.ReadVarInt())
		return NewRescueNode(nodeID, location, flags, buffer.ReadLocation(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadOptionalLocation(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadOptionalLocation(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), func() *RescueNode {
			if n := readOptionalNode(); n != nil {
				return n.(*RescueNode)
			}
			return nil
		}())
	case 130:
		flags = uint32(buffer.ReadVarInt())
		return NewRestParameterNode(nodeID, location, flags, readOptionalConstant(), buffer.ReadOptionalLocation(), buffer.ReadLocation())
	case 131:
		flags = uint32(buffer.ReadVarInt())
		return NewRetryNode(nodeID, location, flags)
	case 132:
		flags = uint32(buffer.ReadVarInt())
		return NewReturnNode(nodeID, location, flags, buffer.ReadLocation(), func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}())
	case 133:
		flags = uint32(buffer.ReadVarInt())
		return NewSelfNode(nodeID, location, flags)
	case 134:
		flags = uint32(buffer.ReadVarInt())
		return NewShareableConstantNode(nodeID, location, flags, readRequiredNode())
	case 135:
		flags = uint32(buffer.ReadVarInt())
		return NewSingletonClassNode(nodeID, location, flags, func() []string {
			count := buffer.ReadVarInt()
			result := make([]string, count)
			for i := 0; i < count; i++ {
				result[i] = readRequiredConstant()
			}
			return result
		}(), buffer.ReadLocation(), buffer.ReadLocation(), readRequiredNode(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}(), buffer.ReadLocation())
	case 136:
		flags = uint32(buffer.ReadVarInt())
		return NewSourceEncodingNode(nodeID, location, flags)
	case 137:
		flags = uint32(buffer.ReadVarInt())
		return NewSourceFileNode(nodeID, location, flags, buffer.ReadStringField(flags))
	case 138:
		flags = uint32(buffer.ReadVarInt())
		return NewSourceLineNode(nodeID, location, flags)
	case 139:
		flags = uint32(buffer.ReadVarInt())
		return NewSplatNode(nodeID, location, flags, buffer.ReadLocation(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}())
	case 140:
		flags = uint32(buffer.ReadVarInt())
		return NewStatementsNode(nodeID, location, flags, func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}())
	case 141:
		flags = uint32(buffer.ReadVarInt())
		return NewStringNode(nodeID, location, flags, buffer.ReadOptionalLocation(), buffer.ReadLocation(), buffer.ReadOptionalLocation(), buffer.ReadStringField(flags))
	case 142:
		flags = uint32(buffer.ReadVarInt())
		return NewSuperNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadOptionalLocation(), func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}(), buffer.ReadOptionalLocation(), func() Node {
			if n := readOptionalNode(); n != nil {
				return n
			}
			return nil
		}())
	case 143:
		flags = uint32(buffer.ReadVarInt())
		return NewSymbolNode(nodeID, location, flags, buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), buffer.ReadStringField(flags))
	case 144:
		flags = uint32(buffer.ReadVarInt())
		return NewTrueNode(nodeID, location, flags)
	case 145:
		flags = uint32(buffer.ReadVarInt())
		return NewUndefNode(nodeID, location, flags, func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadLocation())
	case 146:
		flags = uint32(buffer.ReadVarInt())
		return NewUnlessNode(nodeID, location, flags, buffer.ReadLocation(), readRequiredNode(), buffer.ReadOptionalLocation(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}(), func() *ElseNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ElseNode)
			}
			return nil
		}(), buffer.ReadOptionalLocation())
	case 147:
		flags = uint32(buffer.ReadVarInt())
		return NewUntilNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), readRequiredNode(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}())
	case 148:
		flags = uint32(buffer.ReadVarInt())
		return NewWhenNode(nodeID, location, flags, buffer.ReadLocation(), func() []Node {
			count := buffer.ReadVarInt()
			nodes := make([]Node, count)
			for i := 0; i < count; i++ {
				nodes[i] = readRequiredNode()
			}
			return nodes
		}(), buffer.ReadOptionalLocation(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}())
	case 149:
		flags = uint32(buffer.ReadVarInt())
		return NewWhileNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadOptionalLocation(), buffer.ReadOptionalLocation(), readRequiredNode(), func() *StatementsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*StatementsNode)
			}
			return nil
		}())
	case 150:
		flags = uint32(buffer.ReadVarInt())
		return NewXStringNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadLocation(), buffer.ReadStringField(flags))
	case 151:
		flags = uint32(buffer.ReadVarInt())
		return NewYieldNode(nodeID, location, flags, buffer.ReadLocation(), buffer.ReadOptionalLocation(), func() *ArgumentsNode {
			if n := readOptionalNode(); n != nil {
				return n.(*ArgumentsNode)
			}
			return nil
		}(), buffer.ReadOptionalLocation())
	default:
		panic(fmt.Sprintf("Unknown node type: %d", nodeType))
	}
}
